<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>Archives: 2019 | YangWC&#39;s Blog</title>
  
  
  <meta name="description" content="Personal blog website.">
  

  

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  

  
  <link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1//globalImage/logo.ico">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.4.19/css/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  
  <header class="l_header pure">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="pure"></div>
  </div>

	<div class="wrapper">
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href="/">
        
          YangWC's Blog
        
      </a>
			<div class="menu navgation">
				<ul class="h-list">
          
  					
  						<li>
								<a class="nav flat-box" href="/" id="home">
									<i class="fas fa-grin fa-fw"></i>&nbsp;主页
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/archives/" rel="nofollow" id="archives">
									<i class="fas fa-archive fa-fw"></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/categories/" rel="nofollow" id="blogcategories">
									<i class="fas fa-folder-open fa-fw"></i>&nbsp;大佬
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/tags/" rel="nofollow" id="blogtags">
									<i class="fas fa-folder-open fa-fw"></i>&nbsp;关于我
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索">
						<i class="icon fas fa-search fa-fw"></i>
					</form>
				</div>
			
			<ul class="switcher h-list">
				
					<li class="s-search"><a class="fas fa-search fa-fw" href="javascript:void(0)"></a></li>
				
				<li class="s-menu"><a class="fas fa-bars fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>

		<div class="nav-sub container container--flex">
			<a class="logo flat-box"></a>
			<ul class="switcher h-list">
				<li class="s-comment"><a class="flat-btn fas fa-comments fa-fw" href="javascript:void(0)"></a></li>
        
          <li class="s-toc"><a class="flat-btn fas fa-list fa-fw" href="javascript:void(0)"></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/" id="home">
								<i class="fas fa-clock fa-fw"></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/blog/archives/" rel="nofollow" id="blogarchives">
								<i class="fas fa-archive fa-fw"></i>&nbsp;文章归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/projects/" id="projects">
								<i class="fas fa-code-branch fa-fw"></i>&nbsp;开源项目
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/friends/" rel="nofollow" id="friends">
								<i class="fas fa-link fa-fw"></i>&nbsp;我的友链
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="https://xaoxuu.com/wiki/material-x/" rel="nofollow" id="https:xaoxuu.comwikimaterial-x">
								<i class="fas fa-book fa-fw"></i>&nbsp;主题文档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/" rel="nofollow" id="about">
								<i class="fas fa-info-circle fa-fw"></i>&nbsp;关于小站
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      <div class="l_main">
	
		
  <section class="post-list">
    
      
        
          
        
          
        
          
        
      
    
    
      
        
          <div class="post-wrapper">
            <article class="post reveal no-title">
  


  <section class="meta">
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/04/25/atmosphere/">
      2019-04-25
    </a>
  </h2>


      
      <div class="new-meta-box">
        
          
        
          
            
  <div class="new-meta-item author">
    <a href="http://yoursite.com" rel="nofollow">
      
        <img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1//globalImage/title.png">
      
      <p>WC Yang</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class="notlink">
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-04-25</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1 id="基于GPU预计算的大气层光效渲染"><a href="#基于GPU预计算的大气层光效渲染" class="headerlink" title="基于GPU预计算的大气层光效渲染"></a>基于GPU预计算的大气层光效渲染</h1><ul>
<li>前言</li>
<li>大气物理模型</li>
<li>渲染方程及其实现</li>
<li>实验结果</li>
<li>参考文献<br><img src="https://img-blog.csdnimg.cn/20190106174235322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjE1OTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190106174311196.gif" alt="在这里插入图片描述"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2>本文叙述基于物理模型的大气层光效渲染，不仅考虑单重散射，而且也尝试实现多重散射的效果。主要参考论文为Eric Bruneton和Fabrice Neyret的《Precomputed Atmospheric Scattering》。<strong>博文如果错误，欢迎指出，非常感谢</strong>。此外，本文较多物理理论和数学推导，代码也比较多。<br><strong>代码已放至本人的github上：<a href="https://github.com/ZeusYang/Atmosphere" target="_blank" rel="noopener">https://github.com/ZeusYang/Atmosphere</a></strong></li>
</ul>
<h2 id="大气物理模型"><a href="#大气物理模型" class="headerlink" title="大气物理模型"></a>大气物理模型</h2><p><strong>1、大气散射现象</strong></p>
<p>大气散射是指，太阳光在射入大气层时，与大气中的空气分子或空气溶胶等发生相互作用，使得入射的光能以一定的规律在各个方向上进行重新分布的现象。太阳光在射入大气层时，遇到大气分子、尘埃、雨滴等颗粒后，都会发生散射现象。其中一部分的光能会被这些粒子吸收转化为热能，而另一部分光能则会以该粒子为中心，向四面八方扩散开来。所以，在经过了大气的散射作用之后，有部分太阳光将无法抵达地球表面。大气散射在自然界中是一种十分重要而又普遍存在的物理现象，人们平时用肉眼观察到的光很大一部分都是散射光。如果没有大气散射，那么只要不是太阳光直接照射到的位置，都将是完全黑暗的。</p>
<p><strong>2、空气物理模型</strong></p>
<p>空气中的介质颗粒根据其直径大小的不同可分为两种：直径远小于光线波长的空气微粒、与直径与光线波长相当的空气溶胶。由前者引起的散射我们称为Rayleigh散射，它是导致晴朗天空呈现蓝色的主要原因。由后者引起的散射我们称为Mie散射，它是导致阴霾的天空呈现灰色的原因，因为阴天的空气中存在大量与光波直径相当的水滴。</p>
<p><strong>①Rayleigh散射</strong>：由空气中远小于波长的微粒(如空气分子)引起的散射称作瑞利散射。Rayleigh散射强度与光线波长的四次方成反比，这意味着白光中波长较短的颜色光(蓝色)会比波长较长的光(红色)有更强的散射强度，导致天空在白天偏向蓝色，而在黄昏偏向橙红色。 当日出或日落的时候，由于太阳的位置接近地平线，阳光斜射入大气，会在大气层中穿过很长的距离。在这个过程中，太阳光中的蓝色光几乎都会被散射殆尽无法抵达人眼，只剩下了波长较长的红色光，所以在太阳及其周围的天空都会呈现橘红色。</p>
<p>Rayleigh散射的散射系数可以使用如下公式计算：</p>
<p>$\beta_R(\theta)=\frac{2\pi^2(n^2-1)^2}{3N\lambda^4}p_R(\theta)$    （1）</p>
<p>其中$\theta$是视线与太阳光线的夹角，$N$是大气分子密度，$n$是大气的折射率，$\lambda$是入射光的波长，$p_R(\theta)$是单位化的相位函数。由上可知，Rayleigh散射明显与波长的四次方成反比，在实现中我们可用一个RGB向量来表示，散射系数可表示为：</p>
<p>$\beta_R.rgb=(5.81,13.5,33.1)\times10^{-6}$    （2）</p>
<p>由于Rayleigh散射几乎是各向同性的，即光线会被粒子向各个方向均匀散射，其相位函数可以表示为：</p>
<p>$p_R(\theta)=\frac{3}{16\pi}(1+cos^2\theta))$    （3）</p>
<p>相位函数描述了散射的方向特征，也就是在视线与光线夹角为$\theta$的情况，在总共散射的光线中有多少被散射到视线方向上，可以理解为概率或者比例。</p>
<p><strong>②</strong> <strong>Mie散射</strong>：在空气中直径与波长相当的微粒(如尘埃、雾滴等)所导致的散射现象称作Mie散射。与Rayleigh散射不同，Mie散射与波长无关，散射方向表现出明显的各向异性，光线会被粒子更多的向后方散射。而当阴雨天气时，空气中存在大量的水滴颗粒，Mie散射导致天空呈现灰白色。现今经常出现的雾霆天气，同样是因为空气中悬浮的大颗粒过多而导致的Mie散射现象。</p>
<p>由于Mie散射与波长无关，故可以用标量表示，Mie散射系数为：</p>
<p>$\beta_M.rgb=2.0\times10^{-5}$    （4）</p>
<p>Mie散射的方向是各向异性的，光线会被更多的向后方散射，其相位函数为：</p>
<p>$p_M(\theta)=\frac{1}{4\pi}\frac{3(1-g^2)}{2(2+g^2)}\frac{1+cos^2\theta}{(1+g^2-2gcos\theta)^{\frac{3}{2}}}$    （5）</p>
<p>在公式（5）中，$\theta$是光线方向与视线方向的夹角，而$g$表示散射的对称性。若$g$是正值，则大多数光线会被粒子向后方散射；若$g$是负值，则更多的光线会被向前方散射。通常，g取值[-0.75,0.99]。</p>
<p><img src="https://img-blog.csdnimg.cn/20190106184450910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjE1OTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>③</strong> <strong>大气密度</strong>：对于瑞利散射和米氏散射，它们对太阳光的散射作用都和空气粒子的密度有关。许多大气模型都假设摄像机总是在地面上或者是在十分接近地面的位置，这样就可以认为空气具有一个恒定的粒子密度，这就在很大程度上简化了Nishita在1993年提出的散射积分方程，并在近地空间可以得到很好的渲染效果。然而在远离地表的高空，这种做法得到的渲染结果并不准确。</p>
<p>实际中的大气密度在地球引力的作用下，越靠近地表空气密度越高，越远离地表空气越稀薄。所以，我们假定空气粒子的密度是沿着海拔高度h呈指数递减的：</p>
<p>$\rho=\rho_0e^{-\frac{h}{H}}$        其中$\rho_0$是在海平面的空气密度            （6）</p>
<p>$h$为当前采样点的海拔高度，$H$是缩放高度（在实现中可设为大气层高度）。理论上说大气层并没有确定的高度，但在实现中我们需要一个统一高度来渲染天空弯顶，这样空气密度随着高度的增加而呈指数递减。对于Rayleigh散射与Mie散射我们分别使用不同的缩放高度:$H_R=7994km$，$H_M=1200km$。这是因为影响Mie散射的大颗粒(尘埃、水滴等)更多的存在于近地表的对流层中，再往上Mie散射效果不明显，但Rayleigh散射的作用依然存在。</p>
<p><strong>3、光线内散射</strong></p>
<p>太阳光在大气中传输的时候会与空气中的微粒产生交互作用。有两种重要的交互方式:<strong>散射</strong>，它改变了光线的方向；<strong>吸收</strong>，它将光能吸收并转变为其它形态的能量（如热能）。而散射效果对场景中物体的影响又分为两个方面：一方面是一部分由物体反射的光被散射到视线之外，并不能到达摄像机，因而被衰减，称作外散射；另一方面是一部分太阳光被空气中的粒子散射正对向摄像机，这些正朝向视线的散射被称作<strong>内散射</strong>。<br><img src="https://img-blog.csdnimg.cn/20190106184629851.png" alt="在这里插入图片描述"></p>
<p>最后抵达视点被人眼所观察到的光线可分为两部分：衰减后的物体反射辐射度、被内散射的大气散射辐照度。</p>
<p>$L_{viewer}=L_{object}\cdot e^{-T(O\to C)}+L_{inscatter}$    （7）</p>
<p>其中$L_{viewer}$为最终抵达摄像机的总光强，$L_{object}$为物体的反射光（当视线不与物体相交时则为$0$），$L_{inscatter}$为从O到C点路径上所有内散射光线的总和，这里暂时忽略太阳直射。<br><img src="https://img-blog.csdnimg.cn/20190106184711259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjE1OTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>公式（7）中的$e^{-T(O\to C)}$是光线从O点到C点的衰减系数，其中$T(O\to C)$被称作光学深度（Optical Length)，它是散射系数与密度乘积在整条路径上的积分。</p>
<p><strong>①</strong> <strong>光学深度</strong>：在上图中，大气层内有一点$P$，它在视线$CO$上。太阳光线照向地球，在穿过大气层的时候会受空气分子和空气溶胶的散射作用而发生衰减（外散射的影响），最终到达$P$点处的光能总量为：</p>
<p>$L_p=L_{sun}e^{-T(A\to P)}$    （8）</p>
<p>其中$L_{sun}$是太阳光到达大气层前的初始辐射度。上图中$A$点是光线到达$P$点之前与大气层的交点，则$T(A\to P)$被称作$A$点到$P$点的<strong>光学深度</strong>（Optical Depth），它本质上就是$A$点到$P$点这条路径上散射系数乘上空气密度的积分（包含Rayleigh散射与Mie散射）：</p>
<p>$T(A\to P)=\int_A^P(\beta_R^ee^{-\frac{h(t)}{H_R}}+\beta_M^ee^{-\frac{h(t)}{H_M}})dt$    （9）</p>
<p>公式（9）中的参数前面都已提到过：$\beta_R^e$即Rayleigh散射系数，$\beta_M^e$是Mie散射系数，而形如$e^{-\frac{h}{H}}$的则分别是Rayleigh散射粒子密度分布函数、Mie散射粒子密度分布函数。在这里我们散射系数当作一个在海平面上的常数值，则式（9）可变为如下形式：</p>
<p>$T(A\to P)=\beta_R^e\int_A^Pe^{-\frac{h(t)}{H_R}}dt+\beta_M^e\int_A^Pe^{-\frac{h(t)}{H_M}}dt$    （10）</p>
<p>所以我们只需对AP路径上的空气密度进行积分，这个积分值被称<strong>光学长度</strong>（Optical Length），直观的意义就是在光线照射的路径上空气粒子的总量。</p>
<p><strong>②</strong> <strong>散射系数</strong>：散射系数决定了散射介质对光线的散射的强弱程度，也反应了光线在通过该介质时的衰减程度。我们已经在前面提到，Rayleigh散射对不同波长的光线散射强度不同，在实现中我们可以将其在海平面处的散射系数设为一个三维向量：</p>
<p>$\beta_R.rgb=(5.81,13.5,33.1)\times10^{-6}$</p>
<p>而Mie散射对波长的变化影响不明显，所以可以将其在海平面上的散射系数设为标量：</p>
<p>$\beta_M.rgb=2.0\times10^{-5}$</p>
<p><strong>③</strong> <strong>相位函数</strong>：己知入射光能和介质的散射系数，我们就可以计算出有多少光线会被介质散射出去。但并非所有的光线在散射之后都会朝向摄像机，有一部分会被散射到其它方向，无法被肉眼所观察到(称作外散射)。所以为了计算内散射的光线量，还需要有另外一个因子描述这个物理量。而相位函数$p(\theta)$则描述了在该点有多少光线散射之后朝向摄像机，其中的参数$\theta$是太阳光到点$P$的向量$LP$与点$P$到摄像机位置的向量$PC$的夹角，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20190106184754557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjE1OTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>相位函数是标准化的，函数本身在所有方向的积分为$1$。Rayleigh散射特点是各向同性，光线会以介质粒子为中心均匀地向各个方向散射，其相位函数是前面提到的公式（3）。而Mie散射呈现明显的各向异性，光线会被更多的介质粒子向后方散射，其相位函数是前面提到的公式（5）。</p>
<p><strong>④</strong> <strong>单重散射</strong>：目前我们讨论的都是单重散射，即太阳光在到达视点之前只会进行一次散射。点$P$的内散射光在达到视点前还会受到空气颗粒影响而衰减，衰减程度取决于点$P$到点$C$（视点）的光学深度$T(P\to C)$，因而衰减因子为$e^{-T(P\to C)}$。</p>
<p>所以最终达到视点C的内散射方程如下：</p>
<p>$L_{inscatter}=\int_C^OL_{sun}\cdot e^{-T(A(s)\to P(s))}\cdot e^{-T(P(s)\to C)}\cdot (\beta_R^se^{-\frac{h(s)}{H_R}}p_R(\theta)+\beta_M^se^{-\frac{h(s)}{H_M}}p_M(\theta))ds$（10）</p>
<p>上式中有两个衰减因子，一个是从$A$到$P$的衰减因子，一个是从$P$到$C$的衰减因子。整个积分路径是从$O$到$C$，这一方程描述了从$O$到$C$路径上全部内散射光的总和。</p>
<p><img src="https://img-blog.csdnimg.cn/20190106185030173.png" alt="在这里插入图片描述"></p>
<p>内散射积分公式（10）中，在积分路径OC上太阳光与视线的夹角$\theta$保持不变，因此有必要将相位函数$p(\theta)$从积分内部中提取出来。而太阳光是平行光，$L_{sun}$是大阳光在大气层顶层的辐射度，视为常量，也可从积分内部提取出来。散射系数亦如此。故公式（10）可变为如下：</p>
<p>$L_{inscatter}=L_{sun}p_R(\theta)\beta_R^s\int_C^Oe^{-T(A(s)\to P(s))-T(P(s)\to C)}e^{-\frac{h(s)}{H_R}}ds+L_{sun}p_M(\theta)\beta_M^s\int_C^Oe^{-T(A(s)\to P(s))-T(P(s)\to C)}e^{-\frac{h(s)}{H_M}}ds$    （11）</p>
<p>故要计算一个视点到物体之间的内射光线，我们需要对视线路径上每一点的衰减因子以及空气密度进行积分。</p>
<p><strong>⑤</strong> <strong>多重散射</strong>：光线在传输过程中被空气中的一个粒子影响，称为光的一次散射。当空气中大颗粒较多时，被粒子散射的光又会被散射方向上的其它粒子再次散射，这个过程称为<strong>多重散射</strong>（Multiple Scattering)。在晴朗干净的天空中，由于空气中大粒子的数量较少，多重散射的作用不是很明显。而在空气浑浊或黄昏时，多重散射会对场景的真实性产生较明显的影响。</p>
<p>我们前面的讨论都是单一散射模型。这一模型在白天的时候比较合理，这一假设在白天的时候比较合理，因为在白天的时候太阳光强度较高，多重散射作用不明显;而在傍晚的时候，由于太阳直射光强度变弱，多重散射对场景的影响会变得更加重要，在渲染真实图像中必须加以考虑。即便如此，单一散射模型在此时依旧可以提供一个相对较好的结果。</p>
<p>关于多重散射的文献资料较少，因为单重散射模型目前已经有了不错的渲染结果。在我阅读的这篇论文《Precomputed Atmospheric Scattering》中考虑了多重散射的情况，较为复杂，在后面论述。</p>
<p><strong>⑥</strong> <strong>体积光</strong>：当光线照射到遮挡物时，一部分光线会从物体的边缘和空隙中穿过，并产生很明显的光柱效果，在视觉上给人以很强的体积感，所以称之为<strong>体积光</strong>（Light shaft)。体积光在自然界中是十分常见的现象，如太阳光从云隙中透过时产生的云隙光，森林中阳光从树叶中穿过产生的光柱。体积光现象有时又被称作“丁达尔效应”。其理论基础同样是光线的散射原理，可以使用前面描述的Mie散射理论来解释。对于溶胶，其粒子大小通常与可见光的波长相当，所以在光线穿过气溶胶时，会发生明显的Mie散射现象，产生肉眼可观察到的光柱体。<br><img src="https://img-blog.csdnimg.cn/20190106185116124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjE1OTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="渲染方程及其实现"><a href="#渲染方程及其实现" class="headerlink" title="渲染方程及其实现"></a>渲染方程及其实现</h2><p>为了便于论述，我们记$L(x,v,s)$为视点$x$从方向$v$接收的总的辐射度，其中$s$是太阳方向向量。记$x_0(x,v)$为视线$v$的终点（通常为地面、物体或大气顶层）。$x$到$x_0$之间的衰减因子$T$、$x_0$处的反射辐射度$I$、在某一点$y$向$-v$内散射的辐射度$J$定义如下：<br><img src="https://img-blog.csdnimg.cn/20190106185159448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjE1OTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>$T(x,x_0)=exp(-\int_x^{x_0}(\beta_R^e\rho_R(y)+\beta_M^e\rho_M(y))dy)$    （12）</p>
<p>$I<a href="x_0,s">L</a>=\frac{\alpha(x_0)}{\pi}\int_{2\pi}L(x_0,\omega,s)\cdot n(x_0)d\omega ,or  0$    （13）</p>
<p>$J<a href="y,v,s">L</a>=\int_{4\pi}\sum_{i\in{R,M}}\beta_i^s(y)p_i(v\cdot w)L(y,\omega,s)d\omega$        （14）</p>
<p>公式（12）、（13）、（14）对应上图的（a）、（b）、（c）。有了以上的函数表示，现在我们可以定义渲染方程了。</p>
<p><strong>1、渲染方程</strong></p>
<p>$L(x,v,s)=L_0(x,v,s)+R<a href="x,v,s">L</a>+S<a href="x,v,s">L</a>$    （15）</p>
<p>$L_0(x,v,s)=T(x,x_0)L_{sum}, or 0$    （16）</p>
<p>$R<a href="x,v,s">L</a>=T(x,x_0)I<a href="x_0,s">L</a>$        （17）</p>
<p>$S<a href="x,v,s">L</a>=\int_x^{x_0}T(x,y)J<a href="y,v,s">L</a>dy$    （18）</p>
<p>$L(x,v,s)$为视点$x$从方向$v$接收的总的辐射度。$L_0$是到达$x$的太阳直射光，因此当视线$v$与太阳方向向量$s$不相等时$L_0$为0（又或者太阳被遮挡了）。$R[L]$是在点$x_0$收到的反射的辐射度。$S[L]$则是从$x_0$到$x$路径上接收的内散射光。从渲染方程可以看出，衰减因子$T$无处不在，这是因为在大气层内，涉及到光线的传播都要考虑外散射以及光线被吸收的影响。</p>
<p>这个渲染方程计算量非常大，尤其是公式（18），一重积分内部还嵌套了两重积分。纯粹地暴力计算对于实时渲染来说几乎不可能。为了能够实现实时渲染大气层，不少论文提出了查找表的优化思想，这是一种基于预先计算的优化方法。但大多数的论文都只是考虑了单重散射，我阅读的这篇论文《Precomputed Atmospheric Scattering》将多重散射也考虑进去了，提出了一种4维查找表的方法，在后面论述。除此之外，渲染方程也设计到大量的积分计算。为此，我们采用<strong>梯形法则</strong>和<strong>光线步进</strong>（Ray Marching）来快速计算数值积分。</p>
<p><strong>下面的叙述部分，由于代码比较繁多，我尽量用伪代码描述</strong>。</p>
<p><strong>2、光线衰减因子</strong></p>
<p>前面已经提到过，从$x$的$x_0$光线衰减因子如下（实际计算中把散射系数提出积分外）：</p>
<p>$T(x,x_0)=exp(-\int_x^{x_0}(\beta_R^e\rho_R(y)+\beta_M^e\rho_M(y)dy)$</p>
<p>每一帧去计算它并不现实，因此早在1994年就有人提出了查找表的优化方法。如下图所示，假设我们要计算$p$到$q$的衰减因子。$i$是$p$点沿视线与大气顶层的交点。则有：$p$到$i$的衰减因子=$p$到$q$的衰减因子乘上q到i的衰减因子（<strong>这里相乘的原因是决定衰减因子的光学深度是在其公式的指数位置上，衰减因子相乘等于相应的指数相加</strong>）。那么$p$到$q$的衰减因子=$p$到$i$的衰减因子除以$q$到$i$的衰减因子。因此只要知道点到大气顶层的衰减因子，就可计算任两点之间的光线衰减因子。<br><img src="https://img-blog.csdnimg.cn/20190106185316143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjE1OTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>此外，O’ Neil发现了衰减因子的计算取决于两个参数:当前点的高度$r$和视线的天顶角$\theta$。也就是说我们可以通过预先计算($r$,$\theta$)的全部组合决定的衰减因子存放到一张纹理中，后面的实时计算直接根据需要计算的($r$,$\theta$)查找这张纹理。为了方便，我们取参数($r$,$cos\theta$)，记$u=cos\theta$。</p>
<p><strong>①</strong> <strong>点p到大气顶层的距离</strong>：即计算向量$pi$的长度。建立如图所示的坐标系，点$O$为地心，则向量$pi$距离点$p$为$d$的一点坐标($x$,$z$)为:($d\sqrt{1-u^2}$,$r+du$)</p>
<p>那么设距离$d$为向量$pi$的长度，则($x$,$z$)即为点$i$的坐标。已知大气层半径为$r_{top}$，则由勾股定理有：$(d\sqrt{1-u^2})^2+(r+du)^2=r_{top}^2$，整理后即为二元一次方程：$d^2+2rud+r^2=r_{top}^2$，其中$r$、$u$和$r_{top}$已知，可求出距离$d$。同样可通过该二元一次方程的判别式判断是否有解，从判断射线($r$,$u$)是否与大气层（或地表）存在交点。</p>
<p>点p到地球表面交点的距离同理，将$r_{top}$换成$r_{bottom}$即可。</p>
<p><strong>②</strong> <strong>计算点p到i（与大气顶层的交点）的光学长度</strong>：计算衰减因子需要计算点$p$到$i$的光学深度，也就是对$p$到$i$的散射系数和空气密度乘积进行积分。其中散射系数（包括Rayleigh散射和Mie散射）系数我们取海平面上相应的散射系数，故我们只需对$p$到$i$路径的空气密度进行积分，这就是光学长度–$\int_p^i\rho(s)ds$。</p>
<p>计算积分我们采用梯度法，以光线步进（Ray Marching）循环采样计算累加和。如下图所示，假设我们取$P_1$-$P_5$这五个采样点，依次计算每个点的空气密度乘上积分步长，累加计算。<br><img src="https://img-blog.csdnimg.cn/20190106185443195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjE1OTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190106185535773.png" alt="在这里插入图片描述"><br>计算Rayleigh光学长度和Mie光学长度均采用以上的方法计算。分别采用以上方法计算之后，再乘上相应的散射系数，就是光学深度，然后衰减因子就按照公式（12）计算即可。</p>
<p><strong>③</strong> <strong>坐标映射</strong>：我们把预计算的结果存入一张2D的纹理中，所以需要将($r$,$u$)映射到纹理坐标($u_r$,$v_u$)中。我们知道纹理坐标数值范围是$[0,1]$，故对于一个数值$x$，我们首先要将$x$映射到$[0,1]$，设$x$的值域为$[min,max]$。则令$x = (x-min)/(max-min)$，可将其映射到$[0,1]$。</p>
<p>然而值得注意的是，将$x$映射到$[0,1]$之后，边界部分我们应该要去掉。这是因为我们在对纹理进行查找时需要线性插值，边界部分会产生一些外推值。为了避免这种情况，我们进一步令$x$（此时$x$已属于$[0,1]$）：</p>
<p>$x=\frac{1}{2n}+x*(1.0-\frac{1}{n)}$，其中$n$是纹理的大小，$\frac{1}{n}$就是一个纹素的大小。如此我们将$x$由$[0,1]$映射到了$[\frac{1}{2n},1-\frac{1}{2n}]$上，去掉了边界部分。</p>
<p>接下来我们要将$r$映射到$u$，而$u$映射到$v$。</p>
<p>对于$r$，它代表当前点到地心的距离，显然其值域为$[r_{bottom},r_{top}]$。然而为了更高的精度（避免r接近地表时失真），我们采用了一个非线性映射的方式。如下图所示，实际上对于每个不同$r$，都对应着一个不同的$\rho$，它是视点$p$到过视点的与地表相切的切线的切点的距离，$\rho$的最大值则是如下图中的$H$（最小值为$0$）。故对于$r$我们采用该映射方式映射到$u_r$：$u_r=\frac{\rho}{H}$。</p>
<p>对于天顶角$u$，每个特定的天顶角，都对应着不同的距离$d$（视点到大气顶层交点的距离）。$d$的下界为$r-r_{bottom}$，上界为为$\rho+H$。故其映射方式为：$v_u=\frac{d-d_{min}}{d_{max}-d_{min}}$。<br><img src="https://img-blog.csdnimg.cn/20190106185720990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjE1OTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190106185839192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjE1OTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>至于计算($\rho$,$H$)，可以通过两个三角形勾股定理，不再赘述。我们将($r$,$u$)映射到2D纹理坐标，同样也需要逆过程，这将在预计算阶段用到。逆过程我们将上面的几个公式反推一下即可，也不再赘述。</p>
<p><strong>④</strong> <strong>点p到太阳的光线衰减因子</strong>：我们需要计算点$p$到太阳的光线衰减因子。太阳不是一个点光源，而是一个圆盘发光体。因此$p$到太阳的光线衰减因子，是以太阳圆盘为区域的衰减因子的积分。在这里我们把太阳圆盘区域上的衰减因子视作相同的常量。故该值等于衰减因子乘上太阳圆盘在水平线上部分占整个圆盘的比例。</p>
<p>设过视点p与地表相切的切线为l。当太阳天顶角$\theta_s$大于切线l的天顶角$\theta_h$+太阳的角半径$\alpha_s$时，这部分比例为$0$；当$\theta_s$小于$\theta_h-\alpha_s$时为$1$。故我们可以用相应的余弦值来定性地衡量这一比例（注意余弦函数在$[0,\pi]$递减）。</p>
<p>当$cos\theta_s\leq cos(\theta_h+\alpha_s)\approx cos\theta_h-\alpha_s sin\theta_h$时，为$0$；（约等符号是因为$\alpha_s→0$)</p>
<p>当$cos\theta_s\geq cos(\theta_h-\alpha_s)\approx cos\theta_h+\alpha_s sin\theta_h$时，为$1$。</p>
<p>中间部分则用埃尔米特（Hermite）插值，可直接用GLSL的smoothstep函数。<br><img src="https://img-blog.csdnimg.cn/20190106190021330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjE1OTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>3、单重散射</strong></p>
<p>单重散射是指光线在到达视点之前只发生了一次散射。接下来将叙述如何计算单重散射，如何将其映射到3D纹理上。如下图，$u$是视点$p$处实现的天顶角的$cos$值，假设太阳到达$q$点发生了散射，$pq$的距离为$d$，$u_s$是太阳光方向向量在$p$处的天顶角$cos$值，$w_s$是太阳光方向向量，$v$是太阳光方向向量与视线$pq$夹角的$cos$值，$u_{s,d}$是太阳光方向向量在$q$处的天顶角$cos$值。$r$是点$p$到地心的距离，$r_d$是点$q$到地心的距离。<br><img src="https://img-blog.csdnimg.cn/20190106190141943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjE1OTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>到达p点的内散射辐射度为：</p>
<p>$L_{inscatter}=\int_P^iL_{sun}\cdot e^{-T(A(s)\to P(s))}\cdot(\beta_R^se^{-\frac{h(s)}{H_R}}p_R(\theta)+\beta_M^se^{-\frac{h(s)}{H_M}}p_M(\theta))ds$</p>
<p>其中的$L_{sun}$和两个相位函数我们先不管，计算内散射辐射度我们需要多p到大气顶层交点之间对光线衰减因子和空气密度进行积分。以上图积分点$q$为例，我们需要$q$到太阳的光线衰减因子、$p$到$q$的光线衰减因子，而这两个值可直接借助查找我们前面已经计算好的纹理获得。故对一个积分采样点，其积分函数值计算的伪代码如下。<br><img src="https://img-blog.csdnimg.cn/2019010619023596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjE1OTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>①</strong> <strong>内散射积分</strong>：同样地，我们采用梯度法和光线步进法进行积分。积分路径的终端实际上不一定是大气顶层，有可能是地表，但积分过程都是一样。<br><img src="https://img-blog.csdnimg.cn/20190106190332771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjE1OTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>②</strong> <strong>相位函数</strong>：对于Rayleigh相位函数和Mie相位函数，直接分别套用公式（3）和公式（5）。<br><img src="https://img-blog.csdnimg.cn/20190106190426155.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190106190438977.png" alt="在这里插入图片描述"></p>
<p><strong>③</strong> <strong>坐标映射</strong>:计算单重散射积分同样非常耗费性能。因此我们一样使用预计算查找表的方法计算单重散射积分。与光线衰减因子不同的是，单重散射积分取决于四个参数，就是前面提到的($r$,$u$,$u_s$,$v$)，这意味着我们需要将这四个参数映射到4D纹理坐标。</p>
<p>对于$(r,u)$的坐标映射，与前面的提到的映射方法相同，这里不再赘述。</p>
<p>对于$v$，其值域为$[-1,1]$，我们做简单的线性映射，令$u_v=\frac{1+v}{2}$。</p>
<p>对于$u_s$，通过非线性映射，如下所示（原因不明）：</p>
<p>$a=\frac{d-d_{min}}{d_{max}-d_{min}}$，    $A=\frac{-2.0u_{s_min}r_{bottom}}{d_{max}-d_{min}}$，    $u_{u_s}=\frac{max(1.0-\frac{a}{A},0.0)}{1.0+a}$</p>
<p>而逆过程则直接根据上述公式倒推即可。现在我们把($r$,$u$,$u_s$,$v$)映射到了4D纹理坐标，然而实际上纹理维度最多3D。故映射到4D之后，我们还要将4D坐标映射到3D坐标。为此，我们可通过取整、取模来实现。</p>
<p><strong>4、多重散射</strong></p>
<p>在考虑多重散射的时候，渲染方程就变为：</p>
<p>$L=L_0+L_1+L_2+…=L_0+L_*$    （18）</p>
<p>其中$L_i$代表光线散射$i$重。事实上，在白天的时候多重散射的效果微乎其微，而在傍晚的时候效果较为明显一点。因此实现多重散射是性价比非常低的事情，计算量比单重散射多很多，但是渲染的提升效果可以说是非常小了。</p>
<p>多重散射的来源有两个：一个是经过$(n-1)$次散射之后再发生了一次散射，而另一个是从地面的反射的光线。在这里我们先暂时不讨论地面的反射。多重散射可以分解成$2$重散射、$3$重散射、$4$重散射…等等$n$重散射的累加和。而且，第$i$重散射可以根据第$i-1$重散射计算得到。</p>
<p>先讨论视点$p$接收到的第$n$重散射，设视点$p$沿视线$v$的终端为$i$，$q$为路径$pi$上的任意一点。对于$q$点，我们要计算$q$点接收的经过$n-1$重散射（第$n$重散射时发生内散射，射向视点）的辐射度，这需要对整个球体方向进行积分，是二重积分的计算量。然后我们需要对路径$pi$上所有的$q$点（$q$点是$pi$上的一点）进行积分，是一重积分的计算量。由此我们可以知道，计算第$n$重散射，一重积分里面嵌套了两重积分，为三重积分的计算量。如果对于每一重散射的计算，都从头开始的话，这必然导致很大的计算量，而且有不少重复的计算。</p>
<p>为此，对于多重散射，我们采用迭代的方式来一重一重地计算，而且同样采用查找表的优化方法。每计算一重散射，我们把结果存储到纹理中，然后下一重的散射计算就直接查找这个纹理。如此，我们通过迭代的方式避免前一重的散射计算。</p>
<p>然而即便如此，以三重积分的方式计算第n重散射依然存在着不少重复的部分。如下图所示，设$L$为$q$点接收的经过$n-1$重散射最后第$n$重散射到$-w$方向的总的光线辐射度。如果以三重积分计算$n$重散射，那么在$p$点和$p’$点都会重复地计算到$L$。事实上，对于$p$点到$q$点之间所有的点，都会重复地计算$L$。显然，为了性能考虑，我们必须避免这一重复的部分。<strong>以空间换时间</strong>是个不错的方法。<br><img src="https://img-blog.csdnimg.cn/20190106190545970.png" alt="在这里插入图片描述"></p>
<p>最终，对于计算$n$重散射我们分<strong>两步</strong>走：</p>
<p>第一步：对于$p$点沿视线$w$上的每一个点$q$，我们计算$q$点接收的经过$n-1$重散射的辐射度，这需要两重积分；</p>
<p>第二步：在$p$点沿视线$w$的路径上，计算第$n$重散射，我们查找第一步计算得到的纹理，这只需单重积分。</p>
<p><strong>①</strong> <strong>第一步</strong>：计算$q$点接收的经过$n-1$重散射的光线（第$n$重散射射向$-w$）。</p>
<p>如下所示，对于所有可能的方向$w_i$，我们需要计算从$w_i$方向接收的入射辐射度$L_i$。$L_i$由两部分组成：一部分是$n-1$重散射的辐射度（可以直接查找$n-1$重散射的纹理得到）；另一部分是当射线$w_i$与地面相交时，我们需要考虑地面的反射辐射度。</p>
<p>$n-1$重散射辐射度由前面的迭代计算得到，不再讨论。我们需要重点讨论的是地面的反射辐射度。设射线($q$,$w_i$)与地面的交点为$r$，那么从地面接收的反射辐射度应该是以下几项的乘积：</p>
<ul>
<li><p>点$q$和点$r$之间的光线衰减因子；</p>
</li>
<li><p>地面的平均反照率；</p>
</li>
<li><p>地面的Lambertian BRDF函数的$1/\pi$；</p>
</li>
<li><p>地面接收的经过$n-2$次散射辐照度，这是个半球方向的积分，我们将在后面讨论，现在假设我们已经可以计算得到。<br><img src="https://img-blog.csdnimg.cn/20190106190623752.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190106190711202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjE1OTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<p><strong>②</strong> <strong>第二步</strong>：第二步就是利用第一步的计算结果进行单次积分。在$p$点沿视线$w$的路径上，计算第$n$重散射，我们查找第一步计算得到的纹理。对于$p$到边界交点的每一个点$q$，设$q$计算得到的$n-1$重散射密度为$L$，则由$q$到$p$的辐射度应该再乘上一个$q$到$p$之间的光线衰减因子。</p>
<p><strong>同样的，我们采用梯度法和光线步进计算$p$到边界路径上的黎曼和。</strong><br><img src="https://img-blog.csdnimg.cn/20190106190848547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjE1OTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>③</strong> <strong>坐标映射</strong>：与单重散射一样。</p>
<p><strong>5、地面辐照度</strong></p>
<p>地面接收的辐照度是直接辐照度、单重散射或多重散射之后接收的辐照度总和，我们分为直接辐照度和间接辐照度。计算地面接收的辐照度有以下两个目的：</p>
<ul>
<li><p>计算$n$重散射的时候，我们需要考虑从地面反射的辐射度；</p>
</li>
<li><p>渲染地面的需要。</p>
</li>
</ul>
<p><strong>①</strong> <strong>直接辐照度</strong>：太阳光线直达地面，中间不发生的散射（但是会向外散射导致光强减弱），所以我们将太阳的辐射度乘上地面到大气顶层的光线衰减因子即可。同时，值得注意的是太阳是一个圆盘，我们还需要考虑太阳可见圆盘的比例，这在前面已经讨论过了。比较简单，直接贴代码了。<br> <img src="https://img-blog.csdnimg.cn/20190106190952204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjE1OTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>②</strong> <strong>间接辐照度</strong>：间接辐照度考虑单重及多重散射，如下所示，我们需要对以地面法线为轴向的半球方向进行积分。<br><img src="https://img-blog.csdnimg.cn/20190106191025671.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190106191103743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjE1OTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>5、预计算</strong></p>
<p>有了以上的铺垫，我们现在可以将光线衰减因子、单重散射、多重散射以及地面辐照度预先计算到纹理中，然后渲染的时候直接根据相应的参数去查找纹理（需要纹理坐标的映射）从而获取相应的值，如此在渲染时省去了大量的计算，这带来了非常大的性能提升。<br><img src="https://img-blog.csdnimg.cn/20190106191200877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjE1OTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>演示的是一个非常简单的场景，地球以及地球表面上的球体。由于仅仅只有两个球体，那么绘制轮廓部分用光线追踪的办法是非常简单的，而且在片元着色器也很容易实现，只需求解几个二元一次方程即可。而光照部分则是查找前面已经计算好的散射纹理。</p>
<p><strong>①</strong> <strong>实验平台</strong>:</p>
<ul>
<li><p>操作系统: Windows8.1</p>
</li>
<li><p>IDE: Qt Creator</p>
</li>
<li><p>语言: C++</p>
</li>
<li><p>API: OpenGL3.3+, Qt 5.7</p>
</li>
</ul>
<p><strong>②</strong> <strong>可调参数</strong>:</p>
<ul>
<li><p>太阳光谱:选择常量值还是真实值（通过真实的太阳光谱线性插值）</p>
</li>
<li><p>臭氧层:是否开启臭氧层（臭氧层也会吸收一部分光线）</p>
</li>
<li><p>散射重数:最低为$1$（即只考虑单重散射）</p>
</li>
<li><p>体积光:是否开启丁达尔效应</p>
</li>
<li><p>Rayleigh散射:是否开启rayleigh散射</p>
</li>
<li><p>Mie散射:是否开启Mie散射</p>
</li>
<li><p>Mie散射对称系数:控制Mie散射的方向性，为正则向后散射，为负则向前散射<br><img src="https://img-blog.csdnimg.cn/20190106191448876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjE1OTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<p><strong>③</strong> <strong>实验结果：</strong></p>
<p>1）、首先，<strong>把Rayleigh散射和Mie散射都关闭了</strong>，也就是说相当于没有大气层的存在，<strong>和月球上的情况相似</strong>，所以天空不再是蓝色而是黑色（直接看到外太空了），太阳周围也不会出现光晕。而且由于没有散射，那么阴影部分（非太阳直射的地方）将完全漆黑。<br><img src="https://img-blog.csdnimg.cn/20190106191534897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjE1OTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>2）、现在把Rayleigh散射和Mie散射都开启。<br><img src="https://img-blog.csdnimg.cn/20190106191603123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjE1OTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>3）、仅开启Rayleig散射，这时由于<strong>没有Mie散射</strong>，也就是我们剔除了气溶胶的作用，<strong>天空的朦胧感降为$0$</strong>，天空看着很清澈，这与我们的生活经验一致。<br><img src="https://img-blog.csdnimg.cn/20190106191641107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjE1OTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>4）、而如果仅开启Mie散射，那么天空不会呈现蓝色，而是呈现如下情况。可以看出，Mie散射呈现的是一种<strong>丁达尔效应的朦胧感</strong>。<br><img src="https://img-blog.csdnimg.cn/2019010619170986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjE1OTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>5）、单重散射、多重散射的对比。实现的最大难度在于多重散射，需要编写大量的代码，而且占用更多的空间，但是提升的效果其实很小。如下图。<br><img src="https://img-blog.csdnimg.cn/20190106191744656.png" alt="在这里插入图片描述"><br>对比上面的几张图，可以看到其实单重散射的效果已经非常不错了。而且散射重数多了其实区别也不大。</p>
<p>6）、体积光效果：体积光效果是大气光效渲染比较复杂的一个方面，但是实现的话看起来是很令人震撼的。遗憾的是，论文作者提出的体积光实现是基于阴影体的，简单场景没什么问题，但是比较复杂的就不太现实了。<br><img src="https://img-blog.csdnimg.cn/2019010619182254.png" alt="在这里插入图片描述"></p>
<p>7）、Mie散射对称系数:控制Mie散射的方向性，为正则向后散射，为负则向前散射。为正时越大向后散射得越多。<br><img src="https://img-blog.csdnimg.cn/20190106191855216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjE1OTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>8）、调整曝光率可以出现一些有趣的光效。<br><img src="https://img-blog.csdnimg.cn/20190106191919356.png" alt="在这里插入图片描述"></p>
<p>9）、一些从外太空观察的效果。<br><img src="https://img-blog.csdnimg.cn/20190106191941232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjE1OTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>此外，值得注意的是，渲染的速度非常快，FPS稳定在$60$。基于预先计算的查找表的优化方法把渲染时大量的计算挪到程序启动的初始阶段，而且开始阶段耗费时间也不多，最多两三秒。对于散射重数低于$10$的，几乎是秒开。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1、《Precomputed Atmospheric Scattering》</p>
<p>2、《SIGGRAPH 2009 - Lighting Research at Bungie》</p>
<p>3、《基于GPU的实时大气散射渲染优化算法研究与实现_方辰》</p>
<p>4、《PreethamSig2003CourseNotes》</p>
<p>5、《数字地球大气散射的GPU实现》</p>
<p>6、《基于GPU的行星大气散射效果实时渲染技术研究_刘维敏》</p>
<p>7、《基于GPU的地球大气散射现象可视化仿真_杜芳》</p>
<p>8、《多重散射的天空光照效果建模与实时绘制_艾祖亮》</p>

      
    </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class="post-wrapper">
            <article class="post reveal no-title">
  


  <section class="meta">
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/04/25/fluidSimulation/">
      2019-04-25
    </a>
  </h2>


      
      <div class="new-meta-box">
        
          
        
          
            
  <div class="new-meta-item author">
    <a href="http://yoursite.com" rel="nofollow">
      
        <img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1//globalImage/title.png">
      
      <p>WC Yang</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class="notlink">
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-04-25</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <ul>
<li>前言</li>
<li>矢量微积分</li>
<li>Naiver-Stokes偏微分方程组</li>
<li>N-S方程的分步求解</li>
<li>对流算法</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 本文主要参考文献《FLUID SIMULATION SIGGRAPH 2007 Course Notes》，结合我的理解单纯地讲述一下流体渲染的一些基础知识，本人水平有限，如有错误，欢迎指出。本文只是单纯针对流体模拟领域，可能一些地方不太严谨，但是对于虚拟模拟来说是可行的。即便如此，本文涉及到大量的数学方法。</p>
<h2 id="一、矢量微积分"><a href="#一、矢量微积分" class="headerlink" title="一、矢量微积分"></a>一、矢量微积分</h2><p>高等数学中太多数讨论的是一维的微积分，而矢量微积分则是一维微积分的高维扩展。矢量微积分的三个基础算子：<strong>梯度</strong>（符号为），<strong>散度</strong>（符号为)，<strong>旋度</strong>（符号为），在此基础上流体力学中经常用到的还有拉普拉斯算子。</p>
<h3 id="1、梯度（Gradient）"><a href="#1、梯度（Gradient）" class="headerlink" title="1、梯度（Gradient）"></a>1、梯度（Gradient）</h3><p>梯度实际上就是矢量的空间偏导数，且结果依然是一个矢量，维的梯度如下：</p>
<p>依此类推，维的梯度有如下形式：</p>
<p>有时也会采用如下形式来表示梯度：</p>
<p>梯度通常用来近似计算函数值（实际上就是一维形式的推广)：</p>
<p>同样的，多个函数的梯度就构成了一个矩阵：</p>
<h3 id="2、散度（Divergence）"><a href="#2、散度（Divergence）" class="headerlink" title="2、散度（Divergence）"></a>2、散度（Divergence）</h3><p>散度算子仅仅应用于向量场，它衡量在某一点出相应的矢量聚集或者发散程度，测量方向为<strong>径向</strong>，结果为标量。维、维形式的散度算子如下所示：</p>
<p>输入是矢量，而输出为标量。类比梯度，散度符号可以理解为梯度与矢量的点乘：</p>
<p>若矢量场散度为，则称该矢量场<strong>无散度</strong>。</p>
<h3 id="3、旋度（Curl）"><a href="#3、旋度（Curl）" class="headerlink" title="3、旋度（Curl）"></a>3、旋度（Curl）</h3><p>旋度衡量围绕某一点的旋转速度，测量方向为<strong>切向</strong>，三维形式的旋度是一个向量：</p>
<p>倒推到维，我们取上式中的，即矢量场为，维向量场的旋度是一个标量：</p>
<p>同样地，旋度符号我们可以理解为梯度与矢量场的叉乘：</p>
<p>若矢量场旋度为，则称该矢量场<strong>无旋度</strong>。</p>
<h3 id="4、拉普拉斯算子（Laplacian）"><a href="#4、拉普拉斯算子（Laplacian）" class="headerlink" title="4、拉普拉斯算子（Laplacian）"></a>4、拉普拉斯算子（Laplacian）</h3><p>拉普拉斯算子定义为梯度的散度，符号表示为，显然是散度，而后面的则为梯度，故拉普拉斯算子即梯度的散度，是一个二阶微分算子。维、维形式分别如下：</p>
<p>简言之，拉普拉斯算子定义如下：</p>
<p>偏微分方程被称为拉普拉斯方程；而如果右边为某个非常数，即，我们称之为泊松方程。更一般地，如果梯度再乘上一个标量（如)，即，我们依旧称之为泊松问题。</p>
<h2 id="二、偏微分方程组"><a href="#二、偏微分方程组" class="headerlink" title="二、偏微分方程组"></a>二、偏微分方程组</h2><p>流体模拟器的构建主要围绕著名的不可压缩方程展开，它是一个流体力学领域的偏微分方程，方程形式如下：</p>
<p>这个方程组看起非常地复杂，接下来我们就把它剖析成一个个比较简单的部分来理解。</p>
<h3 id="1、符号标记"><a href="#1、符号标记" class="headerlink" title="1、符号标记"></a>1、符号标记</h3><p>我们有必要定义一些物理量的符号用以标记：</p>
<p>符号在流体力学中通常表示为流体的速度矢量，记维的速度矢量；</p>
<p>希腊字符是流体的密度，对于水，该值大约为，而空气则大约为；</p>
<p>字符代表压力，流体对任何物体施加的单位面积力；</p>
<p>字符则是我们熟悉的重力加速度，通常取。我们约定轴向上，而轴和轴在水平面上。另外补充一点，我们把其他的一些类似的力都累加到上，也就是我们统一用表示所有类似力之和，这类力我们称之为<strong>体积力</strong>（称之为体积力是因为它们的力是作用到整个流体而不只是流体的表面）；</p>
<p>希腊字符是流体的运动粘度，它衡量流体的黏滞性。糖蜜之类的流体有非常高的粘度，而像酒精之类的流体有很低的粘度；</p>
<p>其它一些矢量微积分的符号算子前面已经提到过，不再赘述。</p>
<h3 id="2、动量方程"><a href="#2、动量方程" class="headerlink" title="2、动量方程"></a>2、动量方程</h3><p>偏微分方程我们称之为<strong>动量方程</strong>，它本质上就是我们熟悉的牛顿定律的形式，描述了施加在流体上的力是如何影响流体的运动。</p>
<p>假设我们用粒子系统来模拟流体，每个粒子代表流体的一小滴，每个粒子有各自的质量、体积和速度。为了让整个粒子系统运作起来，我们必须弄清楚每个粒子所承受的力的作用。牛顿第二定律告诉我们：，而根据加速度定义，我们有：</p>
<p>符号是指<strong>物质导数</strong>，所谓物质导数，就是对流体质点求导数，而且是针对流体质点（在这里就是流体粒子）而不是空间的固定点。因而牛顿第二定律就变成：</p>
<p>那么流体粒子承受的力有哪些呢？一个最简单的力就是重力：。而其他的流体质点（或其他流体粒子）也会对当前的流体粒子产生作用力。流体内部的相互作用力之一便是压力，较大压力的区域会向较低压力区域产生作用力。值得注意的是，我们只关注施加在粒子上的压力的净合力。例如，若施加在粒子上压力在每个方向上都相等，那么它的压力的合力便为0。我们用压力的负梯度（取负是因为方向是由压力大的区域指向压力小的区域）来衡量在当前流体粒子处压力的不平衡性，即取。那么流体粒子所承受的压力就是对在整个流体粒子的体积上进行积分，为了简化，我们简单地将与相乘，故粒子压力部分为。</p>
<p>其他的流体相互作用力则是由流体的黏性产生的，我们直观地把这种力理解为尽可能使得粒子以周围区域的平均速度移动的力，也就是使得粒子的速度与周围区域粒子速度的差距最小化。拉普拉斯算子是衡量一个量与之周围区域该量平均值之差的算符，因而是当前粒子速度矢量与周围区域平均速度矢量之差。为了计算粘滞力，我们同样对在整个粒子体积上进行积分，与前面类似，我们简单取。除此之外，我们还引进一个称为动力粘度系数的物理量，符号为。因而粘滞力为。</p>
<p>把重力、压力和粘滞力综合一起，我们可得：</p>
<p>当粒子系统中的粒子数量趋于无穷大，而每个粒子大小趋于时，会产生一个问题：此时每个粒子的质量和体积变为，此时上式变得没有意义。为此，我们把式调整一下，两边同除以体积，又因，故有：</p>
<p>两边同除以，移项调整：</p>
<p>为了进一步简化，定义运动粘度为，式变为：</p>
<p>我们已经快把动量方程推导出来，现在我们要把物质导数弄清楚，为此，我们需要了解两种描述方法：<strong>拉格朗日描述</strong>和<strong>欧拉描述</strong>。</p>
<h3 id="3、拉格朗日描述与欧拉描述"><a href="#3、拉格朗日描述与欧拉描述" class="headerlink" title="3、拉格朗日描述与欧拉描述"></a>3、拉格朗日描述与欧拉描述</h3><p>当我们尝试研究流体或可变形固体的运动的时候，通常有两种方法来描述：<strong>拉格朗日描述</strong>（ Lagrangian viewpoint）、<strong>欧拉描述</strong>（Eulerian viewpoint）。</p>
<p>拉格朗日描述方法是我们比较熟悉的方法，这种描述方法把物体看成是由类似于粒子系统的形式组成，固体或流体的每个点看作一个独立的粒子，粒子有各自相应的位置和速度。我们可以把粒子理解为组成物体的分子。对于我们通常采用拉格朗日描述法进行建模模拟，即用一系列离散的粒子集来构建，粒子之间通过网格相联系。</p>
<p>欧拉描述方法则采用了完全不同的角度，它常被用于流体力学中。与拉格朗日描述追踪每个物体粒子的方法不同，欧拉描述关注点是空间中的一个固定点，并考察在这个固定点上流体性质（如密度、速度、温度等）是如何随着时间变化的。流体流动经过这个固定点可能会导致这个固定点的物理性质发生一些变化（如一个温度较高的流体粒子流经这个固定点，后面紧跟着一个温度较低的流体粒子流过固定点，那么这个固定点的温度会降低，但是并没有任何一个流体粒子的温度发生了变化）。</p>
<p>用天气测量举个简单的例子：拉格朗日描述方法就是你乘坐在一个随风而飘的热气球上，测量周围空气的压力、密度和浑浊度等天气指标；而欧拉描述方法就是你固定在地面上，测量流过的空气的天气指标。</p>
<p>欧拉描述法似乎看起来带来了一些不必要的复杂度，但是目前大多数的流体模拟器都是基于欧拉描述法，这是因为欧拉描述法相比于拉格朗日描述法有一些不可比拟的优点：欧拉描述法能够更加方便地计算一些物理量的空间导数（例如压力梯度和粘度）；而如果用粒子方法的话（即拉格朗日描述法），那么计算物理量相对于空间位置的变化是比较难的。</p>
<p>把拉格朗日描述法和欧拉描述法联系起来的关键点就是物质导数。首先从拉格朗日描述法出发，假设有一群粒子，每个粒子都有各自的位置和速度。记为通用的物理量（如密度、速度和温度等），每个粒子有其对应的值。方程描述在时间点而位置为的粒子对应的物理量值。则一个粒子的物理量随时间的变化率是多少？这是一个拉格朗日描述角度下的问题，我们取对时间的导数（注意用到了求导链式法则，以及和）：</p>
<p>这就是物质导数。把式代入式我们就得到了流体动量方程。物质导数针对的是流体质点（在这里就是流体粒子）而不是空间的固定点。式写完整一点就是：</p>
<p>对于给定的速度场， 流体的物理性质如何在这个速度场下变化的计算我们称之为<strong>对流</strong>（advection）。一个最简单的对流方程，就是其物理量的物质导数为，如下所示：</p>
<p>公式的意义即在拉格朗日视角观察下，每个流体粒子的物理量保持不变。</p>
<h3 id="4、不可压缩性"><a href="#4、不可压缩性" class="headerlink" title="4、不可压缩性"></a>4、不可压缩性</h3><p>关于流体的压缩性在此不做过多的物理细节描述，只需知道一点：通常情况下流体的体积变化非常小（除开一些极端的情况，而且这些极端情况我们日常生活中较少出现）。可压缩流体的模拟涉及到非常复杂的情况，往往需要昂贵的计算资源开销，为此在计算机流体模拟中我们通常把所有的流体当作是不可压缩的，即它们的体积不会发生变化。</p>
<p>任取流体的一部分，设其体积为而其边界闭合曲面为，我们可以通过围绕边界曲面对流体速度在曲面法线方向上的分量进行积分来衡量这块部分流体的体积变化速率：</p>
<p>对于不可压缩的流体，其体积保持为某个常量，故其体积变化速率为：</p>
<p>由高斯散度定理，我们可以把式转换为体积分：</p>
<p>式应该对任意的成立，意即无论取何值，积分值均为。这种情况下只有令积分函数值取方可成立，即对积分无论取何值结果均为。所以有：</p>
<p>这就是方程中的不可压缩条件。满足不可压缩条件的速度场被称为是<strong>无散度</strong>的，即在该速度场下流体体积既不膨胀也不坍缩，而是保持在一个常量。模拟不可压缩流体的关键部分就是使得流体的速度场保持无散度的状态，这也是流体内部压力的来源。</p>
<p>为了把压力与速度场的散度联系起来，我们在动量方程两边同时取散度：</p>
<p>对于上式第一项，我们转变一下求导次序：</p>
<p>如果满足流体不可压缩条件，那么式取值（因为无散度），然后我们调整一下式可得关于压力的方程：</p>
<h3 id="5、丢弃粘度项"><a href="#5、丢弃粘度项" class="headerlink" title="5、丢弃粘度项"></a>5、丢弃粘度项</h3><p>在某些流体如蜂蜜、小水珠等的模拟中，粘滞力起着非常重要的作用。但是在大多数流体动画模拟中，粘滞力的影响微乎其微，为此秉持着方程组越简单越好的原则，我们常常丢弃粘度项。当然这也不可避免地带来一些误差，事实上，在计算流体力学中尽可能地减少丢弃粘度项带来的误差是一个非常大的挑战。下面的叙述都是基于丢弃粘度项的前提。</p>
<p>丢弃了粘度项的方程被称为<strong>欧拉方程</strong>，而这种理想的流体则是<strong>无粘度</strong>的。丢弃了粘度项的欧拉方程如下：</p>
<p><strong>大多数的流体模拟的计算方程都是欧拉方程。</strong></p>
<h3 id="6、边界条件"><a href="#6、边界条件" class="headerlink" title="6、边界条件"></a>6、边界条件</h3><p>目前为止我们讨论的都是流体内部的情况，然而边界部分也是流体模拟非常关键的部分。在流体模拟中我们仅仅关注两种边界条件：<strong>固体墙</strong>（solid walls）、<strong>自由面</strong>（free surfaces）。</p>
<p><strong>固体墙</strong>顾名思义就是流体与固体接触的边界，用速度来描述很简单：流体既不会流进固体内部也不会从固体内部流出，因此流体在固体墙法线方向上的分量为：</p>
<p>当然，上述是固体自身不移动的情况下。通常来说，流体速度在法线方向上的分量与固体的移动速度在法线方向上的分量应该保持一致：</p>
<p>上述的两个公式都是仅对流体速度在法线方向上的分量做了限制，对于无粘度的流体，切线方向上的流体速度与固体的移动速度无必然的联系。</p>
<p><strong>自由面</strong>是另外一个非常重要的边界条件，它通常就是与另外一种流体相接壤的边界部分。例如在模拟水花四溅时，水流表面不与固体接触的都是自由面（如与空气这种流体接触）。因空气密度远小于水导致空气对水体的仿真影响非常小，为了简化模拟，我们将空气所占的空间设为某个固定大气压的区域，设为是最方便的方案，此时自由面就是压强的水体表面。</p>
<p>在小规模的流体仿真中，自由面的表面张力占据着非常重要的地位。在微观分子层面下，表面张力的存在是因为不同的分子相互吸引产生的力。从几何的角度来解释就是，表面张力就是促使流体的表面积尽可能小的一种力。物理学上，两种不同的流体之间实际上存在着与表面平均曲率成正比的压力骤变：</p>
<p>公式中的记为压力之差。是表面张力系数，可以根据模拟的流体类型查找对应的张力系数（例如空气与水在室温下张力系数为）。而就是平均曲率，单位为。又因为我们常常设空气的压力为，因此水与空气交界的自由面的压力为：</p>
<h2 id="三、N-S方程的分步求解"><a href="#三、N-S方程的分步求解" class="headerlink" title="三、N-S方程的分步求解"></a>三、N-S方程的分步求解</h2><p>有了对以上对方程的理论支撑，接下来我们就要如何用计算机来对该组偏微分方程进行离散化求解。为了程序的松耦合性以及使计算尽可能地高效、简单，在流体模型领域，我们将流体方程分成几个独立的步骤，然后按顺序先后推进。对于不可压缩的无粘度流体方程（即前面的欧拉方程和，我们将其离散化成对流项（advection）如公式、体积力项（body force）如公式、压力/不可压缩项如公式：</p>
<p>需要注意的是，在对流项公式中我们用了一个通用量的符号是因为我们不仅仅要对流体的速度进行对流，还需要对其他物理量进行对流。我们记对流项公式的对流计算算法为，即对于给定的时间步长和速度场，对物理量q进行对流。</p>
<p>对于体积力项，我们采用简单的前向欧拉法即可：。</p>
<p>对于压力/不可压缩项，我们用一个称为的算法，通过计算出正确的压力以确保速度场的无散度性质。欧拉方案不会着重研究具体粒子间的作用力，因而不会正向去求解，它是利用流体不可压缩的特性，将速度场投影到散度为的空间上，间接地解算了压力项。这种思想相当于，已知一个中间量，对这个中间量的唯一一个操作（如正向求解压力）不可行，但是直到最终量符号的一个性质（散度为），于是只要将投影到符合散度为的特性平面上，即可间接地还原正向求解压力的操作，得到最终的速度场。</p>
<p>对流项的输入速度场要确保为无散度的状态，投影项确保了流体体积保持不变，因而投影项输出的速度场必然是无散度的。所以我们只要确保投影项输出的速度场作为对流项的输入即可，这时我们的分步求解流体方程的优势就体现出来了，其伪代码如下所示。</p>
<hr>
<p>算法1 Fluid Simulation(, ): </p>
<hr>
<p>1:  初始化速度场,使得无散度 </p>
<p>2:  对于每个时间步</p>
<p>3: 决定一个合理的时间步长 </p>
<p>4: 对流项计算 </p>
<p>5: 体积力项计算</p>
<p>6:  无散度投影 </p>
<hr>
<h3 id="1、时间步长"><a href="#1、时间步长" class="headerlink" title="1、时间步长"></a>1、时间步长</h3><p>在流体模拟算法中，确定适当的时间步长是算法的第一步。因为计算流体模拟的最后结果是呈现在屏幕上的，所以的选取与屏幕的刷新率有重要的关系。若选取的有，那么必须做一个截断使。此外，流体模拟的三个步骤即对流项、体积力项、无散度投影项对时间步长的要求不尽相同，要选择一个满足所有要求的最小时间步长能确保计算的收敛性。此外，一方面为了流体模拟的真实性，我们可能需要选取一个足够小的时间步长来复现流体的高质量细节。另一方面，有时高性能的需求又使得我们不能选取太小的时间步长去渲染一帧。假设一帧至少要进行三个时间步的模拟，那么应该至少设成帧间隔时间的三分之一。</p>
<h3 id="2、网格结构"><a href="#2、网格结构" class="headerlink" title="2、网格结构"></a>2、网格结构</h3><p>欧拉法的整个流程都是基于网格的，所以合理的网格结构是算法高效的关键点。和提出了一种经典的（marker and cell）网格结构，许多不可压缩流体模拟的算法都在这个网格结构上呈现出了良好的效率。网格是一种交叉排列的网格，不同类型的物理量被存储于网格的不同位置。以二维的网格为例，如图3-1左图所示，流体粒子的压力数据存储于网格的中心点，而速度则沿着笛卡尔坐标被分成了两部分。水平方向的成分被存储在了网格单元竖直边的中心处，例如网格单元和之间的水平速度记为。垂直方向的成分则被存储在了网格单元水平面的中心上。这样的存储方案十分有利于估算流体流进/流出某个网格单元的量。</p>
<p><img src="https://img-blog.csdnimg.cn/20190423135658800.png" alt="img"> <img src="https://img-blog.csdnimg.cn/20190423135812820.png" alt="img">图3-1 MAC网格,左图二维,右图三维</p>
<p>扩展到三维的情况，网格同样是交错排列的结构网格，如图3-1右图所示。压力数值存储在立方体网格单元的中心，三个速度分量分别被记录在立方体网格单元的三个表面的中心点上。在数值计算时，这样的分配方式使得我们可以准确地采用中心差分法计算压力梯度和速度的散度，同时克服了中心差分法的一个普遍的缺点。一维的情况为例，在网格顶点位置上估算量场的导数，为了无偏（所谓无偏，就是不偏向左边或者右边）估计网格顶点处的，一种比较自然的方式就是采用一阶中心差分法：</p>
<p>公式是无偏的，且精确度为。而前向欧拉差分法偏向右边且精确度只有：</p>
<p>然而，公式存在着一个非常严重的问题：网格点的估算导数完全忽略了的值。数学上，只有常数函数的一阶导数为零。但是公式遇到了锯齿函数如时，它错误地将该类函数的导数估算为，这种问题被称为零空间问题（null-space problem）。</p>
<p>交叉错排的网格完美地克服了中心差分法的零空间问题，同时也保持了它的无偏二阶精度。在网格上运用中心差分法，网格点处的估算导数公式如下所示：</p>
<p>网格确实给流体的压力计算和不可压缩性的处理带来了很大的便利，但与此同时也带来了一些其他方面的麻烦。如果我们要估算某个地方的速度向量，即便采样点恰好在网格点上我们也要做一些插值才能获取相应的速度向量。在网格点处，我们通常采用平均法，以二维为例：</p>
<p>最后，在实现中下标索引一般没有浮点数之说，前面直接采用的记法是为了便于叙述。一般约定如下：</p>
<p>因而对于分辨率的网格，压力数值存储在的数组中，速度的成分存储在数组中，速度的成分存储在数组中，速度的成分存储在数组中。</p>
<h2 id="四、对流算法"><a href="#四、对流算法" class="headerlink" title="四、对流算法"></a>四、对流算法</h2><p>求解如下所示的对流方程是流体模拟的关键一步：</p>
<p>我们把这个对流数值计算的算法记为：</p>
<p>公式中的各个符号含义：</p>
<p>：在网格上的离散化的速度场；</p>
<p>：时间步长；</p>
<p>：当前的物理量场（如流体密度、速度、燃烧物浓度等）；</p>
<p>：经过对流后得到的新的量场。</p>
<p>在这里要特别注意，输入对流算法的速度场必须是无散度的，否则模拟结果会出现一些奇怪的失真现象。</p>
<h3 id="1、半拉格朗日对流算法（Semi-Lagrangian-Advection）"><a href="#1、半拉格朗日对流算法（Semi-Lagrangian-Advection）" class="headerlink" title="1、半拉格朗日对流算法（Semi-Lagrangian Advection）"></a>1、半拉格朗日对流算法（Semi-Lagrangian Advection）</h3><p>一维情况下，对流方程写成偏微分的形式如下：</p>
<p>分别采用前向欧拉差分法计算对时间的偏导和中心差分法计算对空间的偏导，我们有：</p>
<p>转成以为计算目标的显式公式，得：</p>
<p>公式看起来没什么问题，但是却存在非常严重的漏洞。首先，前向欧拉法被证明是无条件不稳定的空间离散方法：无论取多么小Δ𝑡，随着时间步的推进，累积误差终将发散。即使使用更稳定的时间积分方法来取代前向欧拉方法，解决了时间上的PDE（Partial Differential Equation，偏微分方程）计算，空间上的PDE计算还是会带来重大的麻烦。标准中心差分方法不可避免地会出现的零空间问题，具有高频震荡性质的速度场对空间的导数被错误地计算为或几乎为，低离速度分量被分离出来，从而导致模拟效果中出现许多奇怪的高频摆动和震荡。</p>
<p>针对这些问题，研究者们提出了一个解然不同的、更加简单和更具物理直观意义的半拉格朗日法。之所以叫半拉格朗日法，是因为这种方法是以拉格朗日视角去解决欧拉视角的对流方程（“半”字的由来）。假设我们的目标是求解网格点的在第个时间步时关于物理量的新值，记为。在拉格朗日的视角下，我们可以寻找在第时间步之前，是空间中的哪一个点上的流体粒子在速度场的作用下“流向”了，我们记这个粒子在第个时间步时的网格位置为，则第个时间步时的即为第个时间步时的。如下图4-1为半拉格朗日对流法的示意图。</p>
<p><img src="https://img-blog.csdnimg.cn/20190423135910467.png" alt="img">图4-1 半拉格朗日对流法</p>
<p>半拉格朗日对流法的第一步就是要找出，为此我们根据做反向的追踪。粒子位置对时间的导数就是速度场：</p>
<p>经过一个时间步长之后，粒子由移动到。为了得到，最简单的方法就是采用前向欧拉法进行倒推：</p>
<p>然而前向欧拉法只有一阶的精度，若在不改变的情况下提高精度，我们可以采用高阶的龙格库塔法（Runge-Kutta method）。采用二阶的龙格库塔法如下所示：</p>
<p>倒推得到之前的网格位置一般不会恰好在网格顶点上，为此我们需要做些插值。三维模拟通常采用三线性插值，而二维的则采用双线性插值。</p>
<h3 id="2、边界情况"><a href="#2、边界情况" class="headerlink" title="2、边界情况"></a>2、边界情况</h3><p>若我们倒推得到的仍然在流体的内部，那么做插值是完全没问题的。但若在流体的边界之外呢？这种情况的出现的原因通常有两个：一个是确确实实在流体的外部且即将流入流体内部，另一个是由前向欧拉法或龙格库塔法的数值计算方法带来的误差导致。</p>
<p>在一种情况下，我们应该知道当流体流入时其携带的物理量，此时我们将这个外部流入的物理量作为返回值即可。例如，第个时间步时的外部流体以速度和温度在第个时间步时注入流体内部的位置，那么的值就为。</p>
<p>在第二种由误差导致的情况下，一个适当的策略就是根据边界上的最近点外推出所求得物理量。在模拟某些流体时，外推变得很简单。例如，在模拟烟雾时我们简单地假设烟雾流体外部即空气的速度风场为某个常数（可能为），这样边界上的速度场都取。但还有一些必须根据流体内部的已知量外推出未知量，这时情况就变得比较复杂了。具体如何外推将在后面介绍，目前我们只需要知道大概的步骤：首先寻找边界上的最近点，然后在最近点的领域内插值获取相应的物理量场。</p>
<h3 id="3、时间步长大小"><a href="#3、时间步长大小" class="headerlink" title="3、时间步长大小"></a>3、时间步长大小</h3><p>对任何一种数值计算方法的主要的考虑点就是它是否稳定。幸运的是，<strong>半拉格朗日对流法已经被证明是一种无条件稳定的算法</strong>：无论取多大，它永远不会出现数值爆炸的现象。因为每一个新值的确定，都是通过对旧值得插值，无论是线性插值、双线性插值还是三线性插值，的大小都是处于插值点之间，不会得到比原来插值点更大或者更小的值，因而是有上下界的。这使得我们可以尽情地根据所需的模拟质量和模拟效率去调整时间步长。</p>
<p>但是在实践中，时间步长的大小也不能选得太过极端，否则会产生一些奇观的现象。Foster和Fekiw提出了一个对的限制：流体粒子在内的倒推轨迹最多经过某个常数个网格单元为宜，例如5个：</p>
<p>公式中，是速度场的最大值，我们可以简单地取 存储在网格中的最大速度值。一个更鲁棒的方法考虑了体积力（如重力、浮力等）对最大速度的影响：</p>
<p>将不等式的最大值带入公式，我们有：</p>
<p>取一个简单的速度上界（简化了公式），：</p>
<p>这样确保了始终为正，且避免公式的除错误。</p>
<p>关于时间步长的讨论离不开（以Courant、Friedrichs、Lewy三人的名字命名）条件。条件是一个简单而直观的判断计算是否收敛的必要条件。它的直观物理解释就是时间推进求解的速度必须大于物理扰动传播的速度，只有这样才能将物理上所有的扰动俘获到。满足条件意味着当和趋于取极限时，数值计算所求的解就会收敛到原微分方程的解。</p>
<p>对于半拉格朗日对流法，其满足条件当且仅当在极限情况下，追踪得到的粒子轨迹足够逼近真实的轨迹。足够逼近的意思是经过正确的网格插值能够得到正确的依赖域（即差分格式的依赖域包含了原微分方程的依赖域），追踪的轨迹就会收敛到正确真实的轨迹。</p>
<p>因而，对于采用标准的显式有限差分法的对流方程求解，为了保证收敛，我们要求的新值是由以当前网格点为中心、以（是一个小的整数常量）为半径的邻域范围内插值得到：</p>
<p>公式中的被称为数，因而不等式可以看成是公式取数为得到。</p>
<h3 id="4、数值耗散"><a href="#4、数值耗散" class="headerlink" title="4、数值耗散"></a>4、数值耗散</h3><p>对流算法在对流获取新的物理量场时会进行一些插值操作，插值不可避免地会平滑物理量场，这带来了一些数值耗散。一次两次的数值耗散不会由太大的影响，但是在流体模拟中我们会在每个时间步都进行对流运算，反反复复的平滑操作将数值耗散不断扩大，损失大量的流体细节。</p>
<p>以一维的对流项计算为例，流体速度为常量：</p>
<p>假设，即单个时间步长内粒子追踪轨迹长度小于单个网格单元的大小。我们的目标点是，则倒推得到的粒子位置就落在了上的，然后进行线性插值得到：</p>
<p>将公式整理一下，有：</p>
<p>公式实际上正好就是采用时间上的前向欧拉差分法和空间上的单向有限差分法的欧拉方案，把看成是关于的函数，对进行泰勒级数展开：</p>
<p>将公式代入公式，并做一些变量消去，可得：</p>
<p>在二阶截断误差的情况下，结合公式和公式，有：</p>
<p>右边就是对流方程计算时引入的额外类似粘度乘上系数的项。<strong>这也就是说，当我们采用简单的半拉格朗日法去求解无粘度的对流方程时，模拟的结果却看起来我们像时在模拟有粘度的流体。这就是数值耗散!</strong> 当然，当时，这个数值耗散系数也会趋于，所以取时间步无穷小时能够得到正确的模拟结果，但这需要耗费巨额的计算资源开销。我们通常模拟的流体大多数都是无粘度的，所以如何减少这个数值耗散是个至关重要的难题。</p>
<p>一个简单有效的修复数值耗散的方法就是采用更加锐利的插值方法，从而尽可能地减少由插值带来的数值耗散。在一维的情况时，我们采用三次插值（cubic interpolant）如下公式，而不是简单的一次线性插值：</p>
<p>扩展到二维或者三维就是双三次插值（bicubic interpolation）或三三次插值（tricubic interpolation）。以二维情况为例，我们可以先沿着轴做第一遍的三次插值如公式，然后再沿着轴做第二遍插值如公式：</p>
<p>当然也可以先沿着轴，然后再沿着轴做插值操作。</p>

      
    </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class="post-wrapper">
            <article class="post reveal ">
  


  <section class="meta">
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/04/24/hello-world/">
      Hello World
    </a>
  </h2>


      
      <div class="new-meta-box">
        
          
        
          
            
  <div class="new-meta-item author">
    <a href="http://yoursite.com" rel="nofollow">
      
        <img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1//globalImage/title.png">
      
      <p>WC Yang</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class="notlink">
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-04-24</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    
  </section>
</article>

          </div>
        
      
    
  </section>
  
    
    <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
    
    

  


	
</div>
<aside class="l_side">
  
    
    
      
        
          
          
            <section class="widget author">
  <div class="content pure">
    
      <div class="avatar">
        <img class="avatar" src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png">
      </div>
    
    
    
      <div class="social-wrapper">
        
          
            <a href="mailto:1579148717@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/ZeusYang" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://www.zhihu.com/people/4146bb31e7ea6abe568420e83dcc62c0" class="social fa-code-branch flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

          
        
      
        
          
          
            

          
        
      
        
          
          
            <section class="widget grid">
  
<header class="pure">
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class="content pure">
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="/" href="/" id="home">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="/blog/archives/" href="/blog/archives/" rel="nofollow" id="blogarchives">
          
            <i class="fas fa-archive fa-fw" aria-hidden="true"></i>
          
          文章归档
        </a></li>
      
        <li><a class="flat-box" title="/projects/" href="/projects/" id="projects">
          
            <i class="fas fa-code-branch fa-fw" aria-hidden="true"></i>
          
          开源项目
        </a></li>
      
        <li><a class="flat-box" title="/friends/" href="/friends/" rel="nofollow" id="friends">
          
            <i class="fas fa-link fa-fw" aria-hidden="true"></i>
          
          我的友链
        </a></li>
      
        <li><a class="flat-box" title="https://xaoxuu.com/wiki/material-x/" href="https://xaoxuu.com/wiki/material-x/" rel="nofollow" id="https:xaoxuu.comwikimaterial-x">
          
            <i class="fas fa-book fa-fw" aria-hidden="true"></i>
          
          主题文档
        </a></li>
      
        <li><a class="flat-box" title="/about/" href="/about/" rel="nofollow" id="about">
          
            <i class="fas fa-info-circle fa-fw" aria-hidden="true"></i>
          
          关于小站
        </a></li>
      
    </ul>
  </div>
</section>

          
        
      
        
          
          
            

          
        
      
        
          
          
            

          
        
      
        
          
          
            


  <section class="widget music">
    
<header class="pure">
  <div><i class="fas fa-compact-disc fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;最近在听</div>
  
    <a class="rightBtn" rel="external nofollow noopener noreferrer" target="_blank" href="https://music.163.com/#/user/home?id=63035382" title="https://music.163.com/#/user/home?id=63035382">
    <i class="far fa-heart fa-fw"></i></a>
  
</header>

    <div class="content pure">
      
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.css">
  <div class="aplayer" data-theme="#1BCDFC" data-mode="circulation" data-server="netease" data-type="playlist" data-id="2615636388" data-volume="0.7">
  </div>
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script>


    </div>
  </section>


          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="mailto:1579148717@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/ZeusYang" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://www.zhihu.com/people/4146bb31e7ea6abe568420e83dcc62c0" class="social fa-code-branch flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
</footer>

<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("04/24/2019 18:00:00");//在此处修改你的建站时间
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
setInterval("createtime()",250);
</script>

<script>setLoadingBarProgress(80);</script>




	<!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
	

	


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>














  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.4.19/js/app.js"></script>


  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.4.19/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  
  <script>setLoadingBarProgress(100);</script>
  
  <!--数字雨背景-->
  <canvas id="canvas" width="1440" height="900" >
  <script type="text/javascript" src="http://libs.baidu.com/jquery/1.8.3/jquery.js"></script>
  <script type="text/javascript" src="http://libs.baidu.com/jquery/1.8.3/jquery.min.js"></script>
  <script type="text/javascript" src="/js/snow.js"></script>
	
</body>
</html>

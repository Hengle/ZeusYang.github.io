<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>实时渲染Real-time Rendering：基于物理的光照模型</title>
      <link href="/2019/07/14/PhysicallyBasedRendering/"/>
      <url>/2019/07/14/PhysicallyBasedRendering/</url>
      
        <content type="html"><![CDATA[<p>本文采用OpenGL搭建了一个基于物理着色的渲染器，目前大多数的实时应用都是采用了PBR，相对于传统的Phong等基于经验的光照模型，基于物理着色的渲染方法更为真实。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.18/blog/Pbr/header.gif" width="99%"></div></p><a id="more"></a><ul><li>能量守恒</li><li>微平面模型</li><li>基于物理的BRDF</li><li>屏幕空间环境光遮蔽</li><li>实现效果</li><li>参考资料</li></ul><center><font size="6">基于物理的渲染</font></center>&emsp;&emsp;基于物理的渲染（Physically Based Rendering，简称PBR）技术致力于渲染出更贴近于真实物理世界的光影效果，它倾向于探索光影背后的物理规律，然后在此基础上构建一个基于物理规律的光照模型，最后应用到光照计算中。基于物理的渲染除了更为真实，它也给光照计算的赋予了更多的物理意义，从而使得设计师们摆脱基于经验的参数调整，只要设置的物理量正确，则最终光照效果也将会是正确的。即便如此，基于物理的渲染技术依然只是现实物理世界的一个逼近。对于一个基于物理渲染的光照模型，它通常需要满足以下的三个条件：&emsp;&emsp;1、能量守恒&emsp;&emsp;2、基于微平面的表面模型&emsp;&emsp;3、使用基于物理的BRDF&emsp;&emsp;接下来我们就按照上面的顺序一一展开。## 一、能量守恒（Energy Conservation）&emsp;&emsp;基于物理的光照模型必须遵守这样的一个能量守恒原则：对于一个非自发光的物体，出射光线的能量永远不能超过入射光线的能量。当一束光线照射到物体表面，它就被分割成两个部分，分别是折射部分和反射部分。反射部分的光线则是直接撞击到表面然后反弹开来的那部分光线，这部分构成中我们日常生活中常见的镜面高光。折射部分的光线则进入物体内部，光线在内部与物体的粒子发生碰撞，此时光线的一部分能量就转变成热能。一般情况下，并非所有光能都被转化成热能，还有一些光线在内部经过多次散射最终又离开物体表面，这部分的光线构成了物体的漫反射光。这里还要特别区分一下金属材质，与非金属材质和电介质不同，金属材质会直接吸收折射光而不会散开，只表现出镜面反射光。即金属表面不会显示出漫反射的颜色。&emsp;&emsp;根据能量守恒的原则，反射光与折射光是相互排斥的，因此我们只要知道其中一部分占总入射光的百分比，就能立马得到另外一部分的能量占比。通过这样的一个方案，我们就能保证出射光的总能量小于等于入射光的总能量。下面的图1展示Blin-Phong的光照渲染结果，Blin-Phong光照模型并不是一个基于物理的光照模型，它并不满足能量守恒的原则，可以看到，图1场景看起来太亮了，而我仅仅将光照的辐射率设置为vec3(0.6)。<div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.18/blog/Pbr/1.png" width="80%"><center> 图1 Blin-Phong光照模型的渲染结果 </center><h2 id="二、微平面模型（Microfacet-Model）"><a href="#二、微平面模型（Microfacet-Model）" class="headerlink" title="二、微平面模型（Microfacet Model）"></a>二、微平面模型（Microfacet Model）</h2><p>&emsp;&emsp;PBR技术采用了微平面理论：在微观尺度下，任意的一个平面都可以用一组微小的光滑镜面来描述，这个微小的光滑镜面就是微平面（Microfacet）。根据平面粗糙程度的不同，这些微平面的排列取向也各不相同。一个平面越是粗糙，则其平面上的微平面排列就越混乱。微平面的排列越混乱，则入射光线照射到该平面上时更趋向于朝向完全不同的方向散射开来，从而产生更大范围的镜面光。同理，若平面越光滑，则其微平面排列取向越规整，入射光线大体上越趋向于向同一个方向反射，产生更小范围、更加锐利的镜面高光。正如如下图2所示。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.18/blog/Pbr/2.png" width="80%"></div></p><center> 图2 粗糙和光滑的微平面 </center><p>&emsp;&emsp;微平面的取向排列混乱程度我们采用一个粗糙度（Roughness）的参数来衡量。直接在微观尺度下操作显然不可行，因为我们将在宏观尺度下采用统计学的方法来估算微平面的粗糙度。这个粗糙度我们定义为某个向量的方向与微平面平均取向方向一致的概率，这个向量便是光线向量$l$和视线向量$v$之间的中间向量$h$：</p><script type="math/tex; mode=display">h=\frac{l+v}{||l+v||} \tag {1}</script><p>&emsp;&emsp;在一个表面的微平面中，越多微平面的法线方向与中间向量的方向一致，则镜面的反射效果就越强烈、越锐利。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.18/blog/Pbr/3.png" width="90%"></div></p><center> 图3 不同粗糙度的镜面高光 </center><h2 id="三、基于物理的BRDF"><a href="#三、基于物理的BRDF" class="headerlink" title="三、基于物理的BRDF"></a>三、基于物理的BRDF</h2><p>&emsp;&emsp;在前面的能量守恒原则和微平面理论的基础上，我们将展开基于物理的光照计算。首先我们要了解的是渲染方程，PBR采用的渲染方程是一个特化版本，也被称为反射方程，如下所示：</p><script type="math/tex; mode=display">L_o(p,\omega_o)=\int _{\Omega}f_r(p,\omega_i,\omega_o)L_i(p,\omega_i)n\cdot \omega_id\omega_i \tag {2}</script><p>&emsp;&emsp;上式中，$L_o$是反射辐射率，$L_i$是入射辐射率，$p$为物体表面上的一点，$\omega_o$为出射方向向量，$\omega_i$为入射方向向量，$n$是表面法线向量，$f_r(p,\omega_i,\omega_o)$是后面我们将要提到的BRDF函数。积分区域$\Omega$是以表面法线$n$为轴的半球领域。PBR渲染方程主要是关于光能辐射度量学的（Radiometry）的内容，这里简单介绍一些辐射度量学的物理量。</p><p>&emsp;&emsp;<strong>辐射通量（Radiant Flux）</strong>：辐射通量以瓦特为单位，符号为$\Phi$，它衡量一个光源所辐射的能量。光是由多种不同波长的能量所集合而成的，一个光源所放射出来的能量可以被视作这个光源包含的所有各种波长的一个函数。但是在计算机图形学中，我们通常采用三原色编码即RGB来简化辐射通量的表示，这套编码带来的损失基本可以忽略。</p><p>&emsp;&emsp;<strong>立体角（Solid Angle）</strong>：这个物理量在前面的文章都有提及过了，立体角符号为$\omega$，它描述了一个几何体投影到单位球面上的大小，立体角可以看成是带有体积的方向向量。</p><p>&emsp;&emsp;<strong>辐射强度（Radiant Intensity）</strong>：辐射强度衡量了在单位球面上，一个光源每单位立体角所辐射的辐射通量。其定义公式为$I=\frac{d\Phi}{d\omega}$，即微分辐射通量除以微分立体角。对于一个全向且向所有方向均匀辐射的光源，辐射强度表示了光源在一个单位球面上单位立体角的辐射能量。</p><p>&emsp;&emsp;<strong>辐射率（Radiance）</strong>：辐射率就是具有辐射强度$\Phi$的光源在单位面积$A$、单位立体角$\omega$下的辐射总能量，其定义见下面的公式$(3)$。$d\omega cos\theta$将单位立体角（也就是单位球体上的面积）投影到法线方向。</p><script type="math/tex; mode=display">L=\frac{d^2\Phi}{dAd\omega cos\theta} \tag {3}</script><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.18/blog/Pbr/4.png" width="50%"></div></p><center> 图4 辐射率示意图 </center><p>&emsp;&emsp;辐射率是辐射度量学上表示一个区域平面上光线总量的物理量，它受到入射光线与平面法线间的夹角$\theta$的余弦值$cos\theta$的影响：当直接辐射到平面上的程度越低时，光线就越弱，而当光线完全垂直于平面时强度最高。当立体角$\omega$和面积$A$趋向于无穷小时，我们能用辐射率来表示单束光线穿过空间中的一个点的通量。这就使我们可以计算得出作用于单个片段或点上的单束光线的辐射率，即把立体角$\omega$转变为方向向量然后把面$A$转换为点$p$，这样我们就能直接在我们的着色器中使用辐射率来计算单束光线对每个片段的作用。</p><p>&emsp;&emsp;上面讨论的仅仅是一束光线投射到点$p$上，但是通常我们需要计算的是所有投射到点$p$上的光线总和，这个和就是辐照度（Irradiance）。注意到反射方程$(2)$对半球领域$\Omega$进行积分，这是因为我们要计算的不只是单一一个方向上的入射光，而是一个以点$p$为球心、以法向为中轴的半球领域$\Omega$内所有方向上的入射光。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.18/blog/Pbr/5.png" width="50%"></div></p><center> 图5 半球领域 </center><p>&emsp;&emsp;由于渲染方程都没有解析解，求解公式$(2)$即反射方程时我们将采用离散的方法来积分的数值解。目前常用的就是梯形法，在半球领域$\Omega$按一定的步长将反射率方程分散求解，然后再按照步长大小将所得的结果平均化，这个就是黎曼和（Riemann Sum）。</p><p>&emsp;&emsp;然后剩下的就是BRDF函数，也就是公式$(2)$中的$f_r(p,\omega_i,\omega_o)$部分。BRDF的全称为Bidirectional Reflective Distribution Function，即双向反射分布函数。对于一个给定材质属性，BRDF函数给出了入射光和反射光的关系，一束给定入射方向的入射光照射到物体表面时，会被反射到表面半球范围内的各个方向，不同反射角度的反射光线在入射光线中的占比各不相同，BRDF函数就用来表示这种比例关系，其定义如下：</p><script type="math/tex; mode=display">f(l,v)=\frac{dL_o(v)}{dE(l)} \tag {4}</script><p>&emsp;&emsp;Cook-Torrance模型是目前应用最为广泛的基于物理的BRDF模型，它被用于很多实时渲染管线的材质和光照环境下。Cook-Torrance的BRDF包含漫反射和镜面反射两个部分，其中的镜面反射部分比较复杂：</p><script type="math/tex; mode=display">f_r=k_df_{lambert}+k_sf_{cook-torrance} \tag {5}</script><p>&emsp;&emsp;其中，$k_d$就是前面提到的入射光线中被折射的光线部分的能量占比，而$k_s$则是被反射的光线部分所占的比例。$f_{lambert}$是BRDF的漫反射部分，这个是Lambertian漫反射模型，其计算公式如下所示：</p><script type="math/tex; mode=display">f_{lambert}=\frac{c}{\pi} \tag {6}</script><p>&emsp;&emsp;其中$c$是物体的反照率（Albedo），大部分的实时渲染应用都采用了Lambertian漫反射模型。然后就是镜面反射部分，镜面反射部分就是Cook-Torrance的各向同性光照模型：</p><script type="math/tex; mode=display">f_{cook-torrance} = \frac{DFG}{4(\omega_o\cdot n)(\omega_i\cdot n)} \tag {7}</script><p>&emsp;&emsp;其中$\omega_i$是入射方向，$\omega_o$是观察方向。Cook-Torrance的模型包含三个函数，D、F、G分别是法线分布函数、菲尼尔方程、几何函数。接下来我们将讨论的是Trowbridge-Reitz GGX法线分布函数，Fresnel-Schlick菲涅尔方程以及Smith’s Schlick-GGX几何函数。</p><p>&emsp;&emsp;首先是<strong>法线分布函数（Normal Distribution Function）</strong>，给定表面的粗糙度，法线分布函数估算平面法线取向与中间向量一致的微平面数量。从统计学上讲，法线分布函数近似地描述了与中间向量$h$取向相同的微平面占全部微平面的比例。例如，给定中间向量$h$，若我们要估算的微平面中有$35\%$与向量$h$取向相同，那么法线分布函数将返回$0.35$。Trowbridge-Reitz GGX法线分布函数的数学定义如下所示：</p><script type="math/tex; mode=display">NDF_{GGXTR}(n,h,\alpha)=\frac{\alpha ^2}{\pi ((n\cdot h)^2(\alpha^2-1)+1)^2} \tag {8}</script><p>&emsp;&emsp;其中，$n$为宏观法线，$h$是中间向量，而$\alpha$则表示平面的粗糙度。当粗糙度$\alpha$值很低时，即表面比较光滑时，与中间向量$h$取向相同的微平面会高度地集中在一个小半径范围内。此时镜面反射会形成一个非常明亮的光斑。相反，当表面的粗糙度值较高时，与$h$向量取向一致的微平面分布在一个比较大的半径范围内，这使得最终的镜面反射效果显得较为灰暗。</p><p>&emsp;&emsp;然后就是<strong>菲涅尔方程（Fresnel Equation）</strong>，描述了指定角度下表面反射的光线所占的比例。当一束光线照射到表面时，菲涅尔方程会依据观察角度给出反射光线所占的百分比。然后根据这个反射光所占的百分比和能量守恒定律就可以得出光线折射部分所占的比率。当我们垂直观察物体的时候，任何表面都有一个基础的反射率。例如，用垂直的视角看向木制桌面或者金属桌面，此时只有最基本的反射，但若近乎与平面平行的角度去观察的话就会看到非常明显的反光效果。Fresnel-Schlick近似菲涅尔方程如下所示：</p><script type="math/tex; mode=display">F_{schlick}(h,v,F_0)=F_0+(1-F_0)(1-(h\cdot v))^5 \tag {9}</script><p>&emsp;&emsp;其中，$F_0$就是表面的基础反射率，它是通过折射系数计算得到的，$h$即前面提到的中间向量，$v$为观察方向向量。</p><p>&emsp;&emsp;最后就是<strong>几何函数（Geometry Function）</strong>，几何函数描述了微平面自我遮挡的属性。当一个平面比较粗糙的时候，表面上的微平面可能会挡住其他的微平面从而减弱表面反射光的强度。与法线分布函数类似，几何函数也是从统计学的角度近似求出微平面之间相互遮蔽的比率。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.18/blog/Pbr/6.png" width="50%"></div></p><center> 图6 微平面的相互遮蔽现象 </center><p>&emsp;&emsp;几何函数也采用一个材质的粗糙度作为输入的参数，越粗糙的表面其微平面之间相互遮挡的概率也就越高。Schlick-GGX几何函数的数学定义如下：</p><script type="math/tex; mode=display">G_{schlickGGX}(n,v,k)=\frac{n\cdot v}{(n\cdot v)(1-k)+k} \tag {10}</script><p>&emsp;&emsp;公式$(10)$中的$k$是关于粗糙度$\alpha$的重映射，取决于几何函数是针对直接光照还是针对IBL（Image Based Lighting）光照：</p><script type="math/tex; mode=display">k_{direct}=\frac{(\alpha+1)^2}{8} \\k_{IBL}=\frac{\alpha^2}{2} \tag {11}</script><p>&emsp;&emsp;微平面的相互遮蔽主要有两个方面，分别是几何遮蔽（Geometry Obstruction）和几何阴影（Geometry Shadowing），几何遮蔽与视线向量有关，而几何阴影则于入射方向向量相关。我们采用史密斯法将两者纳入其中：</p><script type="math/tex; mode=display">G(n,v,l,k)=G_{schlickGGX}(n,v,k)G_{schlickGGX}(n,l,k) \tag {12}</script><p>&emsp;&emsp;最终，我们得到反射方程$(2)$中的BRDF计算公式：</p><script type="math/tex; mode=display">f_r=k_d\frac{c}{\pi}+k_s\frac{DFG}{4(\omega_o\cdot n)(\omega_i\cdot n)} \tag {13}</script><p>&emsp;&emsp;实际上，BRDF的计算公式$(13)$有个错误，公式中的$F$即菲涅尔项就是$k_s$，因为菲涅尔项表示的就是反射光线的占比，因此应该把$k_s$去掉，然后$k_d=1-F$。</p><script type="math/tex; mode=display">f_r=k_d\frac{c}{\pi}+\frac{DFG}{4(\omega_o\cdot n)(\omega_i\cdot n)} \tag {14}</script><p>&emsp;&emsp;将公式$(14)$代入到公式$(2)$中，我们最终得到一个具体的渲染方程：</p><script type="math/tex; mode=display">L_o(p,\omega_o)=\int _{\Omega}(k_d\frac{c}{\pi}+\frac{DFG}{4(\omega_o\cdot n)(\omega_i\cdot n)})L_i(p,\omega_i)n\cdot \omega_id\omega_i \tag {15}</script><h2 id="三、PBR渲染器的实现"><a href="#三、PBR渲染器的实现" class="headerlink" title="三、PBR渲染器的实现"></a>三、PBR渲染器的实现</h2><p>&emsp;&emsp;有了前面的理论基础，接下来我们就展开相关的PBR实现。首先我们要讨论的是PBR材质，仔细观察渲染方程公式$(15)$，求解这个渲染方程我们需要获取物体的反照率向量、法线向量、粗糙度。除此之外，我还需要物体的金属度参数，这是因为Fresnel-Schlick近似仅仅对电介质或者说非金属表面有定义，对于导体(Conductor)表面（金属），使用它们的折射指数计算基础折射率并不能得出正确的结果。金属度用来描述一个材质表面是金属还是非金属的，基于金属表面特性，我们要么使用电介质的基础反射率要么就使用物体的表面颜色。因为金属表面会吸收所有折射光线而没有漫反射，所以我们可以直接使用表面颜色纹理来作为它们的基础反射率。</p><p>&emsp;&emsp;因此，对于一个PBR渲染器，我们需要获取物体的PBR材质，PBR材质包含了反照率（Albedo）纹理、法线（Normal）纹理、粗糙度（Roughness）纹理以及金属度（Metallic）纹理，正如如下图7所示。在一些PBR渲染器中，还有一个环境遮蔽光贴图（Ambient Occulsion），这里我们不考虑AO贴图，而是考虑在后面采用SSAO实现环境遮蔽光的效果。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.18/blog/Pbr/7.jpg" width="99%"></div></p><center> 图7 PBR材质 </center><p>&emsp;&emsp;然后还需要提一点的是，我们目前仅考虑直接光照部分，不考虑反弹多次的间接光照。仅考虑直接光照时，对于渲染方程$(15)$，我们不需要对整个半球领域进行积分，因为此时的被积函数是一个狄拉克函数。也就是被积函数仅在某一个特定的方向上才不为0，剩余部分函数值全为0，因此没有必要进行积分。在光照计算中，我们是可以直接知道空间中的光源位置，因此可以直接计算。当空间中有多个光源时，渲染方程的值就是直接计算点与这些光源之间的被击函数值最后累加起来。</p><script type="math/tex; mode=display">L_o(p,\omega_o)=\Sigma_{i}^m(k_d\frac{c}{\pi}+\frac{DFG}{4(\omega_o\cdot n)(\omega_i\cdot n)})L_i(p,\omega_i)n\cdot \omega_i \tag {16}</script><p>&emsp;&emsp;公式$(16)$就是场景中有$m$个光源时的实际渲染方程。为了支持大量的光源，我采用了延迟渲染，将物体空间位置和PBR材质信息存储到多张纹理中，然后在屏幕空间计算光照。首先将物体的信息渲染到纹理中，因为采用了法线贴图，所以要在顶点着色器中构建TBN矩阵提取出法线向量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">---------------Vertex Shader-------------------</span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 position;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec3 normal;</span><br><span class="line">layout (location = <span class="number">2</span>) in vec2 texcoord;</span><br><span class="line">layout (location = <span class="number">3</span>) in vec3 color;</span><br><span class="line">layout (location = <span class="number">4</span>) in vec3 tangent;</span><br><span class="line">layout (location = <span class="number">5</span>) in vec3 bitangent;</span><br><span class="line">layout (location = <span class="number">6</span>) in mat4 instanceMatrix;</span><br><span class="line"></span><br><span class="line">out vec3 FragPos;</span><br><span class="line">out vec2 Texcoord;</span><br><span class="line">out mat3 TBNMatrix;</span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">bool</span> instance;</span><br><span class="line">uniform mat4 modelMatrix;</span><br><span class="line">uniform mat4 viewMatrix;</span><br><span class="line">uniform mat4 projectMatrix;</span><br><span class="line">uniform mat4 normalMatrix;</span><br><span class="line">uniform mat4 lightSpaceMatrix;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">vec3 T = normalize(vec3(modelMatrix * vec4(tangent, <span class="number">0.0f</span>)));</span><br><span class="line">vec3 B = normalize(vec3(modelMatrix * vec4(bitangent, <span class="number">0.0f</span>)));</span><br><span class="line">vec3 N = normalize(vec3(modelMatrix * vec4(normal, <span class="number">0.0f</span>)));</span><br><span class="line">TBNMatrix = mat3(T, B, N);</span><br><span class="line">Texcoord = texcoord;</span><br><span class="line"><span class="keyword">if</span>(!instance)</span><br><span class="line">FragPos = vec3(modelMatrix * vec4(position,<span class="number">1.0f</span>));</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">FragPos = vec3(modelMatrix * instanceMatrix * vec4(position,<span class="number">1.0f</span>));</span><br><span class="line">gl_Position = projectMatrix * viewMatrix * vec4(FragPos,<span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------Fragment Shader-------------------</span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">in vec3 FragPos;</span><br><span class="line">in vec2 Texcoord;</span><br><span class="line">in mat3 TBNMatrix;</span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> nearPlane;</span><br><span class="line">uniform <span class="keyword">float</span> farPlane;</span><br><span class="line">uniform sampler2D albedoMap;</span><br><span class="line">uniform sampler2D normalMap;</span><br><span class="line">uniform sampler2D roughMap;</span><br><span class="line">uniform sampler2D metallicMap;</span><br><span class="line">uniform sampler2D depthMap;</span><br><span class="line"></span><br><span class="line">layout(location = <span class="number">0</span>) out vec3 dposition;</span><br><span class="line">layout(location = <span class="number">1</span>) out vec3 dnormal;</span><br><span class="line">layout(location = <span class="number">2</span>) out vec3 dalbedo;</span><br><span class="line">layout(location = <span class="number">3</span>) out vec3 droughness;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// sample albedo.</span></span><br><span class="line">vec3 albedo = texture(albedoMap, Texcoord).rgb;</span><br><span class="line"><span class="comment">// sample normal.</span></span><br><span class="line">vec3 normal = normalize(<span class="number">2.0f</span> * texture(normalMap, Texcoord).rgb - vec3(<span class="number">1.0f</span>));</span><br><span class="line">normal = TBNMatrix * normal;</span><br><span class="line"><span class="comment">// sample roughness.</span></span><br><span class="line"><span class="keyword">float</span> roughness = texture(roughMap, Texcoord).r;</span><br><span class="line"><span class="comment">// sample metallic.</span></span><br><span class="line"><span class="keyword">float</span> metallic = texture(metallicMap, Texcoord).r;</span><br><span class="line">dposition = FragPos;</span><br><span class="line">dnormal = normal;</span><br><span class="line">dalbedo = albedo;</span><br><span class="line">droughness = vec3(roughness, metallic, gl_FragCoord.z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后在屏幕空间中实现我们的PBR算法。首先是BRDF的三个函数。根据公式$(8)$，法线分布函数如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">NormalDistributionGGX</span><span class="params">(vec3 N, vec3 H, <span class="keyword">float</span> roughness)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">float</span> a = roughness * roughness;</span><br><span class="line"><span class="keyword">float</span> aSquared = a * a;</span><br><span class="line"><span class="keyword">float</span> NdotH = max(dot(N, H), <span class="number">0.0f</span>);</span><br><span class="line"><span class="keyword">float</span> NdotHSquared = NdotH * NdotH;</span><br><span class="line"><span class="keyword">float</span> nom = aSquared;</span><br><span class="line"><span class="keyword">float</span> denom = (NdotHSquared * (aSquared - <span class="number">1.0f</span>) + <span class="number">1.0f</span>);</span><br><span class="line">denom = PI * denom * denom;</span><br><span class="line"><span class="keyword">return</span> nom / denom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据公式$(9)$，菲涅尔方程的计算代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">fresnelSchlick</span><span class="params">(<span class="keyword">float</span> cosTheta, vec3 F0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> F0 + (<span class="number">1.0f</span> - F0) * <span class="built_in">pow</span>(<span class="number">1.0</span> - cosTheta, <span class="number">5.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据公式$(10)$、$(11)$、$(12)$，几何函数的计算代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GeometrySchlickGGX</span><span class="params">(<span class="keyword">float</span> NdotV, <span class="keyword">float</span> roughness)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">float</span> r = (roughness + <span class="number">1.0f</span>);</span><br><span class="line"><span class="keyword">float</span> k = (r * r) / <span class="number">8.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> nom = NdotV;</span><br><span class="line"><span class="keyword">float</span> denom = NdotV * (<span class="number">1.0f</span> - k) + k;</span><br><span class="line"><span class="keyword">return</span> nom / denom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GeometrySmith</span><span class="params">(vec3 N, vec3 V, vec3 L, <span class="keyword">float</span> roughness)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">float</span> NdotV = max(dot(N, V), <span class="number">0.0f</span>);</span><br><span class="line"><span class="keyword">float</span> NdotL = max(dot(N, L), <span class="number">0.0f</span>);</span><br><span class="line"><span class="keyword">float</span> ggx2 = GeometrySchlickGGX(NdotV, roughness);</span><br><span class="line"><span class="keyword">float</span> ggx1 = GeometrySchlickGGX(NdotL, roughness);</span><br><span class="line"><span class="keyword">return</span> ggx2 * ggx1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后就是光照部分，我实现的渲染器支持一个平行光、多个点光源。首先来看平行光部分，平行光部分因为不用考虑衰减，因而更为简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DirLight</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    vec3 direction;</span><br><span class="line">    vec3 radiance;</span><br><span class="line">&#125;;</span><br><span class="line">uniform DirLight dirLight;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// sample position.</span></span><br><span class="line">vec3 FragPos = texture(dposition, Texcoord).rgb;</span><br><span class="line"><span class="comment">// sample albedo.</span></span><br><span class="line">vec3 albedo = texture(dalbedo, Texcoord).rgb;</span><br><span class="line"><span class="comment">// sample normal.</span></span><br><span class="line">vec3 normal = texture(dnormal, Texcoord).rgb;</span><br><span class="line"><span class="comment">// sample roughness.</span></span><br><span class="line"><span class="keyword">float</span> roughness = texture(droughness, Texcoord).r;</span><br><span class="line"><span class="comment">// sample metallic.</span></span><br><span class="line"><span class="keyword">float</span> metallic = texture(droughness, Texcoord).g;</span><br><span class="line"><span class="comment">// sample depth.</span></span><br><span class="line"><span class="keyword">float</span> depth = texture(droughness, Texcoord).b;</span><br><span class="line"><span class="comment">// sample ambient occlusion.</span></span><br><span class="line"><span class="keyword">float</span> ao = texture(ddepth, Texcoord).r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// emssive</span></span><br><span class="line"><span class="keyword">if</span>(normal.x == <span class="number">0.0f</span> &amp;&amp; normal.y == <span class="number">0.0f</span> &amp;&amp; normal.z == <span class="number">0.0f</span>)</span><br><span class="line">&#123;</span><br><span class="line">fragColor.rgb = albedo;</span><br><span class="line"><span class="comment">// glow map.</span></span><br><span class="line"><span class="keyword">float</span> brightness = dot(fragColor.rgb, vec3(<span class="number">0.2126</span>, <span class="number">0.7152</span>, <span class="number">0.0722</span>));</span><br><span class="line">brightColor = vec4(fragColor.rgb, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// write depth to buffer for forwarding shading.</span></span><br><span class="line">gl_FragDepth = depth;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// some directions.</span></span><br><span class="line">vec3 viewDir = normalize(cameraPos - FragPos);</span><br><span class="line"><span class="comment">// index of refracted.</span></span><br><span class="line">vec3 F0 = vec3(<span class="number">0.04</span>);</span><br><span class="line">F0 = mix(F0, albedo, metallic);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ************************directional light************************************</span></span><br><span class="line">vec3 lightDir = dirLight.direction;</span><br><span class="line">vec3 halfwayDir = normalize(lightDir + viewDir);</span><br><span class="line"><span class="comment">// fresnel factor.</span></span><br><span class="line">vec3 fresnel = fresnelSchlick(max(dot(halfwayDir, viewDir), <span class="number">0.0f</span>), F0);</span><br><span class="line"><span class="comment">// normal distribution factor.</span></span><br><span class="line"><span class="keyword">float</span> distribution = NormalDistributionGGX(normal, halfwayDir, roughness);</span><br><span class="line"><span class="comment">// geometry facror.</span></span><br><span class="line"><span class="keyword">float</span> geometryFactor = GeometrySmith(normal, viewDir, lightDir, roughness);</span><br><span class="line"><span class="comment">// brdf function.</span></span><br><span class="line">vec3 brdf = distribution * fresnel * geometryFactor / </span><br><span class="line">(<span class="number">4.0f</span> * max(dot(viewDir, normal), <span class="number">0.0f</span>) * max(dot(lightDir, normal), <span class="number">0.0f</span>) + <span class="number">0.0001f</span>);</span><br><span class="line">vec3 kSpecular = fresnel;</span><br><span class="line">vec3 kDiffuse = vec3(<span class="number">1.0f</span>) - kSpecular;</span><br><span class="line">kDiffuse *= (<span class="number">1.0f</span> - metallic);</span><br><span class="line"><span class="comment">// rendering equation.</span></span><br><span class="line">fragColor.rgb = (kDiffuse * albedo / PI + brdf) * dirLight.radiance * max(dot(normal, lightDir), <span class="number">0.0f</span>);</span><br><span class="line"><span class="comment">// *****************************************************************************</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// other.</span></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;需要特别说明的就是基础反射率部分，在上面的代码第41、42行，对于电介质我们令其基础反射率为0.04，然后根据材质的金属度在0.04和反照率直接做一个混合。然后就是点光源部分，点光源通常要有一个衰减的过程，这里我采用的衰减因子计算公式如下：</p><script type="math/tex; mode=display">attenuation = \frac{1.0}{c\cdot d^2}\\d = length(lightPosition - fragPosition) \tag {17}</script><p>&emsp;&emsp;即点光的光照强度以距离的平方的倒数衰减，其中$c$是衰减系数，可由用户根据想要的效果指定。确定了衰减方程之后，我们还需要计算点光源的光体积，这是因为当光源与当前点的距离超过一定的值时，计算得到的光照值将小到可以忽略不计。因此，我们可以做这样的一个优化，当距离超过一定值时直接不计算光照，这对于拥有大量光源的场景来说是非常有意义的，它能够减少大量的计算。</p><p>&emsp;&emsp;那么如何知道这个距离的阈值呢？这个距离的阈值必须要刚刚好，太小则会产生明显的光照硬边，太大则优化又没有那么明显。事实上，这个距离阈值与上面的衰减因子计算（即公式$(17)$）息息相关。理想情况下，当$attenuation$变为0时，光照的贡献值也变为0。但是事实上$attenuation$不能为0，只能无限地趋于0，我们可以根据一个自己设置的阈值来求解$d$，我设置的阈值为$\frac{1}{256}$，当光照贡献值小于这个值时，可以忽略不计了：</p><script type="math/tex; mode=display">\frac{1}{256}=I_{max}\cdot attenuation = I_{max}\frac{1.0}{c\cdot d^2}\\\to d=\sqrt{\frac{256I_{max}}{c}} \tag {18}</script><p>&emsp;&emsp;上式中的$I_{max}$是光照颜色中的最大分量，根据公式$(18)$我们就得到了点光源的光体积，这是一个以该$d$为半径的球体。当片段位置到光源位置的距离大于这个半径时，我们直接跳过该光源的光照计算。这个光体积直接在CPU上计算一次即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PointLight::setAttenuationCoff(<span class="keyword">float</span> coff)</span><br><span class="line">&#123;</span><br><span class="line">m_atteunationCoff = coff;</span><br><span class="line"><span class="comment">// calculate point light's volume.</span></span><br><span class="line">GLfloat lightMax = <span class="built_in">std</span>::fmaxf(<span class="built_in">std</span>::fmaxf(m_radiance.r, m_radiance.g), m_radiance.b);</span><br><span class="line">m_radius = <span class="built_in">sqrt</span>(<span class="number">256.0f</span> * lightMax / (<span class="number">1.0f</span> * m_atteunationCoff));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PointLight::setLightColor(glm::vec3 radiance)</span><br><span class="line">&#123;</span><br><span class="line">Light::setLightColor(radiance);</span><br><span class="line"><span class="comment">// calculate point light's volume.</span></span><br><span class="line">GLfloat lightMax = <span class="built_in">std</span>::fmaxf(<span class="built_in">std</span>::fmaxf(m_radiance.r, m_radiance.g), m_radiance.b);</span><br><span class="line">m_radius = <span class="built_in">sqrt</span>(<span class="number">256.0f</span> * lightMax / (<span class="number">1.0f</span> * m_atteunationCoff));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后完整的着色器代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">in vec2 Texcoord;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DirLight</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    vec3 direction;</span><br><span class="line">    vec3 radiance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PointLight</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">float</span> radius;</span><br><span class="line">vec3 position;</span><br><span class="line">vec3 radiance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uniform vec3 cameraPos;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lighting.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_POINT_LIGHT 128</span></span><br><span class="line">uniform <span class="keyword">int</span> pointLightNum;</span><br><span class="line">uniform DirLight dirLight;</span><br><span class="line">uniform PointLight pointLight[MAX_POINT_LIGHT];</span><br><span class="line">uniform <span class="keyword">float</span> lightAttenuationCoff;</span><br><span class="line">uniform mat4 lightSpaceMatrix;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pbr material texture.</span></span><br><span class="line">uniform sampler2D dposition;</span><br><span class="line">uniform sampler2D dnormal;</span><br><span class="line">uniform sampler2D dalbedo;</span><br><span class="line">uniform sampler2D droughness;</span><br><span class="line">uniform sampler2D ddepth;</span><br><span class="line">uniform sampler2D shadowDepth;</span><br><span class="line"></span><br><span class="line">layout(location = <span class="number">0</span>) out vec4 fragColor;</span><br><span class="line">layout(location = <span class="number">1</span>) out vec4 brightColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// brdf auxiliary functions.</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">NormalDistributionGGX</span><span class="params">(vec3 N, vec3 H, <span class="keyword">float</span> roughness)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GeometrySchlickGGX</span><span class="params">(<span class="keyword">float</span> NdotV, <span class="keyword">float</span> roughness)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GeometrySmith</span><span class="params">(vec3 N, vec3 V, vec3 L, <span class="keyword">float</span> roughness)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">fresnelSchlick</span><span class="params">(<span class="keyword">float</span> cosTheta, vec3 F0)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">shadowCalculation</span><span class="params">(vec4 fragPosLightSpace, <span class="keyword">float</span> bias)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> PI = <span class="number">3.14159265359</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// sample position.</span></span><br><span class="line">vec3 FragPos = texture(dposition, Texcoord).rgb;</span><br><span class="line"><span class="comment">// sample albedo.</span></span><br><span class="line">vec3 albedo = texture(dalbedo, Texcoord).rgb;</span><br><span class="line"><span class="comment">// sample normal.</span></span><br><span class="line">vec3 normal = texture(dnormal, Texcoord).rgb;</span><br><span class="line"><span class="comment">// sample roughness.</span></span><br><span class="line"><span class="keyword">float</span> roughness = texture(droughness, Texcoord).r;</span><br><span class="line"><span class="comment">// sample metallic.</span></span><br><span class="line"><span class="keyword">float</span> metallic = texture(droughness, Texcoord).g;</span><br><span class="line"><span class="comment">// sample depth.</span></span><br><span class="line"><span class="keyword">float</span> depth = texture(droughness, Texcoord).b;</span><br><span class="line"><span class="comment">// sample ambient occlusion.</span></span><br><span class="line"><span class="keyword">float</span> ao = texture(ddepth, Texcoord).r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// emssive</span></span><br><span class="line"><span class="keyword">if</span>(normal.x == <span class="number">0.0f</span> &amp;&amp; normal.y == <span class="number">0.0f</span> &amp;&amp; normal.z == <span class="number">0.0f</span>)</span><br><span class="line">&#123;</span><br><span class="line">fragColor.rgb = albedo;</span><br><span class="line"><span class="comment">// glow map.</span></span><br><span class="line"><span class="keyword">float</span> brightness = dot(fragColor.rgb, vec3(<span class="number">0.2126</span>, <span class="number">0.7152</span>, <span class="number">0.0722</span>));</span><br><span class="line">brightColor = vec4(fragColor.rgb, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// write depth to buffer for forwarding shading.</span></span><br><span class="line">gl_FragDepth = depth;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// some directions.</span></span><br><span class="line">vec3 viewDir = normalize(cameraPos - FragPos);</span><br><span class="line"><span class="comment">// index of refracted.</span></span><br><span class="line">vec3 F0 = vec3(<span class="number">0.04</span>);</span><br><span class="line">F0 = mix(F0, albedo, metallic);</span><br><span class="line"></span><br><span class="line"><span class="comment">// *******************************directional light************************************</span></span><br><span class="line">vec3 lightDir = dirLight.direction;</span><br><span class="line">vec3 halfwayDir = normalize(lightDir + viewDir);</span><br><span class="line"><span class="comment">// fresnel factor.</span></span><br><span class="line">vec3 fresnel = fresnelSchlick(max(dot(halfwayDir, viewDir), <span class="number">0.0f</span>), F0);</span><br><span class="line"><span class="comment">// normal distribution factor.</span></span><br><span class="line"><span class="keyword">float</span> distribution = NormalDistributionGGX(normal, halfwayDir, roughness);</span><br><span class="line"><span class="comment">// geometry facror.</span></span><br><span class="line"><span class="keyword">float</span> geometryFactor = GeometrySmith(normal, viewDir, lightDir, roughness);</span><br><span class="line"><span class="comment">// brdf function.</span></span><br><span class="line">vec3 brdf = distribution * fresnel * geometryFactor / </span><br><span class="line">(<span class="number">4.0f</span> * max(dot(viewDir, normal), <span class="number">0.0f</span>) * max(dot(lightDir, normal), <span class="number">0.0f</span>) + <span class="number">0.0001f</span>);</span><br><span class="line">vec3 kSpecular = fresnel;</span><br><span class="line">vec3 kDiffuse = vec3(<span class="number">1.0f</span>) - kSpecular;</span><br><span class="line">kDiffuse *= (<span class="number">1.0f</span> - metallic);</span><br><span class="line"><span class="comment">// rendering equation.</span></span><br><span class="line">fragColor.rgb = (kDiffuse * albedo / PI + brdf) * dirLight.radiance * max(dot(normal, lightDir), <span class="number">0.0f</span>);</span><br><span class="line"><span class="comment">// ************************************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// *************************************point lights***********************************</span></span><br><span class="line">vec3 pointLightRadiance = vec3(<span class="number">0.0f</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; pointLightNum;++ i)</span><br><span class="line">&#123;</span><br><span class="line">vec3 lightDir = normalize(pointLight[i].position - FragPos);</span><br><span class="line">vec3 halfwayDir = normalize(viewDir + lightDir);</span><br><span class="line"><span class="keyword">float</span> distance = length(pointLight[i].position - FragPos);</span><br><span class="line"><span class="keyword">if</span>(distance &gt; pointLight[i].radius) </span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">float</span> attenuation = <span class="number">1.0f</span> / (lightAttenuationCoff * distance * distance + <span class="number">0.00001</span>);</span><br><span class="line">vec3 radiance = pointLight[i].radiance * attenuation;</span><br><span class="line"></span><br><span class="line">vec3 fresnel = fresnelSchlick(max(dot(halfwayDir, viewDir), <span class="number">0.0f</span>), F0);</span><br><span class="line"><span class="comment">// normal distribution factor.</span></span><br><span class="line"><span class="keyword">float</span> distribution = NormalDistributionGGX(normal, halfwayDir, roughness);</span><br><span class="line"><span class="comment">// geometry facror.</span></span><br><span class="line"><span class="keyword">float</span> geometryFactor = GeometrySmith(normal, viewDir, lightDir, roughness);</span><br><span class="line"><span class="comment">// brdf function.</span></span><br><span class="line">vec3 brdf = distribution * fresnel * geometryFactor / </span><br><span class="line">(<span class="number">4.0f</span> * max(dot(viewDir, normal), <span class="number">0.0f</span>) * max(dot(lightDir, normal), <span class="number">0.0f</span>) + <span class="number">0.0001f</span>);</span><br><span class="line">vec3 kSpecular = fresnel;</span><br><span class="line">vec3 kDiffuse = vec3(<span class="number">1.0f</span>) - kSpecular;</span><br><span class="line">kDiffuse *= (<span class="number">1.0f</span> - metallic);</span><br><span class="line"><span class="comment">// rendering equation.</span></span><br><span class="line">pointLightRadiance += (kDiffuse * albedo / PI + brdf) * radiance * max(dot(normal, lightDir), <span class="number">0.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ************************************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// shadow</span></span><br><span class="line"><span class="keyword">float</span> shadow = <span class="number">1.0f</span>;</span><br><span class="line">vec4 FragPosLightSpace = lightSpaceMatrix * vec4(FragPos, <span class="number">1.0f</span>);</span><br><span class="line">shadow = <span class="number">1.0f</span> - shadowCalculation(FragPosLightSpace, <span class="number">0.0f</span>);</span><br><span class="line">fragColor.xyz = ao * albedo * <span class="number">0.02f</span> + fragColor.xyz * shadow + pointLightRadiance;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glow map.</span></span><br><span class="line"><span class="keyword">float</span> brightness = dot(fragColor.rgb / (fragColor.rgb + vec3(<span class="number">1.0f</span>)), vec3(<span class="number">0.2126</span>, <span class="number">0.7152</span>, <span class="number">0.0722</span>));</span><br><span class="line"><span class="keyword">if</span>(brightness &gt; <span class="number">0.55f</span>)</span><br><span class="line">brightColor = vec4(fragColor.rgb / (fragColor.rgb + vec3(<span class="number">1.0f</span>)), <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// write depth to buffer for forwarding shading.</span></span><br><span class="line">gl_FragDepth = depth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">NormalDistributionGGX</span><span class="params">(vec3 N, vec3 H, <span class="keyword">float</span> roughness)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">float</span> a = roughness * roughness;</span><br><span class="line"><span class="keyword">float</span> aSquared = a * a;</span><br><span class="line"><span class="keyword">float</span> NdotH = max(dot(N, H), <span class="number">0.0f</span>);</span><br><span class="line"><span class="keyword">float</span> NdotHSquared = NdotH * NdotH;</span><br><span class="line"><span class="keyword">float</span> nom = aSquared;</span><br><span class="line"><span class="keyword">float</span> denom = (NdotHSquared * (aSquared - <span class="number">1.0f</span>) + <span class="number">1.0f</span>);</span><br><span class="line">denom = PI * denom * denom;</span><br><span class="line"><span class="keyword">return</span> nom / denom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GeometrySchlickGGX</span><span class="params">(<span class="keyword">float</span> NdotV, <span class="keyword">float</span> roughness)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">float</span> r = (roughness + <span class="number">1.0f</span>);</span><br><span class="line"><span class="keyword">float</span> k = (r * r) / <span class="number">8.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> nom = NdotV;</span><br><span class="line"><span class="keyword">float</span> denom = NdotV * (<span class="number">1.0f</span> - k) + k;</span><br><span class="line"><span class="keyword">return</span> nom / denom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GeometrySmith</span><span class="params">(vec3 N, vec3 V, vec3 L, <span class="keyword">float</span> roughness)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">float</span> NdotV = max(dot(N, V), <span class="number">0.0f</span>);</span><br><span class="line"><span class="keyword">float</span> NdotL = max(dot(N, L), <span class="number">0.0f</span>);</span><br><span class="line"><span class="keyword">float</span> ggx2 = GeometrySchlickGGX(NdotV, roughness);</span><br><span class="line"><span class="keyword">float</span> ggx1 = GeometrySchlickGGX(NdotL, roughness);</span><br><span class="line"><span class="keyword">return</span> ggx2 * ggx1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vec3 <span class="title">fresnelSchlick</span><span class="params">(<span class="keyword">float</span> cosTheta, vec3 F0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> F0 + (<span class="number">1.0f</span> - F0) * <span class="built_in">pow</span>(<span class="number">1.0</span> - cosTheta, <span class="number">5.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">shadowCalculation</span><span class="params">(vec4 fragPosLightSpace, <span class="keyword">float</span> bias)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// perspective division.</span></span><br><span class="line">vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;</span><br><span class="line">projCoords = projCoords * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(projCoords.z &gt; <span class="number">1.0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pcf.</span></span><br><span class="line"><span class="keyword">float</span> shadowFactor = <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">float</span> currentDepth = projCoords.z;</span><br><span class="line">vec2 texelSize = <span class="number">1.0</span> / textureSize(shadowDepth, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">-1</span>; x &lt;= <span class="number">1</span>; ++x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">-1</span>; y &lt;= <span class="number">1</span>; ++y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> pcfDepth = texture(shadowDepth, projCoords.xy + vec2(x, y) * texelSize).r; </span><br><span class="line">        shadowFactor += ((currentDepth - bias) &gt; pcfDepth) ? <span class="number">1.0</span> : <span class="number">0.0</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">shadowFactor /= <span class="number">9.0</span>;</span><br><span class="line"><span class="keyword">return</span> shadowFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、屏幕空间环境光遮蔽"><a href="#四、屏幕空间环境光遮蔽" class="headerlink" title="四、屏幕空间环境光遮蔽"></a>四、屏幕空间环境光遮蔽</h2><p>&emsp;&emsp;本文前面主要介绍了PBR的直接光照，这意味着在没有被光源直接照亮的区域，依然没有产生符合物理规律的光影效果，这是因为我们还没有考虑间接光照。在实时应用中，为了实现物体的相互遮蔽效果，通常采用SSAO（即Screen Space Ambient Occlusion），实际上这是一个比较tricky的做法，但是产生的效果非常不错。</p><p>&emsp;&emsp;SSAO采用的原理非常简单，：对于每一个片段，我们都会根据周边深度值计算一个<strong>遮蔽因子(Occlusion Factor)</strong>。这个遮蔽因子之后会被用来减少或者抵消片段的环境光照分量。遮蔽因子是通过采集片段周围球型核心(Kernel)的多个深度样本，并和当前片段深度值对比而得到的。高于片段深度值样本的个数就是我们想要的遮蔽因子。正如下图8所示。到这里文章篇幅有点太长了，SSAO也比较简单，因此我就不再赘述了。SSAO因子计算的核心代码：</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.18/blog/Pbr/7.png" width="60%"></div></p><center> 图8 Occlusion Factor </center><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 430 core</span></span><br><span class="line">in vec2 Texcoord;</span><br><span class="line"></span><br><span class="line">uniform vec3 samples[<span class="number">64</span>];</span><br><span class="line">uniform mat4 viewMatrix;</span><br><span class="line">uniform mat4 projectMatrix;</span><br><span class="line">uniform sampler2D dposition;</span><br><span class="line">uniform sampler2D dnormal;</span><br><span class="line">uniform sampler2D ddepth;</span><br><span class="line">uniform sampler2D randomNoise;</span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> farPlane;</span><br><span class="line">uniform <span class="keyword">float</span> nearPlane;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> radius = <span class="number">10.0f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sampleNum = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// sample position.</span></span><br><span class="line">vec3 FragPos = texture(dposition, Texcoord).rgb;</span><br><span class="line"><span class="comment">// sample normal.</span></span><br><span class="line">vec3 normal = texture(dnormal, Texcoord).rgb;</span><br><span class="line"><span class="comment">// sample depth.</span></span><br><span class="line"><span class="keyword">float</span> depth = texture(ddepth, Texcoord).r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sample random vectors.</span></span><br><span class="line">vec2 depthTextureSize = textureSize(ddepth, <span class="number">0</span>);</span><br><span class="line">vec2 noiseTextureSize = textureSize(randomNoise, <span class="number">0</span>);</span><br><span class="line">vec2 noiseTexScale = vec2(depthTextureSize.x / noiseTextureSize.x, depthTextureSize.y / noiseTextureSize.y);</span><br><span class="line">vec3 randomVec = texture(randomNoise, Texcoord * noiseTexScale).rgb;</span><br><span class="line"></span><br><span class="line">vec3 tangent = normalize(randomVec - normal * dot(randomVec, normal));</span><br><span class="line">vec3 bitangent = cross(normal, tangent);</span><br><span class="line">mat3 TBNMatrix = mat3(tangent, bitangent, normal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// calculate ambient occlusion.</span></span><br><span class="line"><span class="keyword">float</span> occlusion = <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; sampleNum;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// change to world space.</span></span><br><span class="line">vec3 samplePoint = TBNMatrix * samples[i];</span><br><span class="line">samplePoint = FragPos + samplePoint * radius;</span><br><span class="line"></span><br><span class="line"><span class="comment">// change to view space.</span></span><br><span class="line">samplePoint = vec3(viewMatrix * vec4(samplePoint, <span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// change to ndc space &amp; screen space.</span></span><br><span class="line">vec4 tmp = vec4(samplePoint, <span class="number">1.0f</span>);</span><br><span class="line">tmp = projectMatrix * tmp;</span><br><span class="line">tmp.xyz /= tmp.w;</span><br><span class="line">tmp.xyz = tmp.xyz * <span class="number">0.5f</span> + <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get sample point's depth.</span></span><br><span class="line"><span class="keyword">float</span> sampleDepth = texture(ddepth, tmp.xy).r;</span><br><span class="line">samplePoint.z /= -farPlane;</span><br><span class="line"></span><br><span class="line"><span class="comment">// range check and accumulate.</span></span><br><span class="line"><span class="keyword">float</span> rangeCheck = smoothstep(<span class="number">0.0</span>, <span class="number">1.0</span>, radius / (<span class="built_in">abs</span>(depth - sampleDepth) * farPlane));</span><br><span class="line">occlusion += (sampleDepth &gt; samplePoint.z ? <span class="number">0.0</span> : <span class="number">1.0</span>) * rangeCheck;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">occlusion /= sampleNum;</span><br><span class="line">occlusion = <span class="number">1.0f</span> - occlusion;</span><br><span class="line"></span><br><span class="line">gl_FragDepth = occlusion;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;SSAO对于场景的真实感觉有着非常重要的作用，可能我们平时不会太过注意，但是却又是一个非常关键的点。下面左边就是计算得到的AO因子，最后将AO因子的乘上物体的反照率以及环境光缩放系数即可。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.18/blog/Pbr/8.png" width="90%"></div></p><center> 图9 ao因子计算结果 </center><h2 id="五、实现效果"><a href="#五、实现效果" class="headerlink" title="五、实现效果"></a>五、实现效果</h2><p>&emsp;&emsp;除了PBR、SSAO，其他如延迟渲染、HDR、Glow Effect、因子等不再赘述。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.18/blog/Pbr/ret1.png" width="90%"></div></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.18/blog/Pbr/ret2.png" width="90%"></div></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.18/blog/Pbr/ret3.png" width="90%"></div></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.18/blog/Pbr/ret4.png" width="90%"></div></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.18/blog/Pbr/ret5.png" width="90%"></div></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.18/blog/Pbr/ret6.png" width="90%"></div></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.18/blog/Pbr/ret7.png" width="90%"></div></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.18/blog/Pbr/retAni1.gif" width="90%"></div></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.18/blog/Pbr/retAni2.gif" width="90%"></div></p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>$[1]$ <a href="https://learnopengl.com/PBR/Theory" target="_blank" rel="noopener">https://learnopengl.com/PBR/Theory</a></p><p>$[2]$ <a href="https://learnopengl.com/PBR/Lighting" target="_blank" rel="noopener">https://learnopengl.com/PBR/Lighting</a></p><p>$[3]$ <a href="https://learnopengl.com/Advanced-Lighting/Deferred-Shading" target="_blank" rel="noopener">https://learnopengl.com/Advanced-Lighting/Deferred-Shading</a></p><p>$[4]$ <a href="https://learnopengl.com/Advanced-Lighting/SSAO" target="_blank" rel="noopener">https://learnopengl.com/Advanced-Lighting/SSAO</a></p></div>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Real-time Rendering </category>
          
          <category> Physically Based Rendering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> Real-time Rendering </tag>
            
            <tag> Physically Based Rendering </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流体渲染Fluid Rendering：基于屏幕空间的液体渲染</title>
      <link href="/2019/07/04/FluidRendering/"/>
      <url>/2019/07/04/FluidRendering/</url>
      
        <content type="html"><![CDATA[<p>本文主要是关于屏幕空间的液体渲染算法，分别介绍了高斯滤波、双边滤波和曲率流方法平滑流体深度的方法。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.17/blog/FluidRendering/header.gif" width="99%"></div></p><a id="more"></a><ul><li>基于屏幕空间的流体渲染</li><li>水体的光照计算</li><li>流体深度贴图的平滑处理</li><li>实现效果</li><li>参考资料</li></ul><center><font size="6">基于屏幕空间的流体渲染</font></center><p>&emsp;&emsp;在计算机图形学中，我们最后都要把模拟的物体渲染出来，这是图形学的最终目的。而目前对于流体渲染，无论是基于拉格朗日视角的还是基于欧拉视角的流体模拟都要经过流体表面重建这一步，然后再做进一步的光照着色计算。流体表面重建有个非常经典的算法——Marching Cubes$^{[2]}$，该方法采用水平集（Level Set），首先将空间划分称均匀的立方体网格，然后计算每个网格上8个顶点的密度。对于每一个立方体，如果立方体上的一条边两个端点的密度值大于给定的一个阈值$\rho_{boundary}$，则这条边上存在着一个流体表面上的顶点。最后将每个立方体构造的多边形拼接，即可得到流体的表面网格。该方法基于这样的一个事实：流体表面处的密度应该等于某个固定的值，流体表面是一个三维的密度等高面，密度值为$\rho_{boundary}$，这就是水平集的思想。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.17/blog/FluidRendering/1.png" width="80%"></div></p><center> 图1 Marching Cube的15种模式 </center><p>&emsp;&emsp;Marching Cube是流体表面重建的传统做法，实现效果非常不错，但是算法的时间复杂度大，重建一次需要花费不少的时间。对于流动的流体来说，需要每帧构建流体表面，因而很难保证实时性。除了Marching Cube这类传统的流体表面重建方法，还有一些技巧性比较强的方法适合实时性应用，基于屏幕空间的流体渲染方法就是这一类。基于屏幕空间的流体渲染以一种新的思路角度展开流体的渲染，这种方法对并行友好，不涉及到直接对液体表面网格的重建，实现也相对简单。</p><h2 id="一、基于屏幕空间的流体渲染"><a href="#一、基于屏幕空间的流体渲染" class="headerlink" title="一、基于屏幕空间的流体渲染"></a>一、基于屏幕空间的流体渲染</h2><p>&emsp;&emsp;首先介绍一些基于屏幕空间的流体渲染算法纵览。与在世界空间构建流体表面网格的思路不同，基于屏幕空间的流体渲染算法直接在屏幕空间做流体表面的复原工作，操作维度从三维降到了二维。这是一种与图形处理紧密结合的渲染算法。算法分为两个步骤，重点在于第一个步骤。第一个步骤是屏幕空间流体处理步骤，首先将流体粒子按照当前的投影矩阵和视图矩阵渲染到屏幕空间，获取流体粒子的深度轮廓信息、流体厚度信息，这些信息存储到纹理中，紧接着我们对存储深度信息的纹理做一些后处理操作，模糊掉球形粒子的坑坑洼洼，使得深度信息更为平滑，最后我们根据深度纹理和厚度纹理做流体的光照计算。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.17/blog/FluidRendering/2.png" width="80%"></div></p><center> 图2 Screen Space Fluid Rendering算法总览 </center><p>&emsp;&emsp;算法的总流程如图2所示，其中的噪声图像生成不是必须的，实际上我觉得加上这个噪声处理反而是个败笔。对于水体来说，它的表面通常是比较光滑的而不是坑坑洼洼。背景图用于处理流体的折射计算，因此流体通常应该放到最后渲染。<strong>该算法可以看成是针对流体的延迟渲染，流体的表面法线信息并不能直接获得，需要从深度贴图中重建法线，而在这之前深度贴图也要经过一些特殊的处理。</strong>基于屏幕空间的流体渲染步骤中，如何对深度贴图做处理使之能真实反映流体的特性是算法的核心，剩下的光照部分直接采用Blin-Phong光照模型，并综合考虑水体的折射和反射，上面提到的厚度贴图用于水体的折射计算，因为越厚的流体其透光率越低。</p><h2 id="二、水体的光照计算"><a href="#二、水体的光照计算" class="headerlink" title="二、水体的光照计算"></a>二、水体的光照计算</h2><p>&emsp;&emsp;<strong>首先我们先实现一个不对深度贴图和厚度贴图做处理的Naive版的流体渲染算法，这有利于我们弄清整个算法的思路，而且使得实现的过程更加清晰、有条理、便于调试。</strong>去掉对深度贴图和厚度贴图的处理部分（噪声部分我们不考虑），剩下的算法流程就分为：渲染不包含流体的场景纹理、渲染粒子深度信息、渲染粒子厚度信息、光照着色计算。这里我们采用OpenGL的render to target，将场景、深度贴图、厚度贴图都渲染到纹理当中，供最后的光照着色计算使用。</p><p>&emsp;&emsp;一开始我们为了获取流体的深度信息和厚度信息，需要流体以球形粒子的形态进行绘制，这里我们采用OpenGL的点精灵Point Sprite做粒子绘制。在OpenGL中，点精灵Point Sprite就是一个内建的始终朝向摄像机视角的正方形，我们可以指定它的大小，但是它的大小是定义在屏幕空间的。因此，在利用点精灵绘制流体粒子时，一方面我们要根据世界空间的流体粒子大小设置点精灵的大小，另一方面要以将四边形变成圆形。</p><p>&emsp;&emsp;首先根据世界空间的流体粒子大小设置点精灵的大小，上面说了，点精灵的大小是定义在屏幕空间的，而通常我们设置的流体粒子大小是世界空间的。为了正确设置点精灵的大小，使之符合透视原理，需要计算世界空间的长度投影到屏幕空间的长度，这个比较基础，根据三角形相似的原理即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calculate particle size scale factor.</span></span><br><span class="line"><span class="keyword">float</span> aspect = camera-&gt;getAspect();</span><br><span class="line"><span class="keyword">float</span> fovy = camera-&gt;getFovy();</span><br><span class="line"><span class="keyword">float</span> pointScale = <span class="number">1.0f</span> * m_screenWidth / aspect * (<span class="number">1.0f</span> / tanf(glm::radians(fovy) * <span class="number">0.5f</span>));</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">shader-&gt;setFloat(<span class="string">"pointScale"</span>, pointScale);</span><br><span class="line">shader-&gt;setFloat(<span class="string">"pointSize"</span>, m_particleRadius);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="meta">#version 430 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec4 position;</span><br><span class="line"></span><br><span class="line">uniform mat4 modelMatrix;</span><br><span class="line">uniform mat4 viewMatrix;</span><br><span class="line">uniform mat4 projectMatrix;</span><br><span class="line">uniform <span class="keyword">float</span> pointScale;</span><br><span class="line">uniform <span class="keyword">float</span> pointSize;</span><br><span class="line"></span><br><span class="line">out vec3 eyeSpacePos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">eyeSpacePos = (viewMatrix * modelMatrix * vec4(position.xyz, <span class="number">1.0f</span>)).xyz;</span><br><span class="line">gl_PointSize = -pointScale * pointSize / eyeSpacePos.z;</span><br><span class="line">gl_Position = projectMatrix * viewMatrix * modelMatrix * vec4(position.xyz, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后就是让正方形的点精灵变成一个圆形。在片元着色器中，点精灵提供了一个gl_PointCoord变量，这是一个内建的专用于点精灵的纹理坐标，已经经过光栅化插值之后的点精灵纹理坐标。我们根据这个坐标来获取每一个点精灵的像素所在的相对位置，gl_PointCoord纹理坐标以左上角为原点，我们需要将其变换到点精灵中心。接着获取每个像素的法线信息，并计算半径长度，半径超过1.0的像素我们给它discard掉。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 430 core</span></span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> pointSize;</span><br><span class="line">uniform mat4 projectMatrix;</span><br><span class="line"></span><br><span class="line">in vec3 eyeSpacePos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">vec3 normal;</span><br><span class="line">normal.xy = gl_PointCoord.xy * vec2(<span class="number">2.0</span>, <span class="number">-2.0</span>) + vec2(<span class="number">-1.0</span>,<span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">float</span> mag = dot(normal.xy, normal.xy);</span><br><span class="line"><span class="keyword">if</span>(mag &gt; <span class="number">1.0</span>) discard;</span><br><span class="line">normal.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - mag);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;点精灵给我们提供一个非常方便的球心粒子绘制方法，这种方法绘制的球体是基于解析解的，精度非常高，球体非常光滑，而如果采用球体网格则需要绘制很多个网格，球体精度受限于网格的精度，速度也慢。现在知道如何根据点精灵绘制，接下来我们需要从流体粒子中获取深度贴图和厚度贴图。</p><h3 id="1、流体深度贴图"><a href="#1、流体深度贴图" class="headerlink" title="1、流体深度贴图"></a>1、流体深度贴图</h3><p>&emsp;&emsp;绘制流体深度贴图需要开启深度测试，并创建一个帧缓冲，深度的信息绘制到给定帧缓冲的深度缓冲当中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> LiquidDrawable::drawLiquidDepth(Camera3D::ptr camera, Light::ptr sunLight,</span><br><span class="line">Camera3D::ptr lightCamera, Shader::ptr shader)</span><br><span class="line">&#123;</span><br><span class="line">m_framebuffer-&gt;bind();</span><br><span class="line"></span><br><span class="line"><span class="comment">// calculate particle size scale factor.</span></span><br><span class="line"><span class="keyword">float</span> aspect = camera-&gt;getAspect();</span><br><span class="line"><span class="keyword">float</span> fovy = camera-&gt;getFovy();</span><br><span class="line"><span class="keyword">float</span> pointScale = <span class="number">1.0f</span> * m_screenWidth / aspect * (<span class="number">1.0f</span> / tanf(glm::radians(fovy) * <span class="number">0.5f</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// render state.</span></span><br><span class="line">glEnable(GL_DEPTH_TEST);</span><br><span class="line">glDisable(GL_BLEND);</span><br><span class="line">glClear(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">glEnable(GL_PROGRAM_POINT_SIZE);</span><br><span class="line">glEnable(GL_VERTEX_PROGRAM_POINT_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// shader.</span></span><br><span class="line">shader = m_shaderMgr-&gt;getShader(<span class="string">"liquidDepth"</span>);</span><br><span class="line">shader-&gt;bind();</span><br><span class="line">shader-&gt;setFloat(<span class="string">"farPlane"</span>, camera-&gt;getFar());</span><br><span class="line">shader-&gt;setFloat(<span class="string">"nearPlane"</span>, camera-&gt;getNear());</span><br><span class="line">shader-&gt;setFloat(<span class="string">"pointScale"</span>, pointScale);</span><br><span class="line">shader-&gt;setFloat(<span class="string">"pointSize"</span>, m_particleRadius);</span><br><span class="line">shader-&gt;setFloat(<span class="string">"densityLowerBound"</span>, m_densityLowerBound);</span><br><span class="line">shader-&gt;setMat4(<span class="string">"modelMatrix"</span>, m_transformation.getWorldMatrix());</span><br><span class="line">shader-&gt;setMat4(<span class="string">"viewMatrix"</span>, camera-&gt;getViewMatrix());</span><br><span class="line">shader-&gt;setMat4(<span class="string">"projectMatrix"</span>, camera-&gt;getProjectMatrix());</span><br><span class="line"></span><br><span class="line"><span class="comment">// draw</span></span><br><span class="line">glBindVertexArray(m_particleVAO);</span><br><span class="line">glDrawArrays(GL_POINTS, <span class="number">0</span>, m_numParticles);</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// restore.</span></span><br><span class="line">m_shaderMgr-&gt;unBindShader();</span><br><span class="line">glDisable(GL_PROGRAM_POINT_SIZE);</span><br><span class="line">m_framebuffer-&gt;unBind();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在片元着色器，我们需要计算像素的深度信息，为了还原出粒子的深度信息，我们首先将粒子在摄像机空间的位置传到片元着色器中，这个其实就是点精灵在摄像机空间的中心点。然后计算每个像素的法线，每个像素在摄像机空间的点就等于$eyeSpacePos + normal * pointSize$，其中$pointSize$就是流体粒子的半径大小。得到每个像素在摄像机空间的点，我们再将其乘上投影矩阵，并做透视除法，得到标准化设备空间$[-1,+1]$的深度值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">============vertex   shader================</span><br><span class="line">#version <span class="number">430</span> core</span><br><span class="line">layout (location = <span class="number">0</span>) in vec4 position;</span><br><span class="line"></span><br><span class="line">uniform mat4 modelMatrix;</span><br><span class="line">uniform mat4 viewMatrix;</span><br><span class="line">uniform mat4 projectMatrix;</span><br><span class="line">uniform <span class="keyword">float</span> pointScale;</span><br><span class="line">uniform <span class="keyword">float</span> pointSize;</span><br><span class="line">uniform <span class="keyword">float</span> densityLowerBound;</span><br><span class="line"></span><br><span class="line">out vec3 eyeSpacePos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">eyeSpacePos = (viewMatrix * modelMatrix * vec4(position.xyz, <span class="number">1.0f</span>)).xyz;</span><br><span class="line">gl_PointSize = -pointScale * pointSize / eyeSpacePos.z;</span><br><span class="line"><span class="comment">// to prevent single or a few particles.</span></span><br><span class="line"><span class="keyword">if</span>(position.w &lt; densityLowerBound) </span><br><span class="line">gl_PointSize = <span class="number">0.0f</span>;</span><br><span class="line">gl_Position = projectMatrix * viewMatrix * modelMatrix * vec4(position.xyz, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">============fragment shader================</span><br><span class="line">#version <span class="number">430</span> core</span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> pointSize;</span><br><span class="line">uniform mat4 projectMatrix;</span><br><span class="line"></span><br><span class="line">in vec3 eyeSpacePos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">vec3 normal;</span><br><span class="line">normal.xy = gl_PointCoord.xy * vec2(<span class="number">2.0</span>, <span class="number">-2.0</span>) + vec2(<span class="number">-1.0</span>,<span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">float</span> mag = dot(normal.xy, normal.xy);</span><br><span class="line"><span class="keyword">if</span>(mag &gt; <span class="number">1.0</span>) discard;</span><br><span class="line">normal.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - mag);</span><br><span class="line"></span><br><span class="line">vec4 pixelEyePos = vec4(eyeSpacePos + normal * pointSize, <span class="number">1.0f</span>);</span><br><span class="line">vec4 pixelClipPos = projectMatrix * pixelEyePos;</span><br><span class="line"><span class="keyword">float</span> ndcZ = pixelClipPos.z / pixelClipPos.w;</span><br><span class="line">gl_FragDepth = ndcZ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;经过上面的一个pass，我们得到了流体的深度信息。下面是一张近看的流体粒子深度贴图，为什么要近看？因为投影矩阵对深度信息做了一个非线性变换，这个非线性变换使得深度值密度在靠近1.0这一端，稍微远一点，就全白看不见了。（<strong>所以如果渲染出来一张全白的深度贴图，不要着急，拉近看看</strong>）</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.17/blog/FluidRendering/3.png" width="80%"></div></p><center> 图3 流体深度贴图 </center><h3 id="2、流体厚度贴图"><a href="#2、流体厚度贴图" class="headerlink" title="2、流体厚度贴图"></a>2、流体厚度贴图</h3><p>&emsp;&emsp;然后我们需要获取流体的厚度贴图，获取厚度贴图不是必须的，这是因为厚度贴图是为了流体折射计算服务。有些流体并不透光（如牛奶），所以也不存在折射。与渲染流体深度贴图一样，我们以将流体粒子以球形的点精灵形态进行绘制。给定一个方向，流体厚度衡量在这个方向上有多少流体粒子，越多越厚。因此，为了计算流体的厚度，我们采用了OpenGL的blending技巧，也就是透明融合，每个流体粒子计算各自贡献的厚度值，然后将其输出到颜色缓冲中，借助OpenGL的透明融合，将厚度值累积起来，这样就能得到从摄像机方向看去的流体厚度信息。此外，由于我们是采用球形点精灵绘制一个流体粒子，一个流体粒子，其厚度贡献值从中心到边缘应该逐渐减少，为此我们采用计算得到的normal的z分量作为厚度值，并乘上一个缩放系数。具体如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 430 core</span></span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> pointSize;</span><br><span class="line">uniform mat4 projectMatrix;</span><br><span class="line"></span><br><span class="line">layout(location = <span class="number">0</span>) out vec4 fragColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">vec3 normal;</span><br><span class="line">normal.xy = gl_PointCoord.xy * vec2(<span class="number">2.0</span>, <span class="number">-2.0</span>) + vec2(<span class="number">-1.0</span>,<span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">float</span> mag = dot(normal.xy, normal.xy);</span><br><span class="line"><span class="keyword">if</span>(mag &gt; <span class="number">1.0</span>) discard;</span><br><span class="line">normal.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - mag);</span><br><span class="line">fragColor = vec4(normal.z*<span class="number">0.005</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在CPU端，我们关闭深度测试，开启透明融合，并设置融合函数为additive blending，即加法融合。所谓加法融合，就是原像素值和目标像素值直接相加，不乘上任何的缩放系数。在OpenGL的加法融合就是设置glBlendFunc的参数均为GL_ONE、GL_ONE。这样不同流体粒子之间的厚度值直接叠加，达到我们所需的效果。同时为了凸显厚度，我们设当地设大一点粒子的大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> LiquidDrawable::drawLiquidThick(Camera3D::ptr camera, Light::ptr sunLight,</span><br><span class="line">Camera3D::ptr lightCamera, Shader::ptr shader)</span><br><span class="line">&#123;</span><br><span class="line">m_framebuffer-&gt;bind();</span><br><span class="line"></span><br><span class="line"><span class="comment">// calculate particle size scale factor.</span></span><br><span class="line"><span class="keyword">float</span> aspect = camera-&gt;getAspect();</span><br><span class="line"><span class="keyword">float</span> fovy = camera-&gt;getFovy();</span><br><span class="line"><span class="keyword">float</span> pointScale = m_screenWidth / aspect * (<span class="number">1.0f</span> / tanf(glm::radians(fovy) * <span class="number">0.5f</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// render state.</span></span><br><span class="line">glEnable(GL_BLEND);</span><br><span class="line">glBlendFunc(GL_ONE, GL_ONE);</span><br><span class="line">glDepthMask(GL_FALSE);</span><br><span class="line">glEnable(GL_DEPTH_TEST);</span><br><span class="line">glDisable(GL_DEPTH_TEST);</span><br><span class="line">glEnable(GL_PROGRAM_POINT_SIZE);</span><br><span class="line">glEnable(GL_VERTEX_PROGRAM_POINT_SIZE);</span><br><span class="line">glClearColor(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// shader.</span></span><br><span class="line">shader = m_shaderMgr-&gt;getShader(<span class="string">"liquidThick"</span>);</span><br><span class="line">shader-&gt;bind();</span><br><span class="line">shader-&gt;setFloat(<span class="string">"pointScale"</span>, pointScale);</span><br><span class="line">shader-&gt;setFloat(<span class="string">"pointSize"</span>, <span class="number">4.0f</span> * m_particleRadius);</span><br><span class="line">shader-&gt;setMat4(<span class="string">"modelMatrix"</span>, m_transformation.getWorldMatrix());</span><br><span class="line">shader-&gt;setMat4(<span class="string">"viewMatrix"</span>, camera-&gt;getViewMatrix());</span><br><span class="line">shader-&gt;setMat4(<span class="string">"projectMatrix"</span>, camera-&gt;getProjectMatrix());</span><br><span class="line"></span><br><span class="line"><span class="comment">// draw</span></span><br><span class="line">glBindVertexArray(m_particleVAO);</span><br><span class="line">glDrawArrays(GL_POINTS, <span class="number">0</span>, m_numParticles);</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// restore.</span></span><br><span class="line">glDepthMask(GL_TRUE);</span><br><span class="line">glDisable(GL_BLEND);</span><br><span class="line">glDisable(GL_PROGRAM_POINT_SIZE);</span><br><span class="line">m_shaderMgr-&gt;unBindShader();</span><br><span class="line">m_framebuffer-&gt;unBind();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.17/blog/FluidRendering/4.png" width="80%"></div></p><center> 图4 流体厚度贴图 </center><p>&emsp;&emsp;图4就是渲染出来的流体厚度贴图，越红的地方越厚。</p><h3 id="3、水体折射、Blin-Phong光照"><a href="#3、水体折射、Blin-Phong光照" class="headerlink" title="3、水体折射、Blin-Phong光照"></a>3、水体折射、Blin-Phong光照</h3><p>&emsp;&emsp;在前面的步骤我们获取了两张纹理贴图：流体深度纹理、流体厚度纹理。然后我们需要根据这两张纹理计算水体的光照效果。前面已经提到过，这是一种类似于延迟渲染的技术，光照计算都是在屏幕空间的四边形上进行。我们首先要根据流体的深度纹理信息重建流体表面的法线向量。在屏幕空间中，我们已知当前像素的纹理坐标，和对应的流体深度信息，那么如何根据这些信息重建法线向量呢？这就涉及到了如何从设备标准空间ndc顶点转换到摄像机空间$^{[1]}$。</p><p>&emsp;&emsp;设摄像机空间的顶点坐标为$(vx,vy,vz,vw)$，其中$vw=1.0$，ndc空间的顶点坐标为$(nx,ny,nz)$，其中$x、y、z\in[-1,+1]$。我们知道从摄像机空间变换到ndc空间，需要经过投影变换、透视除法这两个步骤：</p><script type="math/tex; mode=display">clip=projectMatrix \cdot (vx,vy,vz,1.0)\\(nx,ny,nz) = clip.xyz/clip.w \tag {1}</script><p>&emsp;&emsp;其中的clip就是裁剪空间的顶点坐标。所以我们的问题就是，已知ndc空间的$(nx,ny,nz)$、摄像机空间的$vw=1.0$以及投影变换矩阵，如何计算得到摄像机空间的$(vx,vy,vz)$顶点坐标。根据公式$(1)$，我们有：</p><script type="math/tex; mode=display">(vx,vy,vz,1.0)=(projectMatrix)^{-1}\cdot clip \tag {2}</script><p>&emsp;&emsp;而根据ndc顶点坐标$(nx,ny,nz)$与裁剪空间顶点坐标$clip$的关系，我们又有：</p><script type="math/tex; mode=display">clip=(clip.xyz,clip.w)=((nx,ny,nz)\cdot clip.w, clip.w)=clip.w \cdot (nx,ny,nz,1.0) \tag {3}</script><p>&emsp;&emsp;联立公式$(2)$与公式$(3)$，我们有：</p><script type="math/tex; mode=display">(vx,vy,vz,1.0)=clip.w \cdot (projectMatrix)^{-1}\cdot (nx,ny,nz,1.0) \tag {4}</script><p>&emsp;&emsp;公式$(4)$直接表明了摄像机空间顶点坐标与ndc空间坐标之间的关系，其中只有$clip.w$是未知，这是一个关键点。我们注意到$vw=1.0$，也就是在摄像机空间，顶点的分量为1.0。这一点可以利用起来：</p><script type="math/tex; mode=display">clip.w\cdot[(projectMatrix)^{-1}\cdot (nx,ny,nz,1.0)].w = 1.0 \\\to\\clip.w=\frac{1.0}{[(projectMatrix)^{-1}\cdot (nx,ny,nz,1.0)].w} \tag {5}</script><p>&emsp;&emsp;公式$(5)$意思就是$clip.w$等于ndc空间的坐标$(nx,ny,nz,1.0)$右乘逆投影矩阵所得向量的$w$分量的倒数。将其代入公式$(4)$中，我们可得：</p><script type="math/tex; mode=display">(vx,vy,vz,1.0)=\frac{1.0}{[(projectMatrix)^{-1}\cdot (nx,ny,nz,1.0)].w} \cdot (projectMatrix)^{-1}\cdot (nx,ny,nz,1.0)</script><p>&emsp;&emsp;因此，从ndc空间的坐标到摄像机空间的坐标，我们首先计算$(projectMatrix)^{-1}\cdot (nx,ny,nz,1.0)$，然后再将其$xyz$分量除以$w$分量即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">uvToEye</span><span class="params">(vec2 coord, <span class="keyword">float</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vec2 pos = coord * <span class="number">2.0f</span> - <span class="number">1.0f</span>;</span><br><span class="line">vec4 clipPos = vec4(pos, z, <span class="number">1.0f</span>);</span><br><span class="line">vec4 viewPos = invProjectMatrix * clipPos;</span><br><span class="line"><span class="keyword">return</span> viewPos.xyz / viewPos.w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;知道了摄像机空间的顶点坐标，紧接着我们需要根据顶点坐标重建顶点法线。法线向量可以根据沿着x方向和沿着y方向的偏导数做叉乘得到，这里的x方向和y方向均为屏幕空间中的纹理坐标方向。求偏导数可以根据有限差分法：</p><script type="math/tex; mode=display">\frac{\partial f}{\partial s}\approx\frac{f(s+\Delta s)-f(s)}{\Delta s} \tag {6}</script><p>&emsp;&emsp;这里我们采用了单向差分法（前向差分法、后向差分法），没有采用中心差分法。为了避免计算出错误的法线向量，我们综合考虑前向差分法和后向差分法，取较小的那个差分值（差分值较大的很可能是在边界处与背景或距离比较远的流体深度值做了一个差分，这个时候得到的法线是错误的，因为深度值不连续）。我们对深度纹理图的周围四个像素分别做x方向和y方向的差分，$\Delta s=1$。最后根据得到的偏导向量做叉乘得到法线。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -----------------reconstruct normal----------------------------</span></span><br><span class="line">vec2 depthTexelSize = <span class="number">1.0</span> / textureSize(depthTex, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// calculate eye space position.</span></span><br><span class="line">vec3 eyeSpacePos = uvToEye(Texcoord, depth);</span><br><span class="line"><span class="comment">// finite difference.</span></span><br><span class="line">vec3 ddxLeft   = eyeSpacePos - uvToEye(Texcoord - vec2(depthTexelSize.x,<span class="number">0.0f</span>),</span><br><span class="line">texture(depthTex, Texcoord - vec2(depthTexelSize.x,<span class="number">0.0f</span>)).r);</span><br><span class="line">vec3 ddxRight  = uvToEye(Texcoord + vec2(depthTexelSize.x,<span class="number">0.0f</span>),</span><br><span class="line">texture(depthTex, Texcoord + vec2(depthTexelSize.x,<span class="number">0.0f</span>)).r) - eyeSpacePos;</span><br><span class="line">vec3 ddyTop    = uvToEye(Texcoord + vec2(<span class="number">0.0f</span>,depthTexelSize.y),</span><br><span class="line">texture(depthTex, Texcoord + vec2(<span class="number">0.0f</span>,depthTexelSize.y)).r) - eyeSpacePos;</span><br><span class="line">vec3 ddyBottom = eyeSpacePos - uvToEye(Texcoord - vec2(<span class="number">0.0f</span>,depthTexelSize.y),</span><br><span class="line">texture(depthTex, Texcoord - vec2(<span class="number">0.0f</span>,depthTexelSize.y)).r);</span><br><span class="line">vec3 dx = ddxLeft;</span><br><span class="line">vec3 dy = ddyTop;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(ddxRight.z) &lt; <span class="built_in">abs</span>(ddxLeft.z))</span><br><span class="line">dx = ddxRight;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(ddyBottom.z) &lt; <span class="built_in">abs</span>(ddyTop.z))</span><br><span class="line">dy = ddyBottom;</span><br><span class="line">vec3 normal = normalize(cross(dx, dy));</span><br><span class="line">vec3 worldPos = (invViewMatrix * vec4(eyeSpacePos, <span class="number">1.0f</span>)).xyz;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;下图5显示了重建得到的法线情况，<strong>需要特别注意的是，这里我们重建得到的法线是在摄像机空间而非世界空间，这是因为我们还原的顶点也是摄像机空间的，因此计算光照时需要将光线向量变换到摄像机空间。</strong></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.17/blog/FluidRendering/5.png" width="80%"></div></p><center> 图5 重建的法线 </center><p>&emsp;&emsp;有了法线向量，接下来我们就计算水体折射、Blin-Phong光照。我这里只考虑水体折射，反射不考虑，因为一般清澈的水很少有反射现象。Beer-Lambert定律揭示了液体的光吸收现象。根据Beer-Lambert定律，液体的透光率随着液体的厚度增加呈指数衰减：</p><script type="math/tex; mode=display">I(d)=I_0\cdot e^{-kd} \tag {7}</script><p>&emsp;&emsp;公式$(7)$中，$d$是液体的厚度值，$I_0$是光照强度rgb向量，$k$是液体的光能衰减因子向量，通常等于$1.0-liquidColor$。液体的透光率计算如下所示，厚度值从之前渲染得到的贴图中直接采样得到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> thickness = max(texture(thicknessTex, Texcoord).r, <span class="number">0.3f</span>);</span><br><span class="line">vec3 transmission = <span class="built_in">exp</span>(-(vec3(<span class="number">1.0f</span>) - liquidColor.xyz) * thickness);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后，我们还需要从背景纹理图中采样，因为我们要实现折射的效果。为了实现折射的效果，我们需要对采样的纹理坐标做一个偏移，使之产生折射的效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> refractScale = <span class="number">1.33</span> * <span class="number">0.025</span>;<span class="comment">// refracted index.</span></span><br><span class="line">refractScale *= smoothstep(<span class="number">0.1</span>, <span class="number">0.4</span>, worldPos.y);</span><br><span class="line">vec2 refractCoord = Texcoord + normal.xy * refractScale;</span><br><span class="line">vec3 refractedColor = texture(backgroundTex, refractCoord).xyz * transmission;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后就是关于Blin-Phong光照部分，比较简单，不再赘述。唯一需要注意的是我们获取的法线是在摄像机空间的，需要将光的方向也变换到摄像机空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -----------------Phong lighting----------------------------</span></span><br><span class="line">vec3 viewDir = -normalize(eyeSpacePos);</span><br><span class="line">vec3 lightDir = normalize((viewMatrix * vec4(dirLight.direction, <span class="number">0.0f</span>)).xyz);</span><br><span class="line">vec3 halfVec = normalize(viewDir + lightDir);</span><br><span class="line">vec3 specular = vec3(dirLight.specular * <span class="built_in">pow</span>(max(dot(halfVec, normal), <span class="number">0.0f</span>), <span class="number">400.0f</span>));</span><br><span class="line">vec3 diffuse = liquidColor.xyz * max(dot(lightDir, normal), <span class="number">0.0f</span>) * dirLight.diffuse * liquidColor.w;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------Merge all effect----------------------------</span></span><br><span class="line">fragColor.rgb = diffuse + specular + refractedColor;</span><br><span class="line">fragColor.a = <span class="number">1.0f</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;实现出来的效果如下图6所示。可以看到，渲染的效果很差，液体看起来像是由很多粒果冻组成，流体的粒子感非常明显，这并不是我们想要的。<strong>产生果冻壮流体的根本原因是因为我们的法线向量并不平滑，仔细观察图5，我们重建后的法线还是原来的球面上的法线，这造成光照效果的失真。</strong></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.17/blog/FluidRendering/6.png" width="80%"></div></p><center> 图6 实现的果冻壮流体 </center><p>&emsp;&emsp;因此，为了进一步提升渲染效果，我们要想办法使得流体表面得法线平滑。而法线来源于深度贴图，因为我们追溯到源头就是使得深度贴图尽可能地平滑。接下来我们将讨论在屏幕空间对深度贴图做的一些平滑后处理方案。</p><h2 id="三、流体深度贴图的平滑处理"><a href="#三、流体深度贴图的平滑处理" class="headerlink" title="三、流体深度贴图的平滑处理"></a>三、流体深度贴图的平滑处理</h2><p>&emsp;&emsp;我们现在需要对深度贴图做平滑处理，这其实属于图像处理的范畴。</p><h3 id="1、采用高斯滤波平滑深度贴图"><a href="#1、采用高斯滤波平滑深度贴图" class="headerlink" title="1、采用高斯滤波平滑深度贴图"></a>1、采用高斯滤波平滑深度贴图</h3><p>&emsp;&emsp;首先是高斯模糊的平滑方案，我们把深度纹理当场一张图片，采用高斯权重做一个滤波操作。为了性能，同样我们将二维的高斯模糊分成水平方向和垂直方向两个pass。在之前实现辉光效果时已经介绍过，不再赘述。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> DepthGaussianBlurFilter::blurTexture(<span class="keyword">unsigned</span> <span class="keyword">int</span> targetTexIndex, <span class="keyword">const</span> glm::mat4 &amp;projectMat)</span><br><span class="line">&#123;</span><br><span class="line">m_framebuffer-&gt;bind();</span><br><span class="line">glDepthMask(GL_TRUE);</span><br><span class="line">glEnable(GL_DEPTH_TEST);</span><br><span class="line">glClear(GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">Shader::ptr blurShader = ShaderMgr::getSingleton()-&gt;getShader(m_blurShaderIndex);</span><br><span class="line">blurShader-&gt;bind();</span><br><span class="line">blurShader-&gt;setInt(<span class="string">"image"</span>, <span class="number">0</span>);</span><br><span class="line">TextureMgr::getSingleton()-&gt;bindTexture(targetTexIndex, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">5</span>; ++index) &#123;</span><br><span class="line"><span class="comment">// horizontal blur.</span></span><br><span class="line">blurShader-&gt;setInt(<span class="string">"horizontal"</span>, <span class="number">1</span>);</span><br><span class="line">MeshMgr::getSingleton()-&gt;drawMesh(m_screenQuadIndex, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy to target texture.</span></span><br><span class="line">glCopyTexSubImage2D(GL_TEXTURE_2D, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, m_width, m_height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// vertical blur.</span></span><br><span class="line">blurShader-&gt;setInt(<span class="string">"horizontal"</span>, <span class="number">0</span>);</span><br><span class="line">MeshMgr::getSingleton()-&gt;drawMesh(m_screenQuadIndex, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy to target texture.</span></span><br><span class="line">glCopyTexSubImage2D(GL_TEXTURE_2D, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, m_width, m_height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TextureMgr::getSingleton()-&gt;unBindTexture(targetTexIndex);</span><br><span class="line">blurShader-&gt;unBind();</span><br><span class="line">m_framebuffer-&gt;unBind();</span><br><span class="line"><span class="keyword">return</span> targetTexIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">==============Fragment Shader==================</span><br><span class="line">#version <span class="number">330</span> core</span><br><span class="line"></span><br><span class="line">in vec2 Texcoord;</span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">int</span> horizontal;</span><br><span class="line">uniform sampler2D image;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> weight[<span class="number">8</span>] = <span class="keyword">float</span>[] (<span class="number">0.197448</span>, <span class="number">0.174697</span>, <span class="number">0.120999</span>, <span class="number">0.065602</span>, <span class="number">0.02784</span>, <span class="number">0.009246</span>, <span class="number">0.002403</span>, <span class="number">0.000489</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// gets size of single texel.</span></span><br><span class="line">    vec2 tex_offset = <span class="number">1.0</span> / textureSize(image, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">float</span> result = texture(image, Texcoord).r * weight[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">result += texture(image, Texcoord + vec2(tex_offset.x * <span class="number">1</span> * horizontal, tex_offset.y * <span class="number">1</span> * (<span class="number">1</span>-horizontal))).r * weight[<span class="number">1</span>];</span><br><span class="line">    result += texture(image, Texcoord - vec2(tex_offset.x * <span class="number">1</span> * horizontal, tex_offset.y * <span class="number">1</span> * (<span class="number">1</span>-horizontal))).r * weight[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">result += texture(image, Texcoord + vec2(tex_offset.x * <span class="number">2</span> * horizontal, tex_offset.y * <span class="number">2</span> * (<span class="number">1</span>-horizontal))).r * weight[<span class="number">2</span>];</span><br><span class="line">    result += texture(image, Texcoord - vec2(tex_offset.x * <span class="number">2</span> * horizontal, tex_offset.y * <span class="number">2</span> * (<span class="number">1</span>-horizontal))).r * weight[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">result += texture(image, Texcoord + vec2(tex_offset.x * <span class="number">3</span> * horizontal, tex_offset.y * <span class="number">3</span> * (<span class="number">1</span>-horizontal))).r * weight[<span class="number">3</span>];</span><br><span class="line">    result += texture(image, Texcoord - vec2(tex_offset.x * <span class="number">3</span> * horizontal, tex_offset.y * <span class="number">3</span> * (<span class="number">1</span>-horizontal))).r * weight[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">result += texture(image, Texcoord + vec2(tex_offset.x * <span class="number">4</span> * horizontal, tex_offset.y * <span class="number">4</span> * (<span class="number">1</span>-horizontal))).r * weight[<span class="number">4</span>];</span><br><span class="line">    result += texture(image, Texcoord - vec2(tex_offset.x * <span class="number">4</span> * horizontal, tex_offset.y * <span class="number">4</span> * (<span class="number">1</span>-horizontal))).r * weight[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">result += texture(image, Texcoord + vec2(tex_offset.x * <span class="number">5</span> * horizontal, tex_offset.y * <span class="number">5</span> * (<span class="number">1</span>-horizontal))).r * weight[<span class="number">5</span>];</span><br><span class="line">    result += texture(image, Texcoord - vec2(tex_offset.x * <span class="number">5</span> * horizontal, tex_offset.y * <span class="number">5</span> * (<span class="number">1</span>-horizontal))).r * weight[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">result += texture(image, Texcoord + vec2(tex_offset.x * <span class="number">6</span> * horizontal, tex_offset.y * <span class="number">6</span> * (<span class="number">1</span>-horizontal))).r * weight[<span class="number">6</span>];</span><br><span class="line">    result += texture(image, Texcoord - vec2(tex_offset.x * <span class="number">6</span> * horizontal, tex_offset.y * <span class="number">6</span> * (<span class="number">1</span>-horizontal))).r * weight[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">result += texture(image, Texcoord + vec2(tex_offset.x * <span class="number">7</span> * horizontal, tex_offset.y * <span class="number">7</span> * (<span class="number">1</span>-horizontal))).r * weight[<span class="number">7</span>];</span><br><span class="line">    result += texture(image, Texcoord - vec2(tex_offset.x * <span class="number">7</span> * horizontal, tex_offset.y * <span class="number">7</span> * (<span class="number">1</span>-horizontal))).r * weight[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">gl_FragDepth = result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;经过高斯模糊之后的，重建得到的法线向量平滑了一下如下所示。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.17/blog/FluidRendering/7.png" width="80%"></div></p><center> 图7 高斯模糊平滑得到的法线 </center><p>&emsp;&emsp;然后用高斯模糊平滑得到法线向量做光照着色，得到下面的效果。渲染得到的效果看起来明显比图6的果冻壮好很多了。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.17/blog/FluidRendering/8.png" width="80%"></div></p><center> 图8 高斯模糊-光照着色 </center><p>&emsp;&emsp;然后高斯模糊的平滑方法存在一个问题，高斯模糊没有考虑深度值，它仅仅考虑当前像素到中心像素的距离。这就导致了高斯模糊会明显地模糊掉边界，使得边界与背景或较远处的流体看起来融合在一起了。如下图9所示，上面的这张图红框部分，流体的边界于后面的流体融合在了一起，看不出有一个边界在那里。下面这张图可以看到，流体是分开的，但是从上面的这个视角看起又是连在一起的。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.17/blog/FluidRendering/11.jpg" width="80%"></div></p><center> 图9 高斯滤波模糊掉了边界 </center><h3 id="3、采用双边滤波平滑深度贴图"><a href="#3、采用双边滤波平滑深度贴图" class="headerlink" title="3、采用双边滤波平滑深度贴图"></a>3、采用双边滤波平滑深度贴图</h3><p>&emsp;&emsp;既然高斯模糊没有良好地保留边界，我们就选取一个能够保边去噪的滤波器，高斯双边滤波算法就是这样的一个滤波器。高斯模糊仅仅考虑了像素的空间分布，权重从中间向周边降低。而双边滤波则进一步考虑了图像的像素值，从而保证边缘部分不会被过滤掉。根据维基百科$^{[3]}$，一个双边滤波器定义为：</p><script type="math/tex; mode=display">I^{filtered}(x)=\frac{1}{W_p}\Sigma_{x_i\in \Omega}I(x_i)f_r(||I(x_i)-I(x)||)g_s(||x_i-x||) \tag {8}</script><p>&emsp;&emsp;其中，$I_{filtered}(x)$是过滤后的图像，$x$是被过滤的像素坐标，$\Omega$是像素$x$的滤波核领域，$I(x)$是初始未被过滤的图像。然后$f_r$是域值权重函数，$g_r$是空间权重函数。而$W_p$是归一化因子，其计算方式如下：</p><script type="math/tex; mode=display">W_p=\Sigma_{x_i\in \Omega}f_r(||I(x_i)-I(x)||)g_s(||x_i-x||) \tag {9}</script><p>&emsp;&emsp;可以看到$f_r$函数输入的是两个像素之间的差，而$g_s$输入的是两个像素坐标之间的差。考虑一个像素，其坐标为$(i,j)$，而其邻域像素的坐标为$(k,l)$，则计算与邻域像素$(k,l)$的滤波核函数为：</p><script type="math/tex; mode=display">w(i,j,k,l)=exp(-\frac{(i-k)^2+(j-l)^2}{2\sigma_d^2}-\frac{||I(i,j)-I(k,l)||^2}{2\sigma_r^2}) \tag {10}</script><p>&emsp;&emsp;公式$(10)$给出的核函数包含了$f_r$和$g_s$，其中左边部分就是$g_s$，而右边部分则为$f_r$。在片元着色器中，我实现的双边滤波函数如下所示。这是一个暴力的两重循环，因为图像的邻域是二维的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line">in vec2 Texcoord;</span><br><span class="line"></span><br><span class="line">uniform sampler2D image;</span><br><span class="line">uniform <span class="keyword">float</span> filterRadius;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> blurScale = <span class="number">0.05f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> blurDepthFalloff = <span class="number">500.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// gets size of single texel.</span></span><br><span class="line">    vec2 tex_offset = <span class="number">1.0</span> / textureSize(image, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">float</span> sum = <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">float</span> wsum = <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">float</span> value = texture(image, Texcoord).r;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">float</span> y = -filterRadius;y &lt;= filterRadius;y += <span class="number">1.0f</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">float</span> x = -filterRadius;x &lt;= filterRadius;x += <span class="number">1.0f</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">float</span> sample = texture(image, Texcoord + vec2(x, y) * tex_offset).r;</span><br><span class="line"><span class="comment">// spatial domain.</span></span><br><span class="line"><span class="keyword">float</span> r = length(vec2(x, y)) * blurScale;</span><br><span class="line"><span class="keyword">float</span> w = <span class="built_in">exp</span>(-r * r);</span><br><span class="line"><span class="comment">// range domain.</span></span><br><span class="line"><span class="keyword">float</span> r2 = (sample - value) * blurDepthFalloff;</span><br><span class="line"><span class="keyword">float</span> g = <span class="built_in">exp</span>(-r2 * r2);</span><br><span class="line">sum += sample * w * g;</span><br><span class="line">wsum += w * g;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(wsum &gt;= <span class="number">0.0f</span>)</span><br><span class="line">sum /= wsum;</span><br><span class="line">gl_FragDepth = sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后根据双边滤波平滑后的深度图重建的法线如下图10所示。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.17/blog/FluidRendering/13.png" width="80%"></div></p><center> 图10 双边滤波平滑深度重建的法线 </center><p>&emsp;&emsp;由双边滤波平滑得到的法线做流体渲染如下图11，可以看到流体边界部分的保持得非常良好。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.17/blog/FluidRendering/14.png" width="80%"></div></p><center> 图11 双边滤波-保边良好 </center><p>&emsp;&emsp;但是这里又出现了一个性能方面的问题。双边滤波并不能像高斯模糊一样，拆分成水平方向依次、垂直方向一次，这是因为双边滤波考虑了图像的像素内容。一个核直径为20的双边滤波，每个像素要处理$20\times20=400$个邻域像素，这对于我的rtx2070显卡来说还好，但是在其他一些不那么好的显卡上会严重地拖慢渲染速度。Nvidia$^{[5]}$指出，可以强行将双边滤波分成两个pass，将$O(n^2)$的时间复杂度降到$O(n)$，一些失真可以勉强接受。然后我就尝试了将双边滤波分割成两个pass，水平方向和垂直方向各一次。效果如下图12所示，并不是非常好，在流体的一些边缘部分出现了拉伸的失真。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.17/blog/FluidRendering/15.png" width="80%"></div></p><center> 图12 双边分离滤波-边缘失真 </center><h3 id="4、采用曲率流平滑深度贴图"><a href="#4、采用曲率流平滑深度贴图" class="headerlink" title="4、采用曲率流平滑深度贴图"></a>4、采用曲率流平滑深度贴图</h3><p>&emsp;&emsp;由于双边滤波的不可分割性，Wladimir等人转向了另外一个不同的思路$^{[4]}$。我们的目标是寻转一个算法，能够平滑掉不同流体粒子之间的曲率突变，构建一个平滑、连续的流体表面。因此，一种思路就是最小化流体的曲率，这也跟流体的自然物理属性-流体表面张力相对应。我们称这个过程为曲率流（curvature flow）。</p><p>&emsp;&emsp;曲率流沿着表面法线方向扩展，其速度取决于表面平均曲率。在我们的这个流体渲染中，我们仅仅处理的是流体表面的深度。在一帧当中，视角固定了，我们同样可以通过沿着曲率修改深度值达到平滑的效果：</p><script type="math/tex; mode=display">\frac{\partial z}{\partial t} = H \tag {11}</script><p>&emsp;&emsp;其中$t$是平滑时间步长，$z$就是我们的深度值，$H$就是流体表面的平均曲率，公式$(11)$意思是在每一次的平滑迭代中，深度值的变化梯度为流体表面的平均曲率。因此，我们首先要求流体表面的平均曲率，平均曲率的定义为表面单位法线的散度：</p><script type="math/tex; mode=display">2H=\nabla\cdot \overline n \tag {12}</script><p>&emsp;&emsp;给定屏幕空间的坐标以及深度值，视口宽高$V_x$、$V_y$，以及投影的x和y方向的焦距长（就是投影矩阵的mat[0][0]、mat[1][1]），我们得到摄像机空间顶点坐标与屏幕空间的x和y的关系：</p><script type="math/tex; mode=display">P(x,y)=\left(\begin{matrix}\frac{\frac{2x}{V_x}-1.0}{F_x}\\\frac{\frac{2y}{V_y}-1.0}{F_y}\\1.0\end{matrix}\right)z(x,y)=\left(\begin{matrix}W_x\\W_y\\1.0\end{matrix}\right)z(x,y) \tag {13}</script><p>&emsp;&emsp;然后法线向量由两个偏导叉乘得到：</p><script type="math/tex; mode=display">n(x,y)=\frac{\partial P}{\partial x}\times \frac{\partial P}{\partial y}\\=\left(\begin{matrix}C_xz+W_x\frac{\partial z}{\partial x}\\W_y\frac{\partial z}{\partial x}\\\frac{\partial z}{\partial x}\end{matrix}\right)\times\left(\begin{matrix}W_x\frac{\partial z}{\partial y}\\C_yz+W_y\frac{\partial z}{\partial y}\\\frac{\partial z}{\partial y}\end{matrix}\right)\\\approx\left(\begin{matrix}C_xz\\0\\\frac{\partial z}{\partial x}\end{matrix}\right)\times\left(\begin{matrix}0\\C_yz\\\frac{\partial z}{\partial y}\end{matrix}\right)=\left(\begin{matrix}-C_y\frac{\partial z}{\partial x}\\-C_x\frac{\partial z}{\partial y}\\C_xC_yz\end{matrix}\right)z \tag {14}</script><p>&emsp;&emsp;其中$C_x=\frac{2}{V_xF_x}$，$C_y=\frac{2}{V_yF_y}$，公式$(14)$中我们忽略$W_x$和$W_y$是因为能够大大简化计算，且其贡献非常小。然后单位法线向量则为：</p><script type="math/tex; mode=display">\overline n=\frac{n(x,y)}{|n(x,y)|}=\frac{(-C_y\frac{\partial z}{\partial x},-C_x\frac{\partial z}{\partial y},C_xC_yz)^T}{\sqrt{D}} \tag {15}</script><script type="math/tex; mode=display">D=C_y^2(\frac{\partial z}{\partial x})^2+C_x^2(\frac{\partial z}{\partial y})^2+C_x^2C_y^2z^2 \tag {16}</script><p>&emsp;&emsp;单位法线公式有了，现在回过头来看平均曲率的计算公式$(12)$，我们要求单位法线的散度。由于深度值z是关于屏幕空间坐标x和y的函数，因此$\frac{\partial \overline n}{\partial z}=0$，因为求偏导时x和y定为常数。故：</p><script type="math/tex; mode=display">2H=\frac{\partial \overline n_x}{\partial x}+\frac{\partial \overline n_y}{\partial y}=\frac{C_yE_x+C_xE_y}{D^{\frac32}} \tag {17}</script><script type="math/tex; mode=display">E_x=\frac12\frac{\partial z}{\partial x}\frac{\partial D}{\partial x}-\frac{\partial^2z}{\partial x^2}D \tag {18}</script><script type="math/tex; mode=display">E_y=\frac12\frac{\partial z}{\partial y}\frac{\partial D}{\partial y}-\frac{\partial^2z}{\partial y^2}D \tag {19}</script><p>&emsp;&emsp;求得了平均曲率之后，我们就根据公式$(11)$采用简单的欧拉差分法修改深度值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line">in vec2 Texcoord;</span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> step;</span><br><span class="line">uniform sampler2D image;</span><br><span class="line">uniform mat4 projectMatrix;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">float</span> depth = texture(image, Texcoord).r;</span><br><span class="line"><span class="keyword">if</span>(depth &gt;= <span class="number">1.0f</span> || depth &lt;= <span class="number">-1.0f</span>)</span><br><span class="line">&#123;</span><br><span class="line">gl_FragDepth = depth;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vec2 imageDim = textureSize(image, <span class="number">0</span>);</span><br><span class="line">vec2 texelSize = <span class="number">1.0</span> / imageDim;</span><br><span class="line"></span><br><span class="line"><span class="comment">// central differences.</span></span><br><span class="line"><span class="keyword">float</span> depthRight = texture(image, Texcoord + vec2(texelSize.x, <span class="number">0</span>)).r;</span><br><span class="line"><span class="keyword">float</span> depthLeft = texture(image, Texcoord - vec2(texelSize.x, <span class="number">0</span>)).r;</span><br><span class="line"><span class="keyword">float</span> zdx = <span class="number">0.5f</span> * (depthRight - depthLeft);</span><br><span class="line"><span class="keyword">if</span>(depthRight == <span class="number">0.0f</span> || depthLeft == <span class="number">0.0f</span>)</span><br><span class="line">zdx = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> depthUp = texture(image, Texcoord + vec2(<span class="number">0</span>, texelSize.y)).r;</span><br><span class="line"><span class="keyword">float</span> depthDown = texture(image, Texcoord - vec2(<span class="number">0</span>, texelSize.y)).r;</span><br><span class="line"><span class="keyword">float</span> zdy = <span class="number">0.5f</span> * (depthUp - depthDown);</span><br><span class="line"><span class="keyword">if</span>(depthUp == <span class="number">0.0f</span> || depthDown == <span class="number">0.0f</span>)</span><br><span class="line">zdy = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> zdxx = depthRight + depthLeft - <span class="number">2.0f</span> * depth;</span><br><span class="line"><span class="keyword">float</span> zdyy = depthUp + depthDown - <span class="number">2.0f</span> * depth;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> depthFalloff = <span class="number">0.00005f</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(depth - depthRight) &gt; depthFalloff || <span class="built_in">abs</span>(depth - depthLeft) &gt; depthFalloff)</span><br><span class="line">zdx = zdxx = <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(depth - depthDown) &gt; depthFalloff || <span class="built_in">abs</span>(depth - depthUp) &gt; depthFalloff)</span><br><span class="line">zdy = zdyy = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> Fx = projectMatrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">float</span> Fy = projectMatrix[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> Cx = <span class="number">-2.0f</span>/(imageDim.x * Fx);</span><br><span class="line"><span class="keyword">float</span> Cy = <span class="number">-2.0f</span>/(imageDim.y * Fy);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> D = Cy * Cy * zdx * zdx + Cx * Cx * zdy * zdy + Cx * Cx * Cy * Cy * depth;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> Ex = <span class="number">0.5f</span> * zdx * dFdx(D) - zdxx * D;</span><br><span class="line"><span class="keyword">float</span> Ey = <span class="number">0.5f</span> * zdy * dFdy(D) - zdyy * D;</span><br><span class="line"></span><br><span class="line"><span class="comment">// curvature flow.</span></span><br><span class="line"><span class="keyword">float</span> curvature = <span class="number">0.5f</span> * (Cy * Ex + Cx * Ey)/ <span class="built_in">pow</span>(D, <span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">if</span>(curvature &gt; <span class="number">1.0f</span>)</span><br><span class="line">curvature = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">gl_FragDepth = depth + curvature * step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后在CPU端设置迭代多次，注意平滑的时间步长不能设置得太长。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> DepthCurvatureFlowBlurFilter::blurTexture(<span class="keyword">unsigned</span> <span class="keyword">int</span> targetTexIndex, <span class="keyword">const</span> glm::mat4 &amp;projectMat)</span><br><span class="line">&#123;</span><br><span class="line">m_framebuffer-&gt;bind();</span><br><span class="line">glDepthMask(GL_TRUE);</span><br><span class="line">glEnable(GL_DEPTH_TEST);</span><br><span class="line">glClear(GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// blur.</span></span><br><span class="line">Shader::ptr blurShader = ShaderMgr::getSingleton()-&gt;getShader(m_blurShaderIndex);</span><br><span class="line">blurShader-&gt;bind();</span><br><span class="line">blurShader-&gt;setInt(<span class="string">"image"</span>, <span class="number">0</span>);</span><br><span class="line">blurShader-&gt;setFloat(<span class="string">"step"</span>, <span class="number">0.00070f</span>);</span><br><span class="line">blurShader-&gt;setMat4(<span class="string">"projectMatrix"</span>, projectMat);</span><br><span class="line">TextureMgr::getSingleton()-&gt;bindTexture(targetTexIndex, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> iter = <span class="number">0</span>; iter &lt; m_iterations; ++iter)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// blur.</span></span><br><span class="line">MeshMgr::getSingleton()-&gt;drawMesh(m_screenQuadIndex, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy to target texture.</span></span><br><span class="line">glCopyTexSubImage2D(GL_TEXTURE_2D, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, m_width, m_height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TextureMgr::getSingleton()-&gt;unBindTexture(targetTexIndex);</span><br><span class="line">blurShader-&gt;unBind();</span><br><span class="line">m_framebuffer-&gt;unBind();</span><br><span class="line"><span class="keyword">return</span> targetTexIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>然而采用曲率流得方法我实现的效果并不是想象中的那么好，总体上不如采用双边滤波的方法，颗粒感较强。而且不知道为什么，流体的表面有一些抖动，看起来很奇怪，大概这就是买家秀跟买家秀的区别吧。</strong></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.17/blog/FluidRendering/16.png" width="80%"></div></p><center> 图13 采用曲率流的平滑效果 </center><h2 id="四、实现效果"><a href="#四、实现效果" class="headerlink" title="四、实现效果"></a>四、实现效果</h2><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.17/blog/FluidRendering/ret1.gif" width="99%"></div></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.17/blog/FluidRendering/ret2.gif" width="99%"></div></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.17/blog/FluidRendering/ret3.gif" width="99%"></div></p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>$[1]$ <a href="http://feepingcreature.github.io/math.html" target="_blank" rel="noopener">How to go from device coordinates back to worldspace in OpenGL</a></p><p>$[2]$ W. E. Lorensen and H. E. Cline, “Marching cubes: A high resolution 3D surface construction algorithm,” in Proceedings of the 14th annual conference on Computer graphics and interactive techniques - SIGGRAPH ’87, 1987, pp. 163–169.</p><p>$[3]$ <a href="https://en.wikipedia.org/wiki/Bilateral_filter" target="_blank" rel="noopener">Bilateral filter. From Wikipedia, the free encyclopedia</a></p><p>$[4]$ W. J. van der Laan, S. Green, and M. Sainz, “Screen space fluid rendering with curvature flow” in Proceedings of the 2009 symposium on Interactive 3D graphics and games - I3D ’09, 2009, p. 91.</p><p>$[5]$ <a href="https://link.zhihu.com/?target=http%3A//developer.download.nvidia.com/presentations/2010/gdc/Direct3D_Effects.pdf" target="_blank" rel="noopener">Screen Space Fluid Rendering for Games - Nvidia</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Fluid Simulation </category>
          
          <category> Position Based Dynamics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> Fluid Simulation </tag>
            
            <tag> Position Based Dynamics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流体模拟Fluid Simulation：基于CUDA的PBF实现</title>
      <link href="/2019/06/26/PBF_CUDA/"/>
      <url>/2019/06/26/PBF_CUDA/</url>
      
        <content type="html"><![CDATA[<p>继之前实现了CPU端的PBF算法之后，我去学了CUDA编程模型，本文就是关于用CUDA实现PBF算法在GPU上高速地模拟。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.16/blog/PBFCUDA/header.gif" width="99%"></div></p><a id="more"></a><ul><li>基于GPU的空间哈希</li><li>基于CUDA的PBF流体模拟</li><li>程序结果</li><li>参考资料</li></ul><center><font size="6">基于CUDA的PBF流体模拟</font></center><h2 id="一、基于GPU的空间哈希"><a href="#一、基于GPU的空间哈希" class="headerlink" title="一、基于GPU的空间哈希"></a>一、基于GPU的空间哈希</h2><p>&emsp;&emsp;在之前我们讨论了N-body的GPU并行实现，实际上这是一种比较极端的例子。在N-body系统中，每个粒子的都要与剩下的所有粒子计算两两之间的相互作用，这种相互作用通常有穿透力（如万有引力，称为体积力），无论远近、大小。但是在一些其他的物理模拟中，粒子只与周围邻近的粒子产生相互作用，如刚体、流体等，这时距离当前粒子比较远的其他粒子不会对当前的粒子产生任何的影响，因为刚体、流体之间的相互作用通常需要接触之后才产生（极端的例子不考虑，如万有引力，因为通常考虑的质量太小，万有引力几乎为0），所以我们没有必要采用N-body的方法逐个计算剩下的所有例子与当前粒子的物理作用，因为这会大大增加冗余计算。</p><p>&emsp;&emsp;对于流体、刚体、软体等的物理交互模拟，我们通常都是考虑的局部相互作用，这种局部相互作用要么就是接触才产生，要么就是随着距离的增大而迅速减小至消失。因此在这类的物理模拟中，我们需要采用一种快速的算法，该算法获取周围邻近的粒子，用以后续的物理模拟计算。这种算法就是空间哈希，在前面用CPU实现PBF时我们已经讨论过，它将整个空间做一个分割，每个粒子映射到一个空间数据结构，寻找邻域粒子时直接搜索周围空间的存储列表，算法复杂度只有$O(N)$。但是在GPU上实现该类算法稍微麻烦了点，因为GPU上的数据结构通常只有线性表，同时还要慎重考虑内存访问的开销等。</p><p>&emsp;&emsp;在GPU上实现该类算法有两种思路，先说说第一种方案。第一种方案是直接存储均匀分割的所有空间，为每个空间单元预先申请一个固定的大小的存储空间，这样需要提前申请固定大小的显卡内存空间，而且通常非常大，申请之后每个粒子计算哈希值索引，根据索引将其存储到对应的空间单元，由于流体和刚体通常是聚集的，因为这样将导致大部分的显卡内存空间都是空置状态，浪费了大量的显存空间，存储方式比较稀疏。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.16/blog/PBFCUDA/1.png" width="99%"></div></p><center> 图1 方案一 </center><p>&emsp;&emsp;如上图1的二维示例所示，方案一申请两个线性表，大小均为空间分割的分辨率，图中分割空间为$4\times 4=16$个。一个线性表为Count，记录当前的空间单元存在的粒子数目（为了避免写冲突，必须调用CUDA的原子操作指令atomicAdd），另外一个线性表记录每个空间单元中的粒子索引。当然我们也可以采用两个pass将粒子存储到一个连续的空间中，充分利用存储空间，但这需要两个pass，第一个pass计算每个空间单元的粒子数，然后第二个pass采用前缀和的方法计算每个空间单元存储的粒子的起始地址，最后将粒子连续地存储到线性表中。这个方法和接下来提到的采用排序的方法非常类似。</p><p>&emsp;&emsp;第二种方法采用排序将所有的粒子存储到紧凑的连续空间，节省大量的显存开销。如下图2所示，首先我们根据粒子的位置计算粒子的对应的空间哈希值，在这里我们目前只是简单地将粒子对应的线性编号作为它的哈希值cell id，然后将cell id和particle id这对数据存储线性数组中，其中我们要存储particle id是因为我们计算当前的cell id的时是根据粒子的位置来确定的，在后面我们需要用到这个对应关系，相当于一个索引。根据上面的步骤我们就得到了一个cell id乱序的线性表，接下来我们就根据这个cell id对整个数组做一个并行排序，使得数组的顺序是以cell id的顺序来排列的。这个过程相当于一个基数排序，因为一开始数组是以particle id为序的。得到这个以cell id为序的数组之后，我们需要记录每个空间单元cell记录的粒子起始地址和结束地址。判断起始地址很简单，只需将当前的cell id与数组的前一个cell id做比较，若不相同，则说明当前的粒子地址是当前粒子所在空间单元cell的起始地址，而且是其前一个粒子所在空间单元cell的终止地址。这样就能准确地记录每个空间单元的粒子。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.16/blog/PBFCUDA/2.png" width="99%"></div></p><center> 图2 方案二 </center><p>&emsp;&emsp;这里我们采用方案二的做法。首先需要计算每个粒子的空间hash值，前面已经说过，我们直接采用粒子的所在空间单元的线性编号，注意防止越界访问内存。下面的kernel代码calcGridPosKernel计算粒子所在空间单元的三维编号，接着calcGridHashKernel根据这个三维编号计算一维编号，最后将粒子索引id和哈希值存入两个对应的数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">__device__</span><br><span class="line"><span class="function">int3 <span class="title">calcGridPosKernel</span><span class="params">(float3 p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">int3 gridPos;</span><br><span class="line">gridPos.x = <span class="built_in">floor</span>((p.x - params.m_worldOrigin.x) / params.m_cellSize.x);</span><br><span class="line">gridPos.y = <span class="built_in">floor</span>((p.y - params.m_worldOrigin.y) / params.m_cellSize.y);</span><br><span class="line">gridPos.z = <span class="built_in">floor</span>((p.z - params.m_worldOrigin.z) / params.m_cellSize.z);</span><br><span class="line"><span class="keyword">return</span> gridPos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__device__</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">calcGridHashKernel</span><span class="params">(int3 gridPos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">gridPos.x = gridPos.x &amp; (params.m_gridSize.x - <span class="number">1</span>);</span><br><span class="line">gridPos.y = gridPos.y &amp; (params.m_gridSize.y - <span class="number">1</span>);</span><br><span class="line">gridPos.z = gridPos.z &amp; (params.m_gridSize.z - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> gridPos.z * params.m_gridSize.x * params.m_gridSize.y + gridPos.y * params.m_gridSize.x + gridPos.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__global__</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcParticlesHashKernel</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> *gridParticleHash,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> *gridParticleIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">float4 *pos,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> numParticles</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> index = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= numParticles)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> float4 curPos = pos[index];</span><br><span class="line"></span><br><span class="line">int3 gridPos = calcGridPosKernel(make_float3(curPos.x, curPos.y, curPos.z));</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> hashValue = calcGridHashKernel(gridPos);</span><br><span class="line"></span><br><span class="line">gridParticleHash[index] = hashValue;</span><br><span class="line">gridParticleIndex[index] = index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;紧接着，我们需要对前面计算得到的两个数组做一个key-value排序，就是根据key的顺序来排列。同样为了效率，需要使用并行排序。CUDA提供了一个thrust库，直接调用库中的sort_by_key方法帮我们省去了这一个比较繁琐的工作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortParticles</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> *deviceGridParticleHash,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> *deviceGridParticleIndex,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> numParticles</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">thrust::sort_by_key(</span><br><span class="line">thrust::device_ptr&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(deviceGridParticleHash),</span><br><span class="line">thrust::device_ptr&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(deviceGridParticleHash + numParticles),</span><br><span class="line">thrust::device_ptr&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(deviceGridParticleIndex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;前面对cell id和particle id排序之后，我们需要对存储粒子位置和速度属性的数组做一个相应的调整，使得其顺序与前面拍好的顺序一一对应。与此同时，还需要计算每个空间单元cell的起始地址和终止地址。这里我们充分利用同一个线程块的共享内存，设线程数有$n$个，那么我们申请$n+1$个单位大小的共享内存，每个线程首先将自己对应的那个粒子哈希值存储到共享内存中，第一个线程还要将其前一个粒子对应的哈希值存储到该共享内存中，这样可以避免每个线程访问全局内存2次（共2n次共享内存的访问），访问全局内存数变为了n+1次。然后每个粒子线程将当前对应的哈希值与其前一个粒子哈希值做比较，若不相同，则表明当前线程的index是空间单元cell的起始地址，终止地址同理。具体过程看如下的代码。我们设置cellStart初始为0xffffffff来表示它是一个空的cell单元，即没有任何的粒子落到该空间单元cell中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">__global__</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reoderDataAndFindCellRangeKernel</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> *cellStart,<span class="comment">// output: cell start index</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> *cellEnd,<span class="comment">// output: cell end index</span></span></span></span><br><span class="line"><span class="function"><span class="params">float4 *sortedPos,<span class="comment">// output: sorted positions</span></span></span></span><br><span class="line"><span class="function"><span class="params">float4 *sortedVel,<span class="comment">// output: sorted velocities</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> *gridParticleHash,<span class="comment">// input: sorted grid hashes</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> *gridParticleIndex,<span class="comment">// input: sorted particle indices</span></span></span></span><br><span class="line"><span class="function"><span class="params">float4 *oldPos,<span class="comment">// input: not sorted position array</span></span></span></span><br><span class="line"><span class="function"><span class="params">float4 *oldVel,<span class="comment">// input: not sorted velocity array</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> numParticles)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">thread_block cta = this_thread_block();</span><br><span class="line"><span class="keyword">extern</span> __shared__ <span class="keyword">unsigned</span> <span class="keyword">int</span> sharedHash[];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> index = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> hashValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (index &lt; numParticles)</span><br><span class="line">&#123;</span><br><span class="line">hashValue = gridParticleHash[index];</span><br><span class="line">sharedHash[threadIdx.x + <span class="number">1</span>] = hashValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// first thread in block must load neighbor particle hash</span></span><br><span class="line"><span class="keyword">if</span> (index &gt; <span class="number">0</span> &amp;&amp; threadIdx.x == <span class="number">0</span>)</span><br><span class="line">sharedHash[<span class="number">0</span>] = gridParticleHash[index - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sync(cta);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (index &lt; numParticles)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span> || hashValue != sharedHash[threadIdx.x])</span><br><span class="line">&#123;</span><br><span class="line">cellStart[hashValue] = index;</span><br><span class="line"><span class="keyword">if</span> (index &gt; <span class="number">0</span>)</span><br><span class="line">cellEnd[sharedHash[threadIdx.x]] = index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (index == numParticles - <span class="number">1</span>)</span><br><span class="line">cellEnd[hashValue] = index + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> sortedIndex = gridParticleIndex[index];</span><br><span class="line">float4 pos = oldPos[sortedIndex];</span><br><span class="line">float4 vel = oldVel[sortedIndex];</span><br><span class="line">sortedPos[index] = pos;</span><br><span class="line">sortedVel[index] = vel;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderDataAndFindCellRange</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> *cellStart,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> *cellEnd,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">float</span> *sortedPos,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">float</span> *sortedVel,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> *gridParticleHash,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> *gridParticleIndex,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">float</span> *oldPos,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">float</span> *oldVel,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> numParticles,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> numCell)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> numThreads, numBlocks;</span><br><span class="line">numThreads = <span class="number">256</span>;</span><br><span class="line">numBlocks = (numParticles % numThreads != <span class="number">0</span>) ? (numParticles / numThreads + <span class="number">1</span>) : (numParticles / numThreads);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set all cell to empty.</span></span><br><span class="line">cudaMemset(cellStart, <span class="number">0xffffffff</span>, numCell * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> memSize = <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) * (numThreads + <span class="number">1</span>);</span><br><span class="line">reoderDataAndFindCellRangeKernel &lt;&lt; &lt;numBlocks, numThreads, memSize &gt;&gt; &gt; (</span><br><span class="line">cellStart,</span><br><span class="line">cellEnd,</span><br><span class="line">(float4*)sortedPos,</span><br><span class="line">(float4*)sortedVel,</span><br><span class="line">gridParticleHash,</span><br><span class="line">gridParticleIndex,</span><br><span class="line">(float4*)oldPos,</span><br><span class="line">(float4*)oldVel,</span><br><span class="line">numParticles);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以上就是基于GPU的空间哈希过程，经过以上的步骤，粒子被紧凑地存储到线性空间，后面做物理计算时能快速地得到邻域空间的粒子。下面代码是整个基于GPU的空间哈希调用代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calculate grid Hash.</span></span><br><span class="line">computeHash(</span><br><span class="line">m_deviceGridParticleHash,</span><br><span class="line">m_deviceGridParticleIndex,</span><br><span class="line">m_devicePos,</span><br><span class="line">m_params.m_numParticles</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort particles based on hash value.</span></span><br><span class="line">sortParticles(</span><br><span class="line">m_deviceGridParticleHash,</span><br><span class="line">m_deviceGridParticleIndex,</span><br><span class="line">m_params.m_numParticles);</span><br><span class="line"></span><br><span class="line"><span class="comment">// reorder particle arrays into sorted order</span></span><br><span class="line"><span class="comment">// and find start index and end index of each cell.</span></span><br><span class="line">reorderDataAndFindCellRange(</span><br><span class="line">m_deviceCellStart,</span><br><span class="line">m_deviceCellEnd,</span><br><span class="line">m_deviceSortedPos,</span><br><span class="line">m_deviceSortedVel,</span><br><span class="line">m_deviceGridParticleHash,</span><br><span class="line">m_deviceGridParticleIndex,</span><br><span class="line">m_devicePos,</span><br><span class="line">m_deviceVel,</span><br><span class="line">m_params.m_numParticles,</span><br><span class="line">m_params.m_numGridCells);</span><br></pre></td></tr></table></figure><h2 id="二、基于CUDA的PBF流体模拟"><a href="#二、基于CUDA的PBF流体模拟" class="headerlink" title="二、基于CUDA的PBF流体模拟"></a>二、基于CUDA的PBF流体模拟</h2><p>&emsp;&emsp;在之前我们实现了CPU的PBF流体模拟，受限于CPU的低并行度，我们只能实时模拟数量很少的流体粒子。为了能够快速模拟大量的粒子，我特意去学了CUDA，接下来就用CUDA实现之前讨论的PBF算法。暂时不用刚体粒子来实现流体碰撞边界。首先我们回顾一下之前提到的PBF（Position Based Fluid）算法，算法的伪代码如下所示。基于PBD的流体模拟算法大致可以分成几个部分：流体粒子对流、领域粒子搜索、不可压缩的压力约束投影、更新速度、涡轮修复、粘度计算以及最后的粒子位置更新。可以看到，第5行到第7行邻域粒子搜索的实现在本文的前面部分已经讨论过了，所以就不再赘述了。</p><script type="math/tex; mode=display">\begin{align}&1.\ forall\ \ particles\ \ i\ \ do\\&2.\ \ \ \ \ apply\ \ force\ \ v_i\leftarrow v_i+\Delta tf_{ext}(x_i)\\&3.\ \ \ \ \ predict\ \ position\ \ x_i^*\leftarrow x_i+\Delta t v_i\\&4.\ endfor\\&5.\ forall\ \ particles\ \ i\ \ do\\&6.\ \ \ \ \ find\ \ neighboring\ \ particles\ \ N_i(x_i^*)\\&7.\ endfor\\&8.\ while\ \ iter\ \ <\ \ solverIterations\ \ do\\&9.\ \ \ \ \ forall\ \ particles\ \ i\ \ do\\&10.\ \ \ \ \ \ \ \ calculate\ \ \lambda_i\\\&11.\ \ \ \ endfor\\&12.\ \ \ \ forall\ \ particles\ \ i\ \ do\\&13.\ \ \ \ \ \ \ \ calculate\ \ \Delta p_i\\&14.\ \ \ \ \ \ \ \ perform\ \ collision\ \ detection\ \ and\ \ response\\&15.\ \ \ \ endfor\\&16.\ \ \ \ forall\ \ particles\ \ i\ \ do\\&17.\ \ \ \ \ \ \ \ update\ \ position\ \ x_i^*\leftarrow x_i^*+\Delta p_i\\&18.\ \ \ \ endfor\\&19.endwhile\\&20.forall\ \ particles\ \ i\ \ do\\&21.\ \ \ \ update\ \ velocity\ \ v_i\leftarrow\frac1{\Delta t}(x_i^*-x_i)\\&22.\ \ \ \ apply\ \ vorticity\ \ confinement\ \ and\ \ XSPH\ \ viscosity\\&23.\ \ \ \ update\ \ position\ \ x_i\leftarrow x_i^*\\&24.endfor\end{align}</script><p>&emsp;&emsp;在实现之前我们要弄清楚具体要申请多少的内存，仔细阅读上面的伪代码。首先我们必须申请两个位置向量数组，分别保存流体粒子的$x_i$和$x_i^*$。然后还需要一个数组存储粒子的位移信息$\Delta p_i$。最后需要存储粒子的速度信息，通常速度分量只需$(x,y,z)$即可，但是在算法的过程中还需要保存我们计算得到的拉格朗日乘子$\lambda_i$，所以我们申请分量为$(x,y,z,w)$的速度数组，第4个分量$w$存储拉格朗日乘子。</p><h3 id="1、流体粒子对流"><a href="#1、流体粒子对流" class="headerlink" title="1、流体粒子对流"></a>1、流体粒子对流</h3><p>&emsp;&emsp;本部分即伪代码的第1行至第4行，在体积力（如重力）的作用下，粒子的速度场发生变换，进而导致粒子的位置发生变换。需要注意的是，我们目前采用的方法（即伪代码中的）是只有一阶精度的。计算得到的位置并不是立即替换掉当前的位置，需要保存一个新的数组中，因为最后我们需要根据旧的粒子位置和新的粒子位置计算粒子的速度场。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">__global__</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">float4 *position,</span></span></span><br><span class="line"><span class="function"><span class="params">float4 *velocity,</span></span></span><br><span class="line"><span class="function"><span class="params">float4 *predictedPos,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">float</span> deltaTime,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> numParticles)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= numParticles)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">float4 readVel = velocity[index];</span><br><span class="line">float4 readPos = position[index];</span><br><span class="line">float3 nVel;</span><br><span class="line">float3 nPos;</span><br><span class="line">nVel.x = readVel.x + deltaTime * params.m_gravity.x;</span><br><span class="line">nVel.y = readVel.y + deltaTime * params.m_gravity.y;</span><br><span class="line">nVel.z = readVel.z + deltaTime * params.m_gravity.z;</span><br><span class="line">nPos.x = readPos.x + deltaTime * nVel.x;</span><br><span class="line">nPos.y = readPos.y + deltaTime * nVel.y;</span><br><span class="line">nPos.z = readPos.z + deltaTime * nVel.z;</span><br><span class="line"></span><br><span class="line"><span class="comment">// collision with walls.</span></span><br><span class="line"><span class="keyword">if</span> (nPos.x &gt; <span class="number">40.0f</span> - params.m_particleRadius)</span><br><span class="line">nPos.x = <span class="number">40.0f</span> - params.m_particleRadius;</span><br><span class="line"><span class="keyword">if</span> (nPos.x &lt; params.m_leftWall + params.m_particleRadius)</span><br><span class="line">nPos.x = params.m_leftWall + params.m_particleRadius;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nPos.y &gt; <span class="number">20.0f</span> - params.m_particleRadius)</span><br><span class="line">nPos.y = <span class="number">20.0f</span> - params.m_particleRadius;</span><br><span class="line"><span class="keyword">if</span> (nPos.y &lt; <span class="number">-20.0f</span> + params.m_particleRadius)</span><br><span class="line">nPos.y = <span class="number">-20.0f</span> + params.m_particleRadius;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nPos.z &gt; <span class="number">20.0f</span> - params.m_particleRadius)</span><br><span class="line">nPos.z = <span class="number">20.0f</span> - params.m_particleRadius;</span><br><span class="line"><span class="keyword">if</span> (nPos.z &lt; <span class="number">-20.0f</span> + params.m_particleRadius)</span><br><span class="line">nPos.z = <span class="number">-20.0f</span> + params.m_particleRadius;</span><br><span class="line"></span><br><span class="line">predictedPos[index] = &#123; nPos.x, nPos.y, nPos.z, readPos.w &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、不可压缩约束投影"><a href="#3、不可压缩约束投影" class="headerlink" title="3、不可压缩约束投影"></a>3、不可压缩约束投影</h3><p>&emsp;&emsp;关于不可压缩的约束投影，具体在之前详细讲过，这里我们只是简单地回顾一下。首先PBF的不可压缩的密度约束公式如下所示，其中$\rho_i$是第$i$个粒子的密度值，$\rho_0$是流体静止时的密度值。</p><script type="math/tex; mode=display">C_i(p_1,...,p_n)=\frac{\rho_i}{\rho_0}-1 \tag {1}</script><p>&emsp;&emsp;第$i$个流体粒子的密度计算我们采用SPH的方法，根据周围邻近粒子的质量做一个加权和，如下所示：</p><script type="math/tex; mode=display">\rho_i=\Sigma_jm_jW(p_i-p_j,h) \tag {2}</script><p>&emsp;&emsp;权重$W$函数我们采用Poly6核函数（$h$是光滑核半径）：</p><script type="math/tex; mode=display">W_{poly6}(r,h)=\frac{315}{64\pi h^9}\begin{cases}(h^2-|r|^2)^3\ \ \ \  0\leq|r|\leq h\\0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ otherwise \end{cases} \tag {3}</script><p>&emsp;&emsp;但是在计算密度的梯度时，我们又采用Spiky核函数：</p><script type="math/tex; mode=display">W_{spiky}(r,h)=\frac{15}{\pi h^6}\begin{cases}(h-|r|)^3\ \ \ \ 0\leq|r|\leq h\\0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 0therwise\end{cases} \\\nabla W_{spiky}(r,h)=-\frac{45}{\pi h^6}\begin{cases}(h-|r|)^2\frac{r}{|r|}\ \ \ \ 0\leq|r|\leq h\\0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ otherwise\end{cases} \tag {4}</script><p>&emsp;&emsp;Poly6核函数计算以及Spiky函数的梯度计算代码如下所示，为了性能，我提前在CPU端计算函数的常量系数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">__device__</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">wPoly6</span><span class="params">(<span class="keyword">const</span> float3 &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> lengthSquared = r.x * r.x + r.y * r.y + r.z * r.z;</span><br><span class="line"><span class="keyword">if</span> (lengthSquared &gt; params.m_sphRadiusSquared || lengthSquared &lt;= <span class="number">0.00000001f</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">float</span> iterm = params.m_sphRadiusSquared - lengthSquared;</span><br><span class="line"><span class="keyword">return</span> params.m_poly6Coff * iterm * iterm * iterm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__device__</span><br><span class="line"><span class="function">float3 <span class="title">wSpikyGrad</span><span class="params">(<span class="keyword">const</span> float3 &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> lengthSquared = r.x * r.x + r.y * r.y + r.z * r.z;</span><br><span class="line">float3 ret = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (lengthSquared &gt; params.m_sphRadiusSquared || lengthSquared &lt;= <span class="number">0.00000001f</span>)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> length = sqrtf(lengthSquared);</span><br><span class="line"><span class="keyword">float</span> iterm = params.m_sphRadius - length;</span><br><span class="line"><span class="keyword">float</span> coff = params.m_spikyGradCoff * iterm * iterm / length;</span><br><span class="line">ret.x = coff * r.x;</span><br><span class="line">ret.y = coff * r.y;</span><br><span class="line">ret.z = coff * r.z;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后公式$(1)$及其梯度就为：</p><script type="math/tex; mode=display">C_i(p_1,...,p_n)=\frac{\Sigma_j m_jW(p_i-p_j,h)}{\rho_0}-1 \\\nabla_{p_k}C_i=\frac1\rho_0\begin{cases}\Sigma_j\nabla_{p_k}W(p_i-p_j,h)\ \ \ \ if\ \ k=i\\-\nabla_{p_k}W(p_i-p_j,h)\ \ \ \ \ if\ \ k=j\end{cases} \tag {5}</script><p>&emsp;&emsp;拉格朗日乘子的计算公式就为：</p><script type="math/tex; mode=display">\lambda_i=-\frac{C_i(p_1,...,p_n)}{\Sigma_k|\nabla_{p_k}C_i|^2} \tag {6}</script><p>&emsp;&emsp;<strong>这里我要重点强调的一点就是，流体静止时的密度设置很有必要思考一下。因为我假设粒子的质量都为$1kg$，所以公式中关于质量$m$的都可以直接去掉，我们需要根据流体粒子的体积计算静止时的密度。设一个粒子的半径为$r$，一个流体粒子当成立方体而不是球体，则其体积为$(2r)^3=8r^3$，那么静止时的密度$\rho_0=1/(8r^3)$，因为$\rho=m/v$。</strong>接着我们根据公式$(2)$和公式$(6)$计算流体粒子的密度和拉格朗日乘子，并计算得到的拉格朗日乘子存储到速度的第四个分量上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">__global__</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcLagrangeMultiplier</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">float4 *predictedPos,</span></span></span><br><span class="line"><span class="function"><span class="params">float4 *velocity,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> *cellStart,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> *cellEnd,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> *gridParticleHash,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> numParticles,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> numCells)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// calculate current particle's density and lagrange multiplier.</span></span><br><span class="line"><span class="keyword">int</span> index = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= numParticles)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">float4 readPos = predictedPos[index];</span><br><span class="line">float4 readVel = velocity[index];</span><br><span class="line">float3 curPos = &#123; readPos.x, readPos.y, readPos.z &#125;;</span><br><span class="line">int3 gridPos = calcGridPosKernel(curPos);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> density = <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">float</span> gradSquaredSum_j = <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">float</span> gradSquaredSumTotal = <span class="number">0.0f</span>;</span><br><span class="line">float3 curGrad, gradSum_i = &#123; <span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> unroll 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">-1</span>; z &lt;= <span class="number">1</span>; ++z)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> unroll 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">-1</span>; y &lt;= <span class="number">1</span>; ++y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> unroll 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">-1</span>; x &lt;= <span class="number">1</span>; ++x)</span><br><span class="line">&#123;</span><br><span class="line">int3 neighbourGridPos = &#123; gridPos.x + x, gridPos.y + y, gridPos.z + z &#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> neighbourGridIndex = calcGridHashKernel(neighbourGridPos);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> startIndex = cellStart[neighbourGridIndex];</span><br><span class="line"><span class="comment">// empty cell.</span></span><br><span class="line"><span class="keyword">if</span> (startIndex == <span class="number">0xffffffff</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> endIndex = cellEnd[neighbourGridIndex];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> unroll 32</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = startIndex; i &lt; endIndex; ++i)</span><br><span class="line">&#123;</span><br><span class="line">float4 neighbour = predictedPos[i];</span><br><span class="line">float3 r = &#123; curPos.x - neighbour.x, curPos.y - neighbour.y, curPos.z - neighbour.z &#125;;</span><br><span class="line">density += wPoly6(r);</span><br><span class="line">curGrad = wSpikyGrad(r);</span><br><span class="line">curGrad.x *= params.m_invRestDensity;</span><br><span class="line">curGrad.y *= params.m_invRestDensity;</span><br><span class="line">curGrad.z *= params.m_invRestDensity;</span><br><span class="line"></span><br><span class="line">gradSum_i.x += curGrad.x;</span><br><span class="line">gradSum_i.y += curGrad.y;</span><br><span class="line">gradSum_i.z += curGrad.z;</span><br><span class="line"><span class="keyword">if</span> (i != index)</span><br><span class="line">gradSquaredSum_j += (curGrad.x * curGrad.x + curGrad.y * curGrad.y</span><br><span class="line">+ curGrad.z * curGrad.z);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">gradSquaredSumTotal = gradSquaredSum_j + gradSum_i.x * gradSum_i.x + gradSum_i.y * gradSum_i.y</span><br><span class="line">+ gradSum_i.z * gradSum_i.z;</span><br><span class="line"></span><br><span class="line"><span class="comment">// density constraint.</span></span><br><span class="line"><span class="keyword">float</span> constraint = density * params.m_invRestDensity - <span class="number">1.0f</span>;</span><br><span class="line"><span class="keyword">float</span> lambda = -(constraint) / (gradSquaredSumTotal + params.m_lambdaEps);</span><br><span class="line">velocity[index] = &#123; readVel.x, readVel.y, readVel.z, lambda &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;计算完拉格朗日乘子之后，我们需要根据它来计算流体粒子的矫正位移量。同样，矫正偏移量的公式如下所示，同样我们考虑了邻近粒子的作用。</p><script type="math/tex; mode=display">\begin{align}\Delta p_i&=\lambda_i \nabla_{p_i}C_i+\Sigma_j\lambda_j\nabla_{p_j}C_i\\&=\frac1\rho_0\Sigma_j\lambda_i\nabla_{p_i}W(r,h)+(-\frac1\rho_0\Sigma_j\lambda_j\nabla_{p_j}W(r,h))\\&=\frac1\rho_0\Sigma_j\lambda_i\nabla_{p_i}W(r,h)+\frac1\rho_0\Sigma_j\lambda_j\nabla_{p_i}W(r,h)\\&=\frac{1}{\rho_0}\Sigma_j(\lambda_i+\lambda_j)\nabla_{p_i}W(r,h)\end{align} \tag {7}</script><p>&emsp;&emsp;进一步地，为了防止粒子聚集导致流体表面失真，造成拉伸不稳定性，我们需要给上面的矫正位移公式$(7)$增加一个人工排斥力，当流体粒子距离过近时该排斥力会使它们分开，避免产生粒子聚集的现象。</p><script type="math/tex; mode=display">\Delta p_i=\frac1\rho_0\Sigma_j(\lambda_i+\lambda_j+s_{corr})\nabla_{p_i}W(p_i-p_j,h) \\s_{corr}=-k(\frac{W(p_i-p_j,h)}{W(\Delta q,h)})^n \tag {8}</script><p>&emsp;&emsp;上面的排斥项会使得流体粒子的密度稍微低于静态密度，从而产生类似于表面张力的效果，使得流体表面的的粒子分布均匀。通过这个排斥项，我们不再需要硬性规定流体的邻居数量必须在30~40个，进一步提升算法的流体模拟效率。根据公式$(8)$，我们计算矫正位移的cuda代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">__global__</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcDeltaPosition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">float4 *predictedPos,</span></span></span><br><span class="line"><span class="function"><span class="params">float4 *velocity,</span></span></span><br><span class="line"><span class="function"><span class="params">float3 *deltaPos,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> *cellStart,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> *cellEnd,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> *gridParticleHash,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> numParticles)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= numParticles)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">float4 readPos = predictedPos[index];</span><br><span class="line">float4 readVel = velocity[index];</span><br><span class="line">float3 curPos = &#123; readPos.x, readPos.y, readPos.z &#125;;</span><br><span class="line">int3 gridPos = calcGridPosKernel(curPos);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> curLambda = readVel.w;</span><br><span class="line">float3 deltaP = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> unroll 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">-1</span>; z &lt;= <span class="number">1</span>; ++z)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> unroll 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">-1</span>; y &lt;= <span class="number">1</span>; ++y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> unroll 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">-1</span>; x &lt;= <span class="number">1</span>; ++x)</span><br><span class="line">&#123;</span><br><span class="line">int3 neighbourGridPos = &#123; gridPos.x + x, gridPos.y + y, gridPos.z + z &#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> neighbourGridIndex = calcGridHashKernel(neighbourGridPos);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> startIndex = cellStart[neighbourGridIndex];</span><br><span class="line"><span class="keyword">if</span> (startIndex == <span class="number">0xffffffff</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> endIndex = cellEnd[neighbourGridIndex];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> unroll 32</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = startIndex; i &lt; endIndex; ++i)</span><br><span class="line">&#123;</span><br><span class="line">float4 neighbour = predictedPos[i];</span><br><span class="line"><span class="keyword">float</span> neighbourLambda = velocity[i].w;</span><br><span class="line">float3 r = &#123; curPos.x - neighbour.x, curPos.y - neighbour.y, curPos.z - neighbour.z &#125;;</span><br><span class="line"><span class="keyword">float</span> corrTerm = wPoly6(r) * params.m_oneDivWPoly6;</span><br><span class="line"><span class="keyword">float</span> coff = curLambda + neighbourLambda - <span class="number">0.1f</span> * corrTerm * corrTerm * corrTerm * corrTerm;</span><br><span class="line">float3 grad = wSpikyGrad(r);</span><br><span class="line">deltaP.x += coff * grad.x;</span><br><span class="line">deltaP.y += coff * grad.y;</span><br><span class="line">deltaP.z += coff * grad.z;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float3 ret = &#123;deltaP.x * params.m_invRestDensity, deltaP.y * params.m_invRestDensity,</span><br><span class="line">deltaP.z * params.m_invRestDensity &#125;;</span><br><span class="line">deltaPos[index] = ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后，我们需要把前面计算得到的矫正位移加到位置向量上，从而使得粒子在移动之后依然保持流体不可压缩的特性。这里对应伪代码的第16行到第18行，比较简单。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">__global__</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addDeltaPosition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">float4 *predictedPos,</span></span></span><br><span class="line"><span class="function"><span class="params">float3 *deltaPos,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> numParticles)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= numParticles)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">float4 readPos = predictedPos[index];</span><br><span class="line">float3 readDeltaPos = deltaPos[index];</span><br><span class="line">readDeltaPos.x = readPos.x + readDeltaPos.x;</span><br><span class="line">readDeltaPos.y = readPos.y + readDeltaPos.y;</span><br><span class="line">readDeltaPos.z = readPos.z + readDeltaPos.z;</span><br><span class="line"></span><br><span class="line">predictedPos[index] = &#123; readDeltaPos.x, readDeltaPos.y, readDeltaPos.z, readPos.w &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后，约束投影并不是一次就够了，还需要迭代多次，我设置了迭代3次。</p><h3 id="3、更新速度和位置"><a href="#3、更新速度和位置" class="headerlink" title="3、更新速度和位置"></a>3、更新速度和位置</h3><p>&emsp;&emsp;对应伪代码的第21行，我们根据流体粒子的上一帧位置和当前计算得到的位置计算粒子的速度值，直接根据速度的定义计算。这样计算到的速度将在下一帧产生作用，这也是Position Based Dynamics的由来，我们不是直接根据速度来更新粒子的位置，而是根据粒子的位移来更新粒子的速度，即“位置变化驱动”。最后将新的位置值覆盖到原先的位置向量上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">__global__</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateVelocityAndPosition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">float4 *position,</span></span></span><br><span class="line"><span class="function"><span class="params">float4 *velocity,</span></span></span><br><span class="line"><span class="function"><span class="params">float4 *predictedPos,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">float</span> invDeltaTime,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> numParticles)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= numParticles)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">float4 oldPos = position[index];</span><br><span class="line">float4 newPos = predictedPos[index];</span><br><span class="line">float4 readVel = velocity[index];</span><br><span class="line">float3 posDiff = &#123; newPos.x - oldPos.x, newPos.y - oldPos.y, newPos.z - oldPos.z &#125;;</span><br><span class="line">posDiff.x *= invDeltaTime;</span><br><span class="line">posDiff.y *= invDeltaTime;</span><br><span class="line">posDiff.z *= invDeltaTime;</span><br><span class="line">velocity[index] = &#123; posDiff.x, posDiff.y, posDiff.z, readVel.w &#125;;</span><br><span class="line">position[index] = &#123; newPos.x, newPos.y, newPos.z, newPos.w &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、涡轮修复和人工粘性"><a href="#4、涡轮修复和人工粘性" class="headerlink" title="4、涡轮修复和人工粘性"></a>4、涡轮修复和人工粘性</h3><p>&emsp;&emsp;由于数值耗散，PBD的方法会引入额外的阻尼，使得整个系统的能量损耗太快，导致本来应该由的一些涡流细节迅速消失。在这里，PBF通过涡轮控制方法向整个系统重新注入能量（$\epsilon$用于控制涡轮控制力的强度）：</p><script type="math/tex; mode=display">f_i^{vorticity}=\epsilon (N\times \omega_i) \\N=\frac{\eta}{|\eta|},\ \eta=\nabla|\omega|_i\\\omega_i=\nabla\times v=\Sigma_j(v_j-v_i)\times \nabla_{p_j}W(p_i-p_j,h) \tag {9}</script><p>&emsp;&emsp;涡轮修复这一部分论文并未详细展开，然后我就按照自己的理解写了个大概，代码如下所示。结果发现还是有问题，暂先这样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">__global__</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcVorticityConfinment</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">float4 *velocity,</span></span></span><br><span class="line"><span class="function"><span class="params">float3 *deltaPos,</span></span></span><br><span class="line"><span class="function"><span class="params">float4 *predictedPos,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> *cellStart,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> *cellEnd,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> *gridParticleHash,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> numParticles)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= numParticles)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">float4 readPos = predictedPos[index];</span><br><span class="line">float4 readVel = velocity[index];</span><br><span class="line">float3 curPos = &#123; readPos.x, readPos.y, readPos.z &#125;;</span><br><span class="line">float3 curVel = &#123; readVel.x, readVel.y, readVel.z &#125;;</span><br><span class="line">int3 gridPos = calcGridPosKernel(curPos);</span><br><span class="line">float3 velDiff;</span><br><span class="line">float3 gradient;</span><br><span class="line">float3 omega = &#123; <span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span> &#125;;</span><br><span class="line">float3 eta = &#123; <span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> unroll 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">-1</span>; z &lt;= <span class="number">1</span>; ++z)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> unroll 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">-1</span>; y &lt;= <span class="number">1</span>; ++y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> unroll 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">-1</span>; x &lt;= <span class="number">1</span>; ++x)</span><br><span class="line">&#123;</span><br><span class="line">int3 neighbourGridPos = &#123; gridPos.x + x, gridPos.y + y, gridPos.z + z &#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> neighbourGridIndex = calcGridHashKernel(neighbourGridPos);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> startIndex = cellStart[neighbourGridIndex];</span><br><span class="line"><span class="keyword">if</span> (startIndex == <span class="number">0xffffffff</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> endIndex = cellEnd[neighbourGridIndex];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> unroll 32</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = startIndex; i &lt; endIndex; ++i)</span><br><span class="line">&#123;</span><br><span class="line">float4 neighbourPos = predictedPos[i];</span><br><span class="line">float4 neighbourVel = velocity[i];</span><br><span class="line">velDiff = &#123; neighbourVel.x - curVel.x, neighbourVel.y - curVel.y, neighbourVel.z - curVel.z &#125;;</span><br><span class="line">gradient = wSpikyGrad(&#123; curPos.x - neighbourPos.x, curPos.y - neighbourPos.y ,</span><br><span class="line">curPos.z - neighbourPos.z &#125;);</span><br><span class="line">float3 f = cross(velDiff, gradient);</span><br><span class="line">omega.x += f.x;</span><br><span class="line">omega.y += f.y;</span><br><span class="line">omega.z += f.z;</span><br><span class="line">eta.x += gradient.x;</span><br><span class="line">eta.y += gradient.y;</span><br><span class="line">eta.z += gradient.z;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">float</span> omegaLength = sqrtf(omega.x * omega.x + omega.y * omega.y + omega.z * omega.z);</span><br><span class="line">float3 force = &#123; <span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span> &#125;;</span><br><span class="line"><span class="comment">//No direction for eta</span></span><br><span class="line"><span class="keyword">if</span> (omegaLength == <span class="number">0.0f</span>)</span><br><span class="line">&#123;</span><br><span class="line">deltaPos[index] = force;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// eta.</span></span><br><span class="line">eta.x *= omegaLength;</span><br><span class="line">eta.y *= omegaLength;</span><br><span class="line">eta.z *= omegaLength;</span><br><span class="line"><span class="keyword">if</span> (eta.x == <span class="number">0</span> &amp;&amp; eta.y == <span class="number">0</span> &amp;&amp; eta.z == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">deltaPos[index] = force;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// eta normalize.</span></span><br><span class="line"><span class="keyword">float</span> etaLength = sqrtf(eta.x * eta.x + eta.y * eta.y + eta.z * eta.z);</span><br><span class="line">eta.x /= etaLength;</span><br><span class="line">eta.y /= etaLength;</span><br><span class="line">eta.z /= etaLength;</span><br><span class="line">force = cross(eta, omega);</span><br><span class="line">force.x *= params.m_vorticity;</span><br><span class="line">force.y *= params.m_vorticity;</span><br><span class="line">force.z *= params.m_vorticity;</span><br><span class="line">deltaPos[index] = force;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__global__</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addVorticityConfinment</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">float4 *velocity,</span></span></span><br><span class="line"><span class="function"><span class="params">float3 *deltaPos,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">float</span> deltaTime,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> numParticles)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= numParticles)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">float4 readVel = velocity[index];</span><br><span class="line">float3 vorticity = deltaPos[index];</span><br><span class="line">readVel.x += vorticity.x ;</span><br><span class="line">readVel.y += vorticity.y ;</span><br><span class="line">readVel.z += vorticity.z ;</span><br><span class="line">velocity[index] = readVel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后，PBF方法采用XSPH的粘度方法直接更新速度，从而产生粘性阻尼。人工粘性除了可以增加模拟的数值稳定性，还可以消除非物理的流体振荡。拉格朗日流体模拟方法中，人工粘性本质上会对流体粒子的相对运动产生阻尼作用，使流体的动能转化为热能（同样目前我实现的有问题）：</p><script type="math/tex; mode=display">v_i^{new}=v_i+c\Sigma_j(v_i-v_j)\cdot W(p_i-p_j,h) \tag {10}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">__global__</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcXSPHViscosity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">float4 *velocity,</span></span></span><br><span class="line"><span class="function"><span class="params">float3 *deltaPos,</span></span></span><br><span class="line"><span class="function"><span class="params">float4 *predictedPos,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> *cellStart,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> *cellEnd,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> *gridParticleHash,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> numParticles)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= numParticles)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">float4 readPos = predictedPos[index];</span><br><span class="line">float4 readVel = velocity[index];</span><br><span class="line">float3 curPos = &#123; readPos.x, readPos.y, readPos.z &#125;;</span><br><span class="line">float3 curVel = &#123; readVel.x, readVel.y, readVel.z &#125;;</span><br><span class="line">int3 gridPos = calcGridPosKernel(curPos);</span><br><span class="line">float3 viscosity = &#123; <span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span> &#125;;</span><br><span class="line">float3 velocityDiff;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> unroll 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">-1</span>; z &lt;= <span class="number">1</span>; ++z)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> unroll 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">-1</span>; y &lt;= <span class="number">1</span>; ++y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> unroll 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">-1</span>; x &lt;= <span class="number">1</span>; ++x)</span><br><span class="line">&#123;</span><br><span class="line">int3 neighbourGridPos = &#123; gridPos.x + x, gridPos.y + y,gridPos.z + z &#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> neighbourGridIndex = calcGridHashKernel(neighbourGridPos);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> startIndex = cellStart[neighbourGridIndex];</span><br><span class="line"><span class="keyword">if</span> (startIndex == <span class="number">0xffffffff</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> endIndex = cellEnd[neighbourGridIndex];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> unroll 32</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = startIndex; i &lt; endIndex; ++i)</span><br><span class="line">&#123;</span><br><span class="line">float4 neighbourPos = predictedPos[i];</span><br><span class="line">float4 neighbourVel = velocity[i];</span><br><span class="line"><span class="keyword">float</span> wPoly = wPoly6(&#123;</span><br><span class="line">curPos.x - neighbourPos.x,</span><br><span class="line">curPos.y - neighbourPos.y,</span><br><span class="line">curPos.z - neighbourPos.z &#125;);</span><br><span class="line">velocityDiff = &#123;</span><br><span class="line">curVel.x - neighbourVel.x,</span><br><span class="line">curVel.y - neighbourVel.y,</span><br><span class="line">curVel.z - neighbourVel.z</span><br><span class="line">&#125;;</span><br><span class="line">viscosity.x += velocityDiff.x * wPoly;</span><br><span class="line">viscosity.y += velocityDiff.y * wPoly;</span><br><span class="line">viscosity.z += velocityDiff.z * wPoly;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">viscosity.x *= params.m_viscosity;</span><br><span class="line">viscosity.y *= params.m_viscosity;</span><br><span class="line">viscosity.z *= params.m_viscosity;</span><br><span class="line">deltaPos[index] = viscosity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__global__</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addXSPHViscosity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">float4 *velocity,</span></span></span><br><span class="line"><span class="function"><span class="params">float3 *deltaPos,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">float</span> deltaTime,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> numParticles)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= numParticles)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">float4 readVel = velocity[index];</span><br><span class="line">float3 viscosity = deltaPos[index];</span><br><span class="line">readVel.x += viscosity.x ;</span><br><span class="line">readVel.y += viscosity.y ;</span><br><span class="line">readVel.z += viscosity.z ;</span><br><span class="line">velocity[index] = readVel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、程序结果"><a href="#三、程序结果" class="headerlink" title="三、程序结果"></a>三、程序结果</h2><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.16/blog/PBFCUDA/ret1.gif" width="99%"></div></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.16/blog/PBFCUDA/header.gif" width="99%"></div></p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>$[1]$ <a href="https://developer.download.nvidia.cn/assets/cuda/files/particles.pdf" target="_blank" rel="noopener">“Particle Simulation using CUDA”, Simon Green</a></p><p>$[2]$ Macklin, Miles, and Matthias Müller. “Position based fluids.” ACM Transactions on Graphics (TOG) 32.4 (2013): 104.</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Fluid Simulation </category>
          
          <category> Position Based Dynamics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> Fluid Simulation </tag>
            
            <tag> Position Based Dynamics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多体问题N-body：基于CUDA的快速N-body模拟</title>
      <link href="/2019/06/20/NbodySimulation/"/>
      <url>/2019/06/20/NbodySimulation/</url>
      
        <content type="html"><![CDATA[<p>本篇文章主要是关于用cuda实现天体的N-body系统，以及粒子渲染的辉光效果。相关的完整代码请看<a href="https://github.com/ZeusYang/NBodySimulation" target="_blank" rel="noopener">这个链接</a>。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.15/blog/Nbody/header.gif" width="99%"></div></p><a id="more"></a><ul><li>天体的N-body系统</li><li>基于CUDA的N-body实现</li><li>粒子渲染-辉光特效</li><li>参考资料</li></ul><center><font size="6">基于CUDA的快速N-body模拟</font></center>&emsp;&emsp;N-body问题（或者说N体问题），是一个常见的物理模拟问题。在N-body系统中，每个粒子体都会与剩下的其他粒子产生交互作用（交互作用因具体问题而异），从而产生相应的物理现象。天体模拟就是一个非常经典的N-body系统，根据牛顿的万有引力定律，宇宙中的不同天体之间会产生相互作用的吸引力，吸引力根据两个天体之间的质量和距离的不同而各不相同，一个天体的运动轨迹最终取决于剩下的所有的天体对该天体的引力的合力。除了天体系统之外，N-body模拟在其他计算学科中也是常客。例如模拟蛋白质折叠现象就是通过计算N-body之间的静电和范德华力，**计算机图形学中的湍流流体的流动模拟和全局光照明计算都涉及到N-body问题的求解**。&emsp;&emsp;这周主要学习CUDA（全称为Computer Unified Device Architecture），它是一个NVIDIA的GPU编程模型，搞图形学不免常要与GPU打交道，所以非常有必要学习这个统一的GPU编程框架。N-body问题是计算机图形学中物理模拟的常见问题，在此我采用CUDA实现了一个天体星系的N-body模拟系统，充分利用GPU的并行能力去加速N-body的巨额计算过程。下面这张图就是我实现的天体星系模拟效果。<div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.15/blog/Nbody/header.png" width="99%"><center> 图1 天体星系的N-body模拟 </center><h2 id="1、天体的N-body系统"><a href="#1、天体的N-body系统" class="headerlink" title="1、天体的N-body系统"></a>1、天体的N-body系统</h2><p>&emsp;&emsp;一种最简单的求解N-body的方法就是暴力法，被称为all-pairs法，它直接计算一个粒子体与剩下的所有粒子体的相互作用，对每一个粒子都做类似的处理，这样可以确保每个粒子体都与剩下的所有粒子体都产生交互作用，这种方法简单、暴力，但是算法的复杂度非常高，达到了$O(N^2)$量级，当模拟的N-body系统有$N=10000$个粒子时，算法就需要处理1亿次的相互作用计算。显然对于非常庞大的N-body系统，直接使用暴力法将非常耗时，因而通常不是简单地采用该算法。all-pairs法通常与一种基于长距离力的远场近似法结合，目前此类形式的算法包括Barnes-Hut法$^{[1]}$、快速多极法$^{[2]}$和粒子网格法$^{[3]}$等等。</p><p>&emsp;&emsp;上面提到的几种加速方法最耗时的部分依旧是all-pairs部分，因此这是一个非常关键的部分，如果能够加速这一部分，那么模拟的速度将大大提升。因此，目前我们只关注all-pairs算法部分，而且不是在CPU上实现该算法的串行，而是接用CUDA编程模型实行一个GPU并行的快速版本。接下来先介绍一下天体星系的N-body系统。</p><p>&emsp;&emsp;天体星系模拟主要考虑的是万有引力。给定$N$个天体，我们记每个天体$0\leq i&lt;N$的位置向量为$x_i$、速度向量为$v_i$、质量为$m_i$，根据牛顿的万有引力定律，任意两个不同天体$i$和$j$之间的万有引力计算公式如下所示：</p><script type="math/tex; mode=display">f_{ij}=G\frac{m_im_j}{||r_{ij}||^2}\cdot \frac{r_{ij}}{||r_{ij}||} \tag {1}</script><p>&emsp;&emsp;公式$(1)$中的$r_{ij}=x_j-x_i$为从天体$i$到$j$的一个方向向量，故其模长为两者之间的距离。$G$是万有引力常数。上面这个公式可能看起来跟我们高中时学的万有引力公式略有不同，这是因为高中时还没有将力是一个矢量这个概念显示地表达出来，公式$(1)$中的$\frac{r_{ij}}{||r_{ij}||}$是一个从$i$到$j$的单位方向向量。上述公式描述的是天体$j$对天体$i$的引力，那么除$i$之外的所有天体对天体$i$的引力合力的计算公式为：</p><script type="math/tex; mode=display">F_i=\Sigma_{0\leq j<N,j\neq i}f_{ij}=Gm_i\cdot\Sigma_{0\leq j<N,j\neq i}\frac{m_jr_{ij}}{||r_{ij}||^3} \tag {2}</script><p>&emsp;&emsp;公式$(2)$有个潜在的不稳定问题，当两个粒子之间的距离向量$r_{ij}\to0$时，$||r_{ij}||$取值为$0$，从而导致除零错误，在计算机系统中这将导致程序崩溃。因此，为了避免这种情况，我们在公式$(2)$的基础上给它的分母再加上一个软化因子（softening factor）$ε^2&gt;0$，从而万有引力近似计算公式为：</p><script type="math/tex; mode=display">F_i\approx Gm_i\cdot\Sigma_{0\leq j<N}\frac{m_jr_{ij}}{(||r_{ij}||^2+ε^2)^{3/2}} \tag {3}</script><p>&emsp;&emsp;公式$(3)$中，当$ε$取0时，就是原来的公式$(2)$。除此之外，注意公式$(3)$中还去掉了公式$(2)$中的条件判断$i\neq j$，这样带来的另外一个好处就是免去了条件判断语句，这对GPU非常友好，因为GPU擅长的是算术运算，逻辑运算会或多或少地拖慢GPU的并行速度。根据公式$(3)$我们现在得到了某一个天体的引力合力，我们还要根据这个合力计算天体的加速度，接着根据加速度计算天体的速度，最后得到天体的位置向量。由牛顿定律可知，天体加速度$a_i=F_i/m_i$，结合公式$(3)$消去$m_i$，我们可得下面的加速度计算公式$(4)$：</p><script type="math/tex; mode=display">a_i\approx G\cdot \Sigma_{0\leq j<N}\frac{m_jr_{ij}}{(||r_{ij}||^2+ε^2)^{3/2}} \tag {4}</script><p>&emsp;&emsp;对于天体的N-body模拟，我们实际上要计算的就是公式$(4)$。</p><h2 id="2、基于CUDA的N-body实现"><a href="#2、基于CUDA的N-body实现" class="headerlink" title="2、基于CUDA的N-body实现"></a>2、基于CUDA的N-body实现</h2><p>&emsp;&emsp;N-body模拟的all-pairs算法复杂度为$O(N^2)$，这是相对于串行来说的，但是在GPU上我们可以通过并行来消减算法所需的时间，即通过空间上的并行来降低时间上的复杂度。我们要在CUDA上解决一个问题，首先要分析问题，发现该问题潜在的并行性。对于一个天体系统，我们通过分析发现任两个天体$i$和$j$之间的万有引力$f_{ij}$计算不涉及到其他天体的计算结果，即计算是独立的。$N$个天体的星系需要计算的就是$N\times N$大小的矩阵，第$i$行、$j$列的矩阵项为$f_{ij}$。所以一个非常自然的想法就是，通过并行计算每个矩阵项$f_{ij}$，这样看起来理论上花费的时间就是计算一个矩阵项$f_{ij}$的时间，算法的复杂度降为$O(1)$。但是在GPU上实现并行算法时，我们还要考虑内存访问的时间。上面我们提到的想法需要耗费$O(N^2)$量级的内存空间，这是一个非常大的空间复杂度，很可能我们的显卡上并没有这么大的显存，除此之外显存的访问也将明显拖慢我们的并行速度。</p><p>&emsp;&emsp;因此，为了同时考虑时间和空间的开销，我们需要在两者之间做一个平衡。一个非常不错的做法就是给时间和空间各自分配一个$O(N)$的复杂度，相对于$O(N^2)$，$O(N)$是一个极大的算法复杂度提升。我们知道，对于每一个天体，都要遍历$N$个天体计算加速度。因此，我们采用这样的一个策略：对于每个天体，我们串行地计算它的加速度，不同天体之间的加速度并行计算。这个策略不难理解，如下图2所示，横向是时间轴、纵向是空间轴，在时间轴方向上，每个天体的加速度串行计算；在空间轴方向上，不同天体之间独立地并行。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.15/blog/Nbody/1.png" width="80%"></div></p><center> 图2 GPU上纵向并行、横向加速 </center><p>&emsp;&emsp;接下来就考虑如何在CUDA上实现该策略。首先是每一对天体之间引力的加速度计算，我们直接套用前面提到的公式即可，这里需要注意距离向量的计算。因为万有引力是吸引力，因此天体$j$对天体$i$的引力方向是从$i$到$j$的。CUDA的kernel代码如下所示，<strong>可以看到一对天体之间的引力计算需要耗费20次的浮点数运算。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">__device__</span><br><span class="line"><span class="function">float3 <span class="title">bodyPairInteraction</span><span class="params">(float4 pi, float4 pj, float3 ai)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">float3 distVector = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">distVector.x = pj.x - pi.x;</span><br><span class="line">distVector.y = pj.y - pi.y;</span><br><span class="line">distVector.z = pj.z - pi.z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> distSquared = distVector.x * distVector.x + distVector.y * distVector.y</span><br><span class="line">+ distVector.z * distVector.z;</span><br><span class="line">distSquared += getSofteningSquared();</span><br><span class="line"><span class="keyword">float</span> invDist = rsqrtf(distSquared);</span><br><span class="line"><span class="keyword">float</span> invDistCubic = invDist * invDist * invDist;</span><br><span class="line"><span class="keyword">float</span> coff = pj.w * invDistCubic;</span><br><span class="line"></span><br><span class="line">ai.x += distVector.x * coff;</span><br><span class="line">ai.y += distVector.y * coff;</span><br><span class="line">ai.z += distVector.z * coff;</span><br><span class="line"><span class="keyword">return</span> ai;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一个天体占据一个GPU线程，串行地调用上面的bodyPairInteraction函数。这里我们需要考虑内存的访问。CUDA的内存分为三大类：全局内存、共享内存、寄存器内存，访问速度从左到右越来快。寄存器内存就是单个线程占据的局部内存，这里我们仅仅考虑全局内存和共享内存。全局内存的访问速度非常慢，为了性能我们必须考虑这一点。共享内存仅限于同一个线程块内，不同线程块之间的线程没有共享内存这一概念。既然共享内存仅限于同一个线程块，我们就采用一个分块的策略，不同天体计算各自的加速度之间是有数据重用的，先将天体数据预先加载到共享内存，同一个线程块的线程访问这个共享内存做相应的数值计算。但是又引入一个问题，共享内存是有限的，所以对于一个线程块的共享内存，我们不是一次性地将所有天体数据从全局内存加载到共享内存，而是分批次地加载、计算。如下图3所示，设一个线程块有$p$个线程，那么$N$个天体的引力计算被分到$N/p$个线程块，每个线程块分配p个天体数据大小的共享内存，分$N/P$批次串行计算。每次计算前，在同一个线程块内，各个线程相应地从全局内存加载各自对应的天体数据（通过线程id和线程块id、size计算索引）到共享内存，加载完毕之后各自迭代$p$次计算当前批次的天体引力，如下进行下去。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.15/blog/Nbody/2.png" width="80%"></div></p><center> 图3 同一个线程块分批次加载、计算 </center><p>&emsp;&emsp;注意需要在内存加载和引力计算之后插入同步原语，保证需要计算的数据全部已经加载完毕。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">__device__</span><br><span class="line"><span class="function">float3 <span class="title">calcGravitationForce</span><span class="params">(float4 bodyPos, float4 *positions, <span class="keyword">int</span> numTiles, thread_block cta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">extern</span> __shared__ float4 sharedPos[];</span><br><span class="line"></span><br><span class="line">float3 acc = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> tile = <span class="number">0</span>; tile &lt; numTiles; ++tile)</span><br><span class="line">&#123;</span><br><span class="line">sharedPos[threadIdx.x] = positions[tile * blockDim.x + threadIdx.x];</span><br><span class="line">sync(cta);</span><br><span class="line"></span><br><span class="line"><span class="comment">// tile calculation.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> unroll 128</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> index = <span class="number">0</span>; index &lt; blockDim.x; ++index)</span><br><span class="line">&#123;</span><br><span class="line">acc = bodyPairInteraction(bodyPos, sharedPos[index], acc);</span><br><span class="line">&#125;</span><br><span class="line">sync(cta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过上面的计算我们最终得到了引力的加速度数据，然后我们需要根据这个加速度更新天体的速度、位置，最后写入保存相关的数据的内存当中，比较简单，见如下CUDA的kernel代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">__global__</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">integrateBodies</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">float4 * newPos,</span></span></span><br><span class="line"><span class="function"><span class="params">float4 * oldPos,</span></span></span><br><span class="line"><span class="function"><span class="params">float4 *velocity,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">float</span> deltaTime,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">float</span> damping,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> numTiles,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> numBodies)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// get thread block.</span></span><br><span class="line">thread_block cta = this_thread_block();</span><br><span class="line"><span class="keyword">int</span> index = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line"></span><br><span class="line">float4 pos = oldPos[index];</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute acceleration.</span></span><br><span class="line">float3 accel = calcGravitationForce(pos, oldPos, numTiles, cta);</span><br><span class="line"></span><br><span class="line"><span class="comment">// update velocity.</span></span><br><span class="line">float4 vel = velocity[index];</span><br><span class="line">vel.x += accel.x * deltaTime;</span><br><span class="line">vel.y += accel.y * deltaTime;</span><br><span class="line">vel.z += accel.z * deltaTime;</span><br><span class="line">vel.x *= damping;</span><br><span class="line">vel.y *= damping;</span><br><span class="line">vel.z *= damping;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update position.</span></span><br><span class="line">pos.x += vel.x * deltaTime;</span><br><span class="line">pos.y += vel.y * deltaTime;</span><br><span class="line">pos.z += vel.z * deltaTime;</span><br><span class="line"></span><br><span class="line">newPos[index] = pos;</span><br><span class="line">velocity[index] = vel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后我们需要在CPU端做一些内存映射，完成CPU与GPU的交互。这里我才用了双缓冲，即一个缓冲用于写、一个缓冲用于读，因为设置显存缓冲为只读、只写会稍微带来一些性能的提升。此外由于在CUDA模拟之后需要调用OpenGL进行渲染，我这里就采用了OpenGL与CUDA的混合编程，OpenGL和CUDA共享天体数据，这样中间不再需要经过CPU完成数据的传送，而是直接在GPU上模拟、在GPU上读取进行渲染，剩下了不少的内存传输时间。最后千万不要忘了加上cudaDeviceSynchronize语句，确保在CUDA上模拟完，否则因为一般GPU与CPU是不同步，CPU上调用完CUDA的kernel程序之后，会继续执行自己的语句序列，可能导致后面的OpenGL渲染与CUDA的访存冲突，产生一些意外的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">integrateNBodySystem</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">real **devicePosition,</span></span></span><br><span class="line"><span class="function"><span class="params">real *deviceVelocity,</span></span></span><br><span class="line"><span class="function"><span class="params">cudaGraphicsResource **pGRes,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> currentRead,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">float</span> deltaTime,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">float</span> damping,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> numBodies,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> blockSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// map buffers.</span></span><br><span class="line">cudaGraphicsResourceSetMapFlags(pGRes[currentRead],</span><br><span class="line">cudaGraphicsMapFlagsReadOnly);</span><br><span class="line">cudaGraphicsResourceSetMapFlags(pGRes[<span class="number">1</span> - currentRead],</span><br><span class="line">cudaGraphicsMapFlagsWriteDiscard);</span><br><span class="line">cudaGraphicsMapResources(<span class="number">2</span>, &amp;pGRes[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line"><span class="keyword">size_t</span> bytes;</span><br><span class="line">cudaError_t err = cudaGetLastError();</span><br><span class="line">err = cudaGraphicsResourceGetMappedPointer((<span class="keyword">void</span>**)&amp;devicePosition[currentRead],</span><br><span class="line">&amp;bytes, pGRes[currentRead]);</span><br><span class="line">err = cudaGraphicsResourceGetMappedPointer((<span class="keyword">void</span>**)&amp;devicePosition[<span class="number">1</span> - currentRead],</span><br><span class="line">&amp;bytes, pGRes[<span class="number">1</span> - currentRead]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// launch kernel.</span></span><br><span class="line"><span class="keyword">int</span> numBlocks = (numBodies + blockSize - <span class="number">1</span>) / blockSize;</span><br><span class="line"><span class="keyword">int</span> sharedMemSize = blockSize * <span class="number">4</span> * <span class="keyword">sizeof</span>(real);</span><br><span class="line">integrateBodies &lt;&lt; &lt;numBlocks, blockSize, sharedMemSize &gt;&gt; &gt; (</span><br><span class="line">(float4*)devicePosition[<span class="number">1</span> - currentRead],</span><br><span class="line">(float4*)devicePosition[currentRead],</span><br><span class="line">(float4*)deviceVelocity,</span><br><span class="line">deltaTime, damping,</span><br><span class="line">numBlocks, numBodies);</span><br><span class="line">cudaGraphicsUnmapResources(<span class="number">2</span>, &amp;pGRes[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> NBodySystem::simulate(real deltaTime)</span><br><span class="line">&#123;</span><br><span class="line">integrateNBodySystem(</span><br><span class="line">m_devicePosition,</span><br><span class="line">m_deviceVelocity,</span><br><span class="line">m_pGRes,</span><br><span class="line">m_currentRead,</span><br><span class="line">deltaTime,</span><br><span class="line">m_damping,</span><br><span class="line">m_numBodies,</span><br><span class="line">m_blockSize);</span><br><span class="line">cudaDeviceSynchronize();</span><br><span class="line">getLastCudaError(<span class="string">"Kernel execution failed"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// swap buffer.</span></span><br><span class="line"><span class="built_in">std</span>::swap(m_currentRead, m_currentWrite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、粒子渲染-辉光特效"><a href="#3、粒子渲染-辉光特效" class="headerlink" title="3、粒子渲染-辉光特效"></a>3、粒子渲染-辉光特效</h2><p>&emsp;&emsp;在天体模拟之后，我们需要把这些数据都渲染出来。对于每一个天体，我们都把它当成一个粒子，因而采用OpenGL的点精灵绘制，相关的内容比较简单，不再赘述。这里我要讲的是计算机图形学和图形处理结合实现的一种辉光特效技术，这种技术能够带来非常炫酷的渲染效果。这里说的辉光就是明亮区域产生的光晕效果，实际上是因为光线与空气中的介质相互作用，发生了散射。辉光最直接的例子就是太阳周围的光晕效果，这里我们将通过采用图像处理来实现辉光特效。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.15/blog/Nbody/3.png" width="80%"></div></p><center> 图4 无辉光、有辉光的对比 </center><p>&emsp;&emsp;我们将在OpenGL的着色器做相关的后处理，首先需要将场景的全部渲染到两张纹理中，一张是存储正常场景渲染结果，另外一张纹理存储场面渲染结果中的亮色，可以看成是<strong>亮度图</strong>。这里采用OpenGL的multi render target，将场景渲染到多张纹理当中。我们通过像素的rgb与权重向量$(0.2126, 0.7152, 0.0722)$做点乘得到像素的亮度值，以此来衡量一个像素点的亮度，若亮度超过给定的阈值，我们就把该像素存储到亮度图中，供后面的图像处理用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 430 core</span></span><br><span class="line"></span><br><span class="line">uniform sampler2D image;</span><br><span class="line">uniform vec3 baseColor;</span><br><span class="line"></span><br><span class="line">layout(location = <span class="number">0</span>) out vec4 fragColor;</span><br><span class="line">layout(location = <span class="number">1</span>) out vec4 brightColor;</span><br><span class="line"></span><br><span class="line">in vec3 test;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">fragColor = vec4(baseColor, <span class="number">1.0f</span>);</span><br><span class="line">fragColor = texture(image, gl_PointCoord) * fragColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glow map.</span></span><br><span class="line"><span class="keyword">float</span> brightness = dot(fragColor.rgb, vec3(<span class="number">0.2126</span>, <span class="number">0.7152</span>, <span class="number">0.0722</span>));</span><br><span class="line"><span class="keyword">if</span>(brightness &gt; <span class="number">0.3f</span>)</span><br><span class="line">brightColor = vec4(fragColor.rgb, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来我们就对亮度图做一个高斯模糊处理，这属于图形处理的范畴。对于纹理的每一个像素，我们采样周围的像素，采样的范围取决于我们给定的模糊kernel半径，然后将所有采样得到的像素值根据高斯函数的做一个加权和，这样就完成了整个高斯模糊的过程。高斯函数其实就是我们熟悉的正太分布函数，它的特点就是中间的函数值大，然后向两端减少，两端是对称的。对于一个二维的图像，我们需要采用二维的高斯函数来做一个卷积处理。二维的高斯函数如下所示：</p><script type="math/tex; mode=display">G(x,y)=\frac1{2\pi \sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}} \tag {5}</script><p>&emsp;&emsp;<a href="http://dev.theomader.com/gaussian-kernel-calculator/" target="_blank" rel="noopener">这个</a>网站提供了一个简单易用的高斯核函数计算工具。直接做二维的卷积非常简单，然而这里又需要考虑一个性能的问题，对于离线的图形处理来说，可能直接采样二维的邻域像素然后做加权和没什么太大的关系。但是对于实时渲染来说，这点很关键。因为$O(N^2)$和$O(N)$的差别是很大的，例如高斯模糊的kernel大小为$32\times 32$，那么对于每个像素，我们必须从周围区域采样$1024$个像素值，这仅仅针对于一个像素而言。</p><p>&emsp;&emsp;高斯方程有个非常巧妙的特性，它允许我们把二维方程分解为两个更小的方程：一个描述水平权重，另一个描述垂直权重。我们首先用水平权重在整个纹理上进行水平模糊，然后在经改变的纹理上进行垂直模糊，最后得到结果与原来是一样的，但是可以大大提升算法的性能，因为我们现在只需做32+32次采样了。这种方法叫做两步高斯模糊，整个算法的过程如下图5所示。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.15/blog/Nbody/4.png" width="80%"></div></p><center> 图5 两步高斯模糊 </center><p>&emsp;&emsp;这里我实现的高斯模糊卷积核大小为$15\times 15$，采用两步模糊，只需采样30次。同时为了避免在GPU上做for循环，这里我直接将循环做一个展开。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line">in vec2 Texcoord;</span><br><span class="line"></span><br><span class="line">layout(location = <span class="number">0</span>) out vec4 fragColor;</span><br><span class="line">layout(location = <span class="number">1</span>) out vec4 brightColor;</span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">int</span> horizontal;</span><br><span class="line">uniform sampler2D Color;</span><br><span class="line">uniform sampler2D Bright;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> weight[<span class="number">8</span>] = <span class="keyword">float</span>[] (<span class="number">0.197448</span>, <span class="number">0.174697</span>, <span class="number">0.120999</span>, <span class="number">0.065602</span>, <span class="number">0.02784</span>, <span class="number">0.009246</span>, <span class="number">0.002403</span>, <span class="number">0.000489</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vec2 tex_offset = <span class="number">1.0</span> / textureSize(Bright, <span class="number">0</span>); <span class="comment">// gets size of single texel</span></span><br><span class="line">    vec3 result = texture(Bright, Texcoord).rgb * weight[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">result += texture(Bright, Texcoord + vec2(tex_offset.x * <span class="number">1</span> * horizontal, tex_offset.y * <span class="number">1</span> * (<span class="number">1</span>-horizontal))).rgb * weight[<span class="number">1</span>];</span><br><span class="line">    result += texture(Bright, Texcoord - vec2(tex_offset.x * <span class="number">1</span> * horizontal, tex_offset.y * <span class="number">1</span> * (<span class="number">1</span>-horizontal))).rgb * weight[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">result += texture(Bright, Texcoord + vec2(tex_offset.x * <span class="number">2</span> * horizontal, tex_offset.y * <span class="number">2</span> * (<span class="number">1</span>-horizontal))).rgb * weight[<span class="number">2</span>];</span><br><span class="line">    result += texture(Bright, Texcoord - vec2(tex_offset.x * <span class="number">2</span> * horizontal, tex_offset.y * <span class="number">2</span> * (<span class="number">1</span>-horizontal))).rgb * weight[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">result += texture(Bright, Texcoord + vec2(tex_offset.x * <span class="number">3</span> * horizontal, tex_offset.y * <span class="number">3</span> * (<span class="number">1</span>-horizontal))).rgb * weight[<span class="number">3</span>];</span><br><span class="line">    result += texture(Bright, Texcoord - vec2(tex_offset.x * <span class="number">3</span> * horizontal, tex_offset.y * <span class="number">3</span> * (<span class="number">1</span>-horizontal))).rgb * weight[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">result += texture(Bright, Texcoord + vec2(tex_offset.x * <span class="number">4</span> * horizontal, tex_offset.y * <span class="number">4</span> * (<span class="number">1</span>-horizontal))).rgb * weight[<span class="number">4</span>];</span><br><span class="line">    result += texture(Bright, Texcoord - vec2(tex_offset.x * <span class="number">4</span> * horizontal, tex_offset.y * <span class="number">4</span> * (<span class="number">1</span>-horizontal))).rgb * weight[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">result += texture(Bright, Texcoord + vec2(tex_offset.x * <span class="number">5</span> * horizontal, tex_offset.y * <span class="number">5</span> * (<span class="number">1</span>-horizontal))).rgb * weight[<span class="number">5</span>];</span><br><span class="line">    result += texture(Bright, Texcoord - vec2(tex_offset.x * <span class="number">5</span> * horizontal, tex_offset.y * <span class="number">5</span> * (<span class="number">1</span>-horizontal))).rgb * weight[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">result += texture(Bright, Texcoord + vec2(tex_offset.x * <span class="number">6</span> * horizontal, tex_offset.y * <span class="number">6</span> * (<span class="number">1</span>-horizontal))).rgb * weight[<span class="number">6</span>];</span><br><span class="line">    result += texture(Bright, Texcoord - vec2(tex_offset.x * <span class="number">6</span> * horizontal, tex_offset.y * <span class="number">6</span> * (<span class="number">1</span>-horizontal))).rgb * weight[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">result += texture(Bright, Texcoord + vec2(tex_offset.x * <span class="number">7</span> * horizontal, tex_offset.y * <span class="number">7</span> * (<span class="number">1</span>-horizontal))).rgb * weight[<span class="number">7</span>];</span><br><span class="line">    result += texture(Bright, Texcoord - vec2(tex_offset.x * <span class="number">7</span> * horizontal, tex_offset.y * <span class="number">7</span> * (<span class="number">1</span>-horizontal))).rgb * weight[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">    brightColor = vec4(result, <span class="number">1.0</span>);</span><br><span class="line">fragColor = texture(Color, Texcoord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;采用了两步高斯模糊之后，我们需要模糊多次，一个比较好得模糊次数是10，水平方向和垂直方向各模糊5次。为了实现两步高斯交替模糊，这里又再一次地采用了双缓冲机制，这是因为OpenGL只支持对uniform纹理的读取。具体代码见下面所示。通过以上步骤我们就得到了一张模拟的亮度图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> horizontal = <span class="literal">true</span>;</span><br><span class="line">Shader::ptr blurShader = ShaderMgr::getSingleton()-&gt;getShader(m_gaussianShaderIndex);</span><br><span class="line">blurShader-&gt;bind();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> texStr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_blurTimes; ++i)</span><br><span class="line">&#123;</span><br><span class="line">m_framebuffer[m_writeIndex]-&gt;bind();</span><br><span class="line">glDisable(GL_CULL_FACE);</span><br><span class="line">glDisable(GL_DEPTH_TEST);</span><br><span class="line">glDisable(GL_BLEND);</span><br><span class="line">glClearColor(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">blurShader-&gt;setInt(<span class="string">"Color"</span>, <span class="number">0</span>);</span><br><span class="line">blurShader-&gt;setInt(<span class="string">"Bright"</span>, <span class="number">1</span>);</span><br><span class="line">blurShader-&gt;setInt(<span class="string">"horizontal"</span>, horizontal);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> iss;</span><br><span class="line">iss &lt;&lt; m_readIndex;</span><br><span class="line">TextureMgr::getSingleton()-&gt;bindTexture(<span class="string">"Color"</span> + iss.str(), <span class="number">0</span>);</span><br><span class="line">TextureMgr::getSingleton()-&gt;bindTexture(<span class="string">"BrightColor"</span> + iss.str(), <span class="number">1</span>);</span><br><span class="line">MeshMgr::getSingleton()-&gt;drawMesh(m_screenQuadIndex, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">std</span>::swap(m_readIndex, m_writeIndex);</span><br><span class="line">horizontal = !horizontal;</span><br><span class="line">&#125;</span><br><span class="line">blurShader-&gt;unBind();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后为了实现辉光效果，我们需要将模糊的亮度图叠加到场景渲染结果上，这样辉光特效就制作好了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line">in vec2 Texcoord;</span><br><span class="line"></span><br><span class="line">out vec4 fragColor;</span><br><span class="line"></span><br><span class="line">uniform sampler2D Color;</span><br><span class="line">uniform sampler2D BrightColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">vec3 hdrColor = (texture(Color, Texcoord).rgb + texture(BrightColor, Texcoord).rgb);</span><br><span class="line">    fragColor = vec4(hdrColor, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;下面是无辉光特效、有辉光特效的一个对比图，可以看到差别非常明显，辉光效果可以极大地提升场景中的效果。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.15/blog/Nbody/5.jpg" width="99%"></div></p><center> 图6 无辉光（上）、有辉光（下）对比 </center><h2 id="4、模拟效果"><a href="#4、模拟效果" class="headerlink" title="4、模拟效果"></a>4、模拟效果</h2><p>&emsp;&emsp;文章开头模拟的是银河星系。下面这个是银河星系与仙女座星系碰撞。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.15/blog/Nbody/ret1.gif" width="99%"></div></p><p>&emsp;&emsp;星系膨胀。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.15/blog/Nbody/ret2.gif" width="99%"></div></p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>$[1]$ Aarseth, S. 2003. Gravitational N-Body Simulations. Cambridge University Press. Barnes, J., and P. Hut. 1986. “A Hierarchical O(n log n) Force Calculation Algorithm.” Nature 324.</p><p>$[2]$ Greengard, Leslie F., and Jingfang Huang. 2002. “A New Version of the Fast Multipole Method for Screened Coulomb Interactions in Three Dimensions.” Journal of Computational Physics 180(2), pp. 642–658.</p><p>$[3]$ Darden, T., D. York, and L. Pederson. 1993. “Particle Mesh Ewald: An N log(N) Method for Ewald Sums in Large Systems.” Journal of Chemical Physics 98(12), p. 10089.</p><p>$[4]$ <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#abstract" target="_blank" rel="noopener">CUDA C Programming Guide</a></p><p>$[5]$ <a href="http://bima.astro.umd.edu/nemo/archive/#dubinski" target="_blank" rel="noopener">N-Body Data Archive</a></p><p>$[6]$ Lars Nyland, Mark Harris, Jan Prins.《GPU Germ3》 Chapter 31: Fast N-Body Simulation with CUDA.</p></div>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> N-body </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> N-body </tag>
            
            <tag> Glow effect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>体素化Voxelization：基于GPU的三维体素化</title>
      <link href="/2019/06/11/Voxelization/"/>
      <url>/2019/06/11/Voxelization/</url>
      
        <content type="html"><![CDATA[<p>本篇文章主要是关于三维网格模型的基于GPU并行的体素化算法，这个算法我是偶然从NVIDIA官网上看到的。基于GPU的体素化算法巧妙地借助了渲染流程的光栅化处理，将整个体素化的过程并行化，速度极快，缺点就是占用的内存较高。相关的完整代码请看<a href="https://github.com/ZeusYang/PositionBasedFluid" target="_blank" rel="noopener">这个链接</a>中的Renderer目录下的Voxelization.h文件和Voxelization.cpp文件。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/header.png" width="70%"></div></p><a id="more"></a><ul><li>体素化</li><li>修补裂缝</li><li>修补孔洞</li><li>参考资料</li></ul><p>&emsp;&emsp;<strong>在基于位置动力学的物理模拟中，所有要模拟的物体都由一组粒子来表示，每个粒子都是一个给定半径大小的球体，对于固体这类的物体，粒子通常是紧密相连的。为此，为了实现基于位置动力学的物理模拟，我们需要采用一种算法将网格物体的三角网格模型用一个个粒子表示</strong>，这个并不是简单地取网格模型的所有顶点就行，因为我们需要紧密连接的粒子，面片网格模型的顶点通常是稀疏的。这个过程其实就是体素化，三维体素是二维像素的三维扩展，体素的基本单元不再是二维的正方形，而是三维的立方体，立方体的边长决定了体素化的分辨率，通常边长越长，则分辨率越低。将网格体素化后我们得到了一组体素的中心顶点位置，可将其用于后续的基于位置动力学的物理模拟当中。</p><p>&emsp;&emsp;目前常用的体素化方法大都是基于CPU的，这类方法通常是将射线与物体求交，根据是奇数个交点还是偶数个交点来判断当前的体素是否在物体的内部。在没有采用特殊的数据结构时，每次求交都要遍历一次网格模型的所有三角形，效率非常低。在采用了八叉树加速之后，速度有所提升，但随着模型的三角形面片数增加，串行的体素化算法耗费的时间越来越长。我没有采用CPU串行的体素化方法，而是采用了基于GPU并行的体素化算法，这个算法我是偶然从NVIDIA官网上看到的。基于GPU的体素化算法巧妙地借助了渲染流程的光栅化处理，将整个体素化的过程并行化，速度极快，缺点就是占用的内存较高。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/1.jpg" width="60%"><br>    <center> 图1 三维体素模型 </center></div></p><h1 id="一、体素化"><a href="#一、体素化" class="headerlink" title="一、体素化"></a>一、体素化</h1><p>&emsp;&emsp;基于GPU的三维体素化大致思想就是：首先计算出需要体素化模型的AABB包围盒，然后将模型投影到AABB包围盒的某个平面上，经过渲染管线的光栅化插值操作，我们可以在片元着色器得到每个像素点对应的世界空间的顶点坐标，根据这个顶点坐标标记三维空间数组（这个三维空间数组就是根据体素划分的空间序列）的相应位置，最后在CPU端读出这个三维空间数组，若当前的数组位置有标记，则将该数组位置对应的立方体作为一个体素。可以看到，整个流程思路非常清晰，但是还需要借助一些手段修正算法存在的缺陷，这个在后面会提到。</p><p>&emsp;&emsp;首先就是计算网格模型的AABB包围盒，在导入模型时获取$x$、$y$、$z$轴分量的最大值和最小值，从而得到包围盒的最大顶点和最小顶点。这个比较简单，不再赘述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bounding box.</span></span><br><span class="line"><span class="keyword">if</span> (mesh-&gt;mVertices[x].x &lt; m_min.x)</span><br><span class="line">m_min.x = mesh-&gt;mVertices[x].x;</span><br><span class="line"><span class="keyword">if</span> (mesh-&gt;mVertices[x].y &lt; m_min.y)</span><br><span class="line">m_min.y = mesh-&gt;mVertices[x].y;</span><br><span class="line"><span class="keyword">if</span> (mesh-&gt;mVertices[x].z &lt; m_min.z)</span><br><span class="line">m_min.z = mesh-&gt;mVertices[x].z;</span><br><span class="line"><span class="keyword">if</span> (mesh-&gt;mVertices[x].x &gt; m_max.x)</span><br><span class="line">m_max.x = mesh-&gt;mVertices[x].x;</span><br><span class="line"><span class="keyword">if</span> (mesh-&gt;mVertices[x].y &gt; m_max.y)</span><br><span class="line">m_max.y = mesh-&gt;mVertices[x].y;</span><br><span class="line"><span class="keyword">if</span> (mesh-&gt;mVertices[x].z &gt; m_max.z)</span><br><span class="line">m_max.z = mesh-&gt;mVertices[x].z;</span><br></pre></td></tr></table></figure><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/2.png" width="60%"></div></p><center> 图2 模型包围盒 </center><p>&emsp;&emsp;获取了模型的包围盒之后，我们就需要根据这个包围盒设置我们的观察角度和投影平面，这关系到后面的体素化结果。同时为了保证正确地体素化模型，我们采用的投影方式是<strong>正交投影</strong>。首先我们要选择一个观察方向和投影平面，AABB包围盒有六个面，其中前和后、上和下、左和右的投影结果是一样的，因此实际的选择只有三个平面，分别是前、上、右（或者后、下、左）。显然一个物体投影到这个三个平面上的结果都不一样，目前我们暂时先选择投影到前面这个平面上，摄像机的视线朝向z轴的负方向。注意正确地设置摄像机的位置，否则什么看不到。既然我们选择投影到前面这个平面上，我们就设置摄像机的位置在包围盒前面这个平面的中心再往前一点。同时了为了确保模型全部投影到屏幕上，我们设置的正交投影平面比选定的包围盒平面稍微大一点点。具体代码如下所示：</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/4.png" width="60%"></div></p><center> 图3 三个面上的投影结果 </center><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bounding box and resolution.</span></span><br><span class="line">glm::vec3 min, max;</span><br><span class="line">glm::ivec3 resolution;</span><br><span class="line">target-&gt;getAABB(min, max);</span><br><span class="line"></span><br><span class="line">glm::<span class="function">vec3 <span class="title">range</span><span class="params">(max.x - min.x, max.y - min.y, max.z - min.z)</span></span>;</span><br><span class="line">resolution.x = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(range.x / step);</span><br><span class="line">resolution.y = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(range.y / step);</span><br><span class="line">resolution.z = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(range.z / step);</span><br><span class="line"><span class="keyword">int</span> length = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(resolution.x * resolution.y * resolution.z);</span><br><span class="line"></span><br><span class="line"><span class="comment">// camera</span></span><br><span class="line">glm::vec3 cameraPos;</span><br><span class="line">cameraPos.x = (min.x + max.x) * <span class="number">0.5f</span>;</span><br><span class="line">cameraPos.y = (min.y + max.y) * <span class="number">0.5f</span>;</span><br><span class="line">cameraPos.z = max.z + <span class="number">0.2f</span>;</span><br><span class="line">FPSCamera::<span class="function">ptr <span class="title">camera</span><span class="params">(<span class="keyword">new</span> FPSCamera(cameraPos))</span></span>;</span><br><span class="line">camera-&gt;lookAt(glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>));</span><br><span class="line">camera-&gt;setOrthographicProject(-range.x * <span class="number">0.51</span>, +range.x * <span class="number">0.51</span>, -range.y * <span class="number">0.51</span>, +range.y * <span class="number">0.51</span>, <span class="number">0.1</span>, range.z * <span class="number">1.2f</span> + <span class="number">0.2f</span>);</span><br></pre></td></tr></table></figure><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/3.png" width="60%"></div></p><center> 图4 包围盒投影平面 </center><p>&emsp;&emsp;设置好投影矩阵和视图矩阵之后，我们需要申请一个着色器可写的缓冲，这个缓冲的大小等于AABB包围盒的分辨率，在片元着色器阶段我们需要根据当前片元的世界空间位置对这个缓冲做标记，表示该缓冲位置上有一个体素。我们采用OpenGL的GL_SHADER_STORAGE_BUFFER，这是一个着色器可读写的缓冲类型。申请缓冲之后，将缓冲全部初始化为0。然后将需要体素化的网格模型送入渲染管线进行渲染。在片元着色器中，将每个片元的世界空间位置对应的缓冲位置加1。最后在CPU端读出缓冲内容，缓冲值大于0时，则表示该位置有一个体素。CPU端的整个流程代码如下所示。这里需要特别注意的是，我们应该关闭深度测试和背面剔除，保证模型的全面三角形都进入片元着色器，确保所有的三角形不被剔除，从而使得全部的三角形都被处理，最后得到正确的体素化结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Voxelization::voxelize(Drawable* target, <span class="keyword">const</span> <span class="keyword">float</span> &amp; step, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt;&amp; ret)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// shader</span></span><br><span class="line">ShaderMgr::ptr shaderMgr = ShaderMgr::getSingleton();</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> voxelizeCount = shaderMgr-&gt;loadShader(<span class="string">"voxelizeCount"</span>,</span><br><span class="line"><span class="string">"./glsl/voxelizeCount.vert"</span>, <span class="string">"./glsl/voxelizeCount.frag"</span>);</span><br><span class="line">Shader::ptr shader = shaderMgr-&gt;getShader(voxelizeCount);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bounding box and resolution.</span></span><br><span class="line">glm::vec3 min, max;</span><br><span class="line">glm::ivec3 resolution;</span><br><span class="line">target-&gt;getAABB(min, max);</span><br><span class="line"></span><br><span class="line">glm::<span class="function">vec3 <span class="title">range</span><span class="params">(max.x - min.x, max.y - min.y, max.z - min.z)</span></span>;</span><br><span class="line">resolution.x = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(range.x / step) + <span class="number">1</span>;</span><br><span class="line">resolution.y = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(range.y / step) + <span class="number">1</span>;</span><br><span class="line">resolution.z = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(range.z / step) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> length = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(resolution.x * resolution.y * resolution.z);</span><br><span class="line"></span><br><span class="line"><span class="comment">// camera</span></span><br><span class="line">glm::vec3 cameraPos;</span><br><span class="line">cameraPos.x = (min.x + max.x) * <span class="number">0.5f</span>;</span><br><span class="line">cameraPos.y = (min.y + max.y) * <span class="number">0.5f</span>;</span><br><span class="line">cameraPos.z = max.z + <span class="number">0.2f</span>;</span><br><span class="line">FPSCamera::<span class="function">ptr <span class="title">camera</span><span class="params">(<span class="keyword">new</span> FPSCamera(cameraPos))</span></span>;</span><br><span class="line">camera-&gt;lookAt(glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>));</span><br><span class="line">camera-&gt;setOrthographicProject(-range.x * <span class="number">0.51</span>, +range.x * <span class="number">0.51</span>, -range.y * <span class="number">0.51</span>, +range.y * <span class="number">0.51</span>, <span class="number">0.1</span>, range.z * <span class="number">1.2f</span> + <span class="number">0.2f</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// polygon mode.</span></span><br><span class="line">glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);</span><br><span class="line">glDisable(GL_CULL_FACE);</span><br><span class="line">glDisable(GL_DEPTH_TEST);</span><br><span class="line">glClearColor(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// generate ssbo.</span></span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;m_cntBuffer);</span><br><span class="line">glBindBuffer(GL_SHADER_STORAGE_BUFFER, m_cntBuffer);</span><br><span class="line">glBufferData(GL_SHADER_STORAGE_BUFFER, length * <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="literal">nullptr</span>, GL_STATIC_DRAW);</span><br><span class="line">glBindBufferBase(GL_SHADER_STORAGE_BUFFER, <span class="number">0</span>, m_cntBuffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind shader and ssbo.</span></span><br><span class="line">shader-&gt;bind();</span><br><span class="line">shader-&gt;setVec3(<span class="string">"boxMin"</span>, min);</span><br><span class="line">shader-&gt;setFloat(<span class="string">"step"</span>, step);</span><br><span class="line">shader-&gt;setVec3(<span class="string">"resolution"</span>, resolution);</span><br><span class="line"><span class="keyword">int</span> *writePtr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(glMapBuffer(GL_SHADER_STORAGE_BUFFER, GL_WRITE_ONLY));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; length; ++x)</span><br><span class="line">&#123;</span><br><span class="line">writePtr[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!glUnmapBuffer(GL_SHADER_STORAGE_BUFFER))</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"unMap error\n"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// draw and count.</span></span><br><span class="line">target-&gt;render(camera, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, shader);</span><br><span class="line">glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get count buffer.</span></span><br><span class="line">glBindBuffer(GL_SHADER_STORAGE_BUFFER, m_cntBuffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *readPtr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(glMapBuffer(GL_SHADER_STORAGE_BUFFER, GL_READ_ONLY));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (readPtr != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; length; ++x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*(readPtr + x) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> iy = x / (resolution.x * resolution.z);</span><br><span class="line"><span class="keyword">int</span> iz = (x - iy * resolution.x * resolution.z) / (resolution.x);</span><br><span class="line"><span class="keyword">int</span> ix = x - iy * resolution.x * resolution.z - iz * resolution.x;</span><br><span class="line">ret.push_back(min + glm::vec3(ix * step, iy * step, iz * step));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"nullptr error!\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glUnmapBuffer(m_cntBuffer);</span><br><span class="line">glBindBuffer(GL_SHADER_STORAGE_BUFFER, <span class="number">0</span>);</span><br><span class="line">glDeleteBuffers(<span class="number">1</span>, &amp;m_cntBuffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来就需要在着色器中做一些操作。首先是顶点着色器，在顶点着色器中并没有什么复杂的操作，我们需要将当前的顶点位置传到片元着色器，借助渲染管线的光栅化功能，从而在片元着色器中得到每个片元对应的世界空间位置。下面顶点着色器的代码，其余部分乘上视图矩阵和投影矩阵就不说了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 430 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"></span><br><span class="line">out vec3 FragPos;</span><br><span class="line"></span><br><span class="line">uniform mat4 viewMatrix;</span><br><span class="line">uniform mat4 projectMatrix;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">FragPos = position;</span><br><span class="line">gl_Position = projectMatrix * viewMatrix * vec4(position,<span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;中间经过光栅化处理，我们在片元着色器得到每个片元的世界空间坐标。根据这个世界空间的坐标去索引计数缓冲，注意这里采用了GLSL的原子操作函数atmoicAdd，避免GPU线程之间的写冲突。缓冲下标索引的计算基本就是根据体素的大小和包围盒来确定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 430 core</span></span><br><span class="line"></span><br><span class="line">in vec3 FragPos;</span><br><span class="line"></span><br><span class="line">layout (std430, binding = <span class="number">0</span>) buffer CountBuffer&#123;</span><br><span class="line">    <span class="keyword">int</span> cnts[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> step;</span><br><span class="line">uniform vec3 boxMin;</span><br><span class="line">uniform vec3 resolution;</span><br><span class="line"></span><br><span class="line">out vec4 color;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="keyword">int</span>((FragPos.x - boxMin.x)/step);</span><br><span class="line"><span class="keyword">int</span> y = <span class="keyword">int</span>((FragPos.y - boxMin.y)/step);</span><br><span class="line"><span class="keyword">int</span> z = <span class="keyword">int</span>((FragPos.z - boxMin.z)/step);</span><br><span class="line"><span class="keyword">int</span> index = <span class="keyword">int</span>(y * (resolution.z * resolution.x) + z * resolution.x + x);</span><br><span class="line">atomicAdd(cnts[index], <span class="number">1</span>);</span><br><span class="line">color = vec4(<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后下面就是我实现的体素化效果，每个体素用一个立方体绘制，当然也可以用球体绘制。看起来颇有游戏《我的世界》的风格。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/7.png" width="60%"></div></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/6.png" width="60%"></div></p><h1 id="二、修补裂缝"><a href="#二、修补裂缝" class="headerlink" title="二、修补裂缝"></a>二、修补裂缝</h1><p>&emsp;&emsp;上面的实现效果看起来貌似非常不错，但是却存在一个非常严重的问题。前面我们在选择投影平面的时候固定投影在了z轴方向的包围盒平面，这是问题产生的根源。因为模型的每个三角形面片在每个包围盒投影面上的投影结果都不同，若当前的三角形与选取的投影面垂直，那么三角形投影到平面上的将是一条直线，这丢失了很多信息，从而导致裂缝的产生。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/8.jpg" width="80%"></div></p><center> 图5 不同投影平面的体素化结果 </center><p>&emsp;&emsp;图5中，左图选取的投影面是摄像机在右边，朝向坐标，这时光栅化得到的结果很好，因而体素化的结果也很好。但是右边的这张图选取的投影面是摄像机在上面，朝向下边，这时光栅化得到的几何面片较少，很多相邻的位置都被投影到了一个片元像素，一些地方没有被体素化，从而导致了裂缝的产生！下面是我实现的程序产生的裂缝，选取的投影方向是z轴方向，下图中的红框部分的几何面片几乎平行于xz平面，从而导致投影光栅化产生的是一个被“压缩“的结果。由于裂缝非常明显且几乎必然会产生（因为通常模型都很复杂，三角形面片朝向很随机），因此有必要采取一些措施来修补这些裂缝。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/10.png" width="60%"></div></p><center> 图6 根据前面步骤产生的裂缝 </center>&emsp;&emsp;如前面的图3所示，每个三角形面片在不同包围盒投影面上的投影结果不同，根据三角形的朝向不同，投影到平面上的三角形大小也各不相同。裂缝产生的原因就是因为投影到平面上的三角形面积被”压缩“了，因此我们需要选取一个投影方向，在该投影方向上三角形的投影面积最大，这样就能够确保所有的三角形面片被充分地体素化，从而使得裂缝小时。<div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/11.png" width="80%"><center> 图7 分别投影到包围盒的右、上、前平面上 </center><p>&emsp;&emsp;因此，我们首先创建三个投影摄像机，将物体分别投影到沿着$x$、$y$、$z$轴的平面上，如图7所示，用以后面着色器中根据三角形的投影面积做选择。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cameras</span></span><br><span class="line"><span class="keyword">float</span> offset = <span class="number">0.2f</span>;</span><br><span class="line">glm::vec3 cameraPosZ, cameraPosX, cameraPosY;</span><br><span class="line"><span class="comment">// looking along z axis.</span></span><br><span class="line">cameraPosZ.x = (min.x + max.x) * <span class="number">0.5f</span>;</span><br><span class="line">cameraPosZ.y = (min.y + max.y) * <span class="number">0.5f</span>;</span><br><span class="line">cameraPosZ.z = max.z + offset;</span><br><span class="line">FPSCamera::<span class="function">ptr <span class="title">cameraZ</span><span class="params">(<span class="keyword">new</span> FPSCamera(cameraPosZ))</span></span>;</span><br><span class="line">cameraZ-&gt;lookAt(glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>), Camera3D::LocalUp);</span><br><span class="line">cameraZ-&gt;setOrthographicProject(-range.x * <span class="number">0.51</span>, +range.x * <span class="number">0.51</span>, -range.y * <span class="number">0.51</span>,</span><br><span class="line">+range.y * <span class="number">0.51</span>, <span class="number">0.1</span>, range.z * <span class="number">1.2f</span> + offset);</span><br><span class="line"><span class="comment">// looking along x axis.</span></span><br><span class="line">cameraPosX.x = max.x + offset;</span><br><span class="line">cameraPosX.y = (min.y + max.y) * <span class="number">0.5f</span>;</span><br><span class="line">cameraPosX.z = (min.z + max.z) * <span class="number">0.5f</span>;</span><br><span class="line">FPSCamera::<span class="function">ptr <span class="title">cameraX</span><span class="params">(<span class="keyword">new</span> FPSCamera(cameraPosX))</span></span>;</span><br><span class="line">cameraX-&gt;lookAt(glm::vec3(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), Camera3D::LocalUp);</span><br><span class="line">cameraX-&gt;setOrthographicProject(-range.z * <span class="number">0.51</span>, +range.z * <span class="number">0.51</span>, -range.y * <span class="number">0.51</span>,</span><br><span class="line">+range.y * <span class="number">0.51</span>, <span class="number">0.1</span>, range.x * <span class="number">1.2f</span> + offset);</span><br><span class="line"><span class="comment">// looking along y axis.</span></span><br><span class="line">cameraPosY.x = (min.x + max.x) * <span class="number">0.5f</span>;</span><br><span class="line">cameraPosY.y = max.y + offset;</span><br><span class="line">cameraPosY.z = (min.z + max.z) * <span class="number">0.5f</span>;</span><br><span class="line">FPSCamera::<span class="function">ptr <span class="title">cameraY</span><span class="params">(<span class="keyword">new</span> FPSCamera(cameraPosY))</span></span>;</span><br><span class="line">cameraY-&gt;lookAt(glm::vec3(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>), glm::vec3(<span class="number">0</span>, <span class="number">1.0</span>, <span class="number">0.001</span>));</span><br><span class="line">cameraY-&gt;setOrthographicProject(-range.x * <span class="number">0.51</span>, +range.x * <span class="number">0.51</span>, -range.z * <span class="number">0.51</span>,</span><br><span class="line">+range.z * <span class="number">0.51</span>, <span class="number">0.1</span>, range.y * <span class="number">1.2f</span> + offset);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">shader-&gt;setMat4(<span class="string">"viewProject[0]"</span>, cameraX-&gt;getProjectMatrix() * cameraX-&gt;getViewMatrix());</span><br><span class="line">shader-&gt;setMat4(<span class="string">"viewProject[1]"</span>, cameraY-&gt;getProjectMatrix() * cameraY-&gt;getViewMatrix());</span><br><span class="line">shader-&gt;setMat4(<span class="string">"viewProject[2]"</span>, cameraZ-&gt;getProjectMatrix() * cameraZ-&gt;getViewMatrix());</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来我们将用到<strong>几何着色器</strong>，几何着色器阶段在顶点着色器之后、光栅化之前，它根据给定的输入图元和输出图元进行相关的几何图元操作，正好我们可以接用它来根据三角形的投影面积选择采用哪一个投影相机。这里有一个技巧，直观上我们说是根据三角形的投影面积来渲染采用哪个投影相机，实际上没有必要真正地去计算三角形的投影面积，<strong>我们可以直接根据当前三角形的世界空间法线朝向来决定投影方向</strong>。举个例子，当法线向量的x分量比其余两个分量大时，则当前的三角形肯定投影到x轴方向的投影平面上的面积更大。<strong>更深入的理解：设法线向量为$n=(nx,ny,nz)$，我们将法线向量$n$与$(1,0,0)$、$(0,1,0)$、$(0,0,1)$分别做点乘，结果为$nx$、$ny$、$nz$，而法线向量分别与该三个基向量点乘的意义为法线向量在$x$、$y$、$z$轴上的投影值，该值越大则三角形投影到该平面上的面积也越大。所以，我们直接根据最大的法线分量来选择采用哪个投影相机</strong>。如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">selectViewProject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vec3 p1 = gl_in[<span class="number">1</span>].gl_Position.xyz - gl_in[<span class="number">0</span>].gl_Position.xyz;</span><br><span class="line">vec3 p2 = gl_in[<span class="number">2</span>].gl_Position.xyz - gl_in[<span class="number">0</span>].gl_Position.xyz;</span><br><span class="line">vec3 faceNormal = cross(p1, p2);</span><br><span class="line"><span class="keyword">float</span> nDX = <span class="built_in">abs</span>(faceNormal.x);</span><br><span class="line"><span class="keyword">float</span> nDY = <span class="built_in">abs</span>(faceNormal.y);</span><br><span class="line"><span class="keyword">float</span> nDZ = <span class="built_in">abs</span>(faceNormal.z);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( nDX &gt; nDY &amp;&amp; nDX &gt; nDZ )</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( nDY &gt; nDX &amp;&amp; nDY &gt; nDZ  )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后我们将上述的代码应用到我们的几何着色器中，因为视图投影过程挪到了几何着色器阶段，所以顶点着色器直接输入顶点的位置，不做任何变换。几何着色器设置输入图元为三角形，输出图元为最大顶点数为3的三角形带，设置一个viewProject的uniform数组。通过几何着色器，我们对模型的每个三角形面片都做了一个投影选择的处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vertex shader</span></span><br><span class="line"><span class="meta">#version 430 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">gl_Position = vec4(position, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// geometry shader</span></span><br><span class="line"><span class="meta">#version 430 core</span></span><br><span class="line">layout (triangles) in;</span><br><span class="line">layout (triangle_strip, max_vertices = <span class="number">3</span>) out;</span><br><span class="line"></span><br><span class="line">out vec3 FragPos;</span><br><span class="line"></span><br><span class="line">uniform mat4 viewProject[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">uint <span class="title">selectViewProject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vec3 p1 = gl_in[<span class="number">1</span>].gl_Position.xyz - gl_in[<span class="number">0</span>].gl_Position.xyz;</span><br><span class="line">vec3 p2 = gl_in[<span class="number">2</span>].gl_Position.xyz - gl_in[<span class="number">0</span>].gl_Position.xyz;</span><br><span class="line">vec3 faceNormal = cross(p1, p2);</span><br><span class="line"><span class="keyword">float</span> nDX = <span class="built_in">abs</span>(faceNormal.x);</span><br><span class="line"><span class="keyword">float</span> nDY = <span class="built_in">abs</span>(faceNormal.y);</span><br><span class="line"><span class="keyword">float</span> nDZ = <span class="built_in">abs</span>(faceNormal.z);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( nDX &gt; nDY &amp;&amp; nDX &gt; nDZ )</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( nDY &gt; nDX &amp;&amp; nDY &gt; nDZ  )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">uint projectIndex = selectViewProject();</span><br><span class="line">FragPos = gl_in[<span class="number">0</span>].gl_Position.xyz;</span><br><span class="line">gl_Position = viewProject[projectIndex] * gl_in[<span class="number">0</span>].gl_Position;</span><br><span class="line">    EmitVertex();</span><br><span class="line"></span><br><span class="line">FragPos = gl_in[<span class="number">1</span>].gl_Position.xyz;</span><br><span class="line">gl_Position = viewProject[projectIndex] * gl_in[<span class="number">1</span>].gl_Position;</span><br><span class="line">    EmitVertex();</span><br><span class="line"></span><br><span class="line">FragPos = gl_in[<span class="number">2</span>].gl_Position.xyz;</span><br><span class="line">gl_Position = viewProject[projectIndex] * gl_in[<span class="number">2</span>].gl_Position;</span><br><span class="line">    EmitVertex();</span><br><span class="line"></span><br><span class="line">    EndPrimitive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最终，我们成功的修补了体素的裂缝，如下图所示，先前的裂缝已经填上了体素。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/12.png" width="60%"></div></p><center> 图8 成功修补裂缝 </center><h1 id="三、修补孔洞"><a href="#三、修补孔洞" class="headerlink" title="三、修补孔洞"></a>三、修补孔洞</h1><p>&emsp;&emsp;然而，通过前面2部分的处理，另外一个问题出现了。由于模型的每个三角形都是各自根据在每个平面上的投影面积来选择投影相机，这意味着两个相邻的三角形片面可能选取了不同投影相机，使得三角形面片之间因为体素化投影平面的不同而产生过渡问题，从而出现孔洞，即有些部分没有被体素化到。如下图9所示。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/13.png" width="60%"></div></p><center> 图9 体素孔洞 </center><p>&emsp;&emsp;孔洞的产生根源于光栅化处理，一个像素是否作为当前图元的光栅片元，是通过判断当前图元是否覆盖了该像素中心来完成的。对于那些没有覆盖像素中心的片元，不作为该图元的光栅片元送入片元着色器做进一步的处理，因而模型的一些部分可能会被丢失，从而造成孔洞。为了解决这个问题，我们将在几何着色器中实现一种被称为<strong>保守光栅化</strong>（Conservative Rasterization）的算法，依旧在几何着色器中实现。</p><p>&emsp;&emsp;通常的硬件光栅化，都是默认只取那些中心被图元覆盖的像素单元。而保守光栅化则将所有被图元覆盖（无论是否覆盖到像素单元的中心点）的像素单元都作为光栅化的片元，从而确保图元覆盖的所有区域都被光栅化，故名思意，这就是“保守”一词的由来。如下图10所示，通常情况下硬件默认的光栅片元是绿色部分，边缘红色部分的片元没有被光栅化，导致我们的体素化结果出现孔洞。为了修补体素化的孔洞，我们必须使得被图元哪怕一点点覆盖到的像素（就是下图中的红色部分）都作为当前图元的光栅化结果，这个过程就是保守光栅化算法。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/14.png" width="60%"></div></p><center> 图10 保守光栅化 </center><p>&emsp;&emsp;那么怎么实现保守光栅化算法，使得上面的红色部分也被光栅化到呢？<strong>一个简单直观的思路就是手动扩充三角形图元面片。如上图10所示，里面的三角形是最初的我们要光栅化的三角形，为了使得边缘红色的像素也包含进来，我们扩张最初的三角形得到外面的那个三角形，这个三角形比原来的三角形稍微大一点，此时若将该扩大的三角形送入硬件默认的光栅化单元进行处理，则红色像素也被当作光栅片元，从而达到了我们的目的。</strong>注意，这里三角形的扩大程度非常关键，上面的扩大的三角形将我们不需要的像素单元也包含了进来，即黄色像素部分，我们将通过计算三角形的包围盒来剔除那些黄色像素单元，剔除像素部分我们将在片元着色器中实现。下图11是我实现的保守光栅化（图右）效果，图左是默认光栅化的效果。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/20.jpg" width="80%"></div></p><center> 图11 默认的光栅化和保守光栅化对比 </center><p>&emsp;&emsp;扩大三角形和剔除像素整个过程都是在裁剪空间中进行的，也就是经过摄像机空间变换和投影变换之后。故而三角形的包围盒只需二维即可，然后需要适当地扩大一点，以免剔除红色的像素片元。一个裁剪空间的三角形包围盒计算如下所示，我们采用GLSL的vec4存储包围盒的最小顶点和最大顶点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec4 <span class="title">calcAABB</span><span class="params">(vec4 pos[<span class="number">3</span>], vec2 pixelDiagonal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vec4 aabb;</span><br><span class="line">aabb.xy = min(pos[<span class="number">2</span>].xy, min(pos[<span class="number">1</span>].xy, pos[<span class="number">0</span>].xy));</span><br><span class="line">aabb.zw = max(pos[<span class="number">2</span>].xy, max(pos[<span class="number">1</span>].xy, pos[<span class="number">0</span>].xy));</span><br><span class="line"><span class="comment">// enlarge by half-pixel</span></span><br><span class="line">aabb.xy -= pixelDiagonal;</span><br><span class="line">aabb.zw += pixelDiagonal;</span><br><span class="line"><span class="keyword">return</span> aabb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来对于给定的三角形的三个顶点，我们要适当地扩大三角形。总体的思路就是：<strong>首先计算三角形的三条边与原点构成的齐次空间的平面，然后适当挪动这三个平面，接着就计算偏移后的这三个齐次平面的交线，最后计算三条交线与三角形平面的交点，从而得到扩大后的三角形的三个顶点。</strong>整个计算过程都是在裁剪空间中进行的，所以我们忽略顶点的$z$分量，但是上面又提到了齐次平面一词，我们采用一个齐次平面来描述三角形边的线段。所谓齐次平面，就是我们把顶点的齐次分量$w$和$x$、$y$分量合并一起来表示一条线段，直观来看，这就是一个齐次空间的平面，但实际上就是一段二维空间的直线。如下所示：</p><script type="math/tex; mode=display">Ax_c+By_c+Cw_c=0 \tag {1}</script><p>&emsp;&emsp;公式$(1)$就是一个齐次空间的过原点的平面方程，但是它实际上就是一个二维空间的直线方程。这是因为我们采用的都是正交投影，正交投影并没有透视除法之类的处理，因为正交投影都是线性变换，故而$w_c=1$，所以公式$(1)$表示的过原点的齐次空间的平面方程就是如下所示的二维直线方程：</p><script type="math/tex; mode=display">Ax_c+By_c+C=0 \tag {2}</script><p>&emsp;&emsp;之所以采用齐次空间的平面方程，是为了方便我们的计算。首先我们根据三角形的三条边计算三个齐次空间的平面，我们已知该齐次空间的平面过原点，平面方程的$(A,B,C)$就是该平面的法线向量，我们直接做叉乘计算可得平面的法线，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vec3 edgePlanes[<span class="number">3</span>];</span><br><span class="line">edgePlanes[<span class="number">0</span>] = cross(pos[<span class="number">0</span>].xyw - pos[<span class="number">2</span>].xyw, pos[<span class="number">2</span>].xyw);</span><br><span class="line">edgePlanes[<span class="number">1</span>] = cross(pos[<span class="number">1</span>].xyw - pos[<span class="number">0</span>].xyw, pos[<span class="number">0</span>].xyw);</span><br><span class="line">edgePlanes[<span class="number">2</span>] = cross(pos[<span class="number">2</span>].xyw - pos[<span class="number">1</span>].xyw, pos[<span class="number">1</span>].xyw);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后对这三个平面分别进行偏移。直观上来说，我们分别令三角形的三条边在其法线的方向上挪一段距离，这个距离由像素单元格的大小（即下面的halfPixel）在法线方向的投影决定，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">edgePlanes[<span class="number">0</span>].z -= dot(halfPixel[projectIndex], <span class="built_in">abs</span>(edgePlanes[<span class="number">0</span>].xy));</span><br><span class="line">edgePlanes[<span class="number">1</span>].z -= dot(halfPixel[projectIndex], <span class="built_in">abs</span>(edgePlanes[<span class="number">1</span>].xy)); </span><br><span class="line">edgePlanes[<span class="number">2</span>].z -= dot(halfPixel[projectIndex], <span class="built_in">abs</span>(edgePlanes[<span class="number">2</span>].xy));</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接着计算三个齐次平面的交线向量，这个不难理解，两个平面的交线必然垂直于这两个平面的法线向量，因而交线向量可由这两个平面的法线向量做叉乘得到：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vec3 intersection[<span class="number">3</span>];</span><br><span class="line">intersection[<span class="number">0</span>] = cross(edgePlanes[<span class="number">0</span>], edgePlanes[<span class="number">1</span>]);</span><br><span class="line">intersection[<span class="number">1</span>] = cross(edgePlanes[<span class="number">1</span>], edgePlanes[<span class="number">2</span>]);</span><br><span class="line">intersection[<span class="number">2</span>] = cross(edgePlanes[<span class="number">2</span>], edgePlanes[<span class="number">0</span>]);</span><br><span class="line">intersection[<span class="number">0</span>] /= intersection[<span class="number">0</span>].z;</span><br><span class="line">intersection[<span class="number">1</span>] /= intersection[<span class="number">1</span>].z;</span><br><span class="line">intersection[<span class="number">2</span>] /= intersection[<span class="number">2</span>].z;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后我们根据上面的三条射线向量与初试三角形所在的平面求交点，从而得到最终扩大后的三角形的三个顶点。由于我们是正交投影，所以上面求到的三条射线向量的$x$分量和$y$分量就是扩大三角形顶点的$x$分量和$y$分量，即交点的$x$、$y$已知，需要求$z$值。一个三维平面方程如下所示，从直观的几何意义上来说，$(A,B,C)$就是平面的法线向量，$D$就是原点到平面的直线距离。</p><script type="math/tex; mode=display">Ax+By+Cz+D=0 \tag {3}</script><p>&emsp;&emsp;已知初始三角形的三个点，我们可以求出它的法线向量，然后原点到平面的直线距离就等于平面上的点在法线向量方向上的投影长度，这里要特别注意符号，具体看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec4 trianglePlane;</span><br><span class="line">trianglePlane.xyz = normalize(cross(pos[<span class="number">1</span>].xyz - pos[<span class="number">0</span>].xyz, pos[<span class="number">2</span>].xyz-pos[<span class="number">0</span>].xyz));</span><br><span class="line">trianglePlane.w   = -dot(pos[<span class="number">0</span>].xyz, trianglePlane.xyz);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后还需要提一点的是，我们要确保输入的三角形的顶点环绕顺序都是逆时针方向，这个逆时针方向是针对当前的相机投影方向。对于背向的面片，我们要做一个纠正的过程。判断是否是背向面片很简单，只需通过计算三角形法线向量与$(0,0,1)$做点乘，判断其符号即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// change winding, otherwise there are artifacts for the back faces.</span></span><br><span class="line"><span class="keyword">if</span> (dot(trianglePlane.xyz, vec3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)) &lt; <span class="number">0.0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    vec4 vertexTemp = pos[<span class="number">2</span>];</span><br><span class="line">    pos[<span class="number">2</span>] = pos[<span class="number">1</span>];</span><br><span class="line">    pos[<span class="number">1</span>] = vertexTemp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;已知交点的$x$和$y$，我们代入平面方程$(3)$求得$z$值。</p><script type="math/tex; mode=display">z=-\frac{Ax+By+D}{C} \tag {4}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calculate dilated triangle vertices</span></span><br><span class="line"><span class="keyword">float</span> z[<span class="number">3</span>];</span><br><span class="line">z[<span class="number">0</span>] = -(intersection[<span class="number">0</span>].x * trianglePlane.x + intersection[<span class="number">0</span>].y * trianglePlane.y + trianglePlane.w) / trianglePlane.z;</span><br><span class="line">z[<span class="number">1</span>] = -(intersection[<span class="number">1</span>].x * trianglePlane.x + intersection[<span class="number">1</span>].y * trianglePlane.y + trianglePlane.w) / trianglePlane.z;</span><br><span class="line">z[<span class="number">2</span>] = -(intersection[<span class="number">2</span>].x * trianglePlane.x + intersection[<span class="number">2</span>].y * trianglePlane.y + trianglePlane.w) / trianglePlane.z;</span><br><span class="line">pos[<span class="number">0</span>].xyz = vec3(intersection[<span class="number">0</span>].xy, z[<span class="number">0</span>]);</span><br><span class="line">pos[<span class="number">1</span>].xyz = vec3(intersection[<span class="number">1</span>].xy, z[<span class="number">1</span>]);</span><br><span class="line">pos[<span class="number">2</span>].xyz = vec3(intersection[<span class="number">2</span>].xy, z[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最终，我们求得到扩大后的三角形的三个顶点，我们还需要对三个顶点做逆视图投影变换，将裁剪空间的顶点变换到世界空间，得到扩大后的三角形的世界坐标，因为我们最终目的是根据世界空间坐标做体素化的处理。与此同时，我们还将在裁剪空间的扩大三角形的顶点传到片元着色器，因为我们要剔除不必要的片元。以下是保守光栅化算法的几何着色器代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 430 core</span></span><br><span class="line">layout (triangles) in;</span><br><span class="line">layout (triangle_strip, max_vertices = <span class="number">3</span>) out;</span><br><span class="line"></span><br><span class="line">out vec3 FragPos;</span><br><span class="line">out vec3 ProjectPos;</span><br><span class="line">out vec4 BoundingBox;</span><br><span class="line"></span><br><span class="line">uniform vec2 halfPixel[<span class="number">3</span>];</span><br><span class="line">uniform mat4 viewProject[<span class="number">3</span>];</span><br><span class="line">uniform mat4 viewProjectInverse[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">uint <span class="title">selectViewProject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vec3 p1 = gl_in[<span class="number">1</span>].gl_Position.xyz - gl_in[<span class="number">0</span>].gl_Position.xyz;</span><br><span class="line">vec3 p2 = gl_in[<span class="number">2</span>].gl_Position.xyz - gl_in[<span class="number">0</span>].gl_Position.xyz;</span><br><span class="line">vec3 faceNormal = cross(p1, p2);</span><br><span class="line"><span class="keyword">float</span> nDX = <span class="built_in">abs</span>(faceNormal.x);</span><br><span class="line"><span class="keyword">float</span> nDY = <span class="built_in">abs</span>(faceNormal.y);</span><br><span class="line"><span class="keyword">float</span> nDZ = <span class="built_in">abs</span>(faceNormal.z);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( nDX &gt; nDY &amp;&amp; nDX &gt; nDZ )</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( nDY &gt; nDX &amp;&amp; nDY &gt; nDZ  )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">vec4 <span class="title">calcAABB</span><span class="params">(vec4 pos[<span class="number">3</span>], vec2 pixelDiagonal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vec4 aabb;</span><br><span class="line">aabb.xy = min(pos[<span class="number">2</span>].xy, min(pos[<span class="number">1</span>].xy, pos[<span class="number">0</span>].xy));</span><br><span class="line">aabb.zw = max(pos[<span class="number">2</span>].xy, max(pos[<span class="number">1</span>].xy, pos[<span class="number">0</span>].xy));</span><br><span class="line"><span class="comment">// enlarge by half-pixel</span></span><br><span class="line">aabb.xy -= pixelDiagonal;</span><br><span class="line">aabb.zw += pixelDiagonal;</span><br><span class="line"><span class="keyword">return</span> aabb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">uint projectIndex = selectViewProject();</span><br><span class="line">vec4 pos[<span class="number">3</span>] = vec4[<span class="number">3</span>]</span><br><span class="line">(</span><br><span class="line">viewProject[projectIndex] * gl_in[<span class="number">0</span>].gl_Position,</span><br><span class="line">viewProject[projectIndex] * gl_in[<span class="number">1</span>].gl_Position,</span><br><span class="line">viewProject[projectIndex] * gl_in[<span class="number">2</span>].gl_Position</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">vec4 trianglePlane;</span><br><span class="line">trianglePlane.xyz = normalize(cross(pos[<span class="number">1</span>].xyz - pos[<span class="number">0</span>].xyz, pos[<span class="number">2</span>].xyz - pos[<span class="number">0</span>].xyz));</span><br><span class="line">trianglePlane.w   = -dot(pos[<span class="number">0</span>].xyz, trianglePlane.xyz);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// change winding, otherwise there are artifacts for the back faces.</span></span><br><span class="line">    <span class="keyword">if</span> (dot(trianglePlane.xyz, vec3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)) &lt; <span class="number">0.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        vec4 vertexTemp = pos[<span class="number">2</span>];</span><br><span class="line">        pos[<span class="number">2</span>] = pos[<span class="number">1</span>];</span><br><span class="line">        pos[<span class="number">1</span>] = vertexTemp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>(trianglePlane.z == <span class="number">0.0f</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">BoundingBox = calcAABB(pos, halfPixel[projectIndex]);</span><br><span class="line"></span><br><span class="line">vec3 edgePlanes[<span class="number">3</span>];</span><br><span class="line">edgePlanes[<span class="number">0</span>] = cross(pos[<span class="number">0</span>].xyw - pos[<span class="number">2</span>].xyw, pos[<span class="number">2</span>].xyw);</span><br><span class="line">edgePlanes[<span class="number">1</span>] = cross(pos[<span class="number">1</span>].xyw - pos[<span class="number">0</span>].xyw, pos[<span class="number">0</span>].xyw);</span><br><span class="line">edgePlanes[<span class="number">2</span>] = cross(pos[<span class="number">2</span>].xyw - pos[<span class="number">1</span>].xyw, pos[<span class="number">1</span>].xyw);</span><br><span class="line">edgePlanes[<span class="number">0</span>].z -= dot(halfPixel[projectIndex], <span class="built_in">abs</span>(edgePlanes[<span class="number">0</span>].xy));</span><br><span class="line">edgePlanes[<span class="number">1</span>].z -= dot(halfPixel[projectIndex], <span class="built_in">abs</span>(edgePlanes[<span class="number">1</span>].xy)); </span><br><span class="line">edgePlanes[<span class="number">2</span>].z -= dot(halfPixel[projectIndex], <span class="built_in">abs</span>(edgePlanes[<span class="number">2</span>].xy));</span><br><span class="line"></span><br><span class="line">vec3 intersection[<span class="number">3</span>];</span><br><span class="line">intersection[<span class="number">0</span>] = cross(edgePlanes[<span class="number">0</span>], edgePlanes[<span class="number">1</span>]);</span><br><span class="line">intersection[<span class="number">1</span>] = cross(edgePlanes[<span class="number">1</span>], edgePlanes[<span class="number">2</span>]);</span><br><span class="line">intersection[<span class="number">2</span>] = cross(edgePlanes[<span class="number">2</span>], edgePlanes[<span class="number">0</span>]);</span><br><span class="line">intersection[<span class="number">0</span>] /= intersection[<span class="number">0</span>].z;</span><br><span class="line">intersection[<span class="number">1</span>] /= intersection[<span class="number">1</span>].z;</span><br><span class="line">intersection[<span class="number">2</span>] /= intersection[<span class="number">2</span>].z;</span><br><span class="line"></span><br><span class="line"><span class="comment">// calculate dilated triangle vertices</span></span><br><span class="line"><span class="keyword">float</span> z[<span class="number">3</span>];</span><br><span class="line">z[<span class="number">0</span>] = -(intersection[<span class="number">0</span>].x * trianglePlane.x + intersection[<span class="number">0</span>].y * trianglePlane.y + trianglePlane.w) / trianglePlane.z;</span><br><span class="line">z[<span class="number">1</span>] = -(intersection[<span class="number">1</span>].x * trianglePlane.x + intersection[<span class="number">1</span>].y * trianglePlane.y + trianglePlane.w) / trianglePlane.z;</span><br><span class="line">z[<span class="number">2</span>] = -(intersection[<span class="number">2</span>].x * trianglePlane.x + intersection[<span class="number">2</span>].y * trianglePlane.y + trianglePlane.w) / trianglePlane.z;</span><br><span class="line">pos[<span class="number">0</span>].xyz = vec3(intersection[<span class="number">0</span>].xy, z[<span class="number">0</span>]);</span><br><span class="line">pos[<span class="number">1</span>].xyz = vec3(intersection[<span class="number">1</span>].xy, z[<span class="number">1</span>]);</span><br><span class="line">pos[<span class="number">2</span>].xyz = vec3(intersection[<span class="number">2</span>].xy, z[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">vec4 voxelPos;</span><br><span class="line"></span><br><span class="line">ProjectPos = pos[<span class="number">0</span>].xyz;</span><br><span class="line">gl_Position = pos[<span class="number">0</span>];</span><br><span class="line">voxelPos = viewProjectInverse[projectIndex] * gl_Position;</span><br><span class="line">FragPos = voxelPos.xyz;</span><br><span class="line">    EmitVertex();</span><br><span class="line"></span><br><span class="line">ProjectPos = pos[<span class="number">1</span>].xyz;</span><br><span class="line">gl_Position = pos[<span class="number">1</span>];</span><br><span class="line">voxelPos = viewProjectInverse[projectIndex] * gl_Position;</span><br><span class="line">FragPos = voxelPos.xyz;</span><br><span class="line">    EmitVertex();</span><br><span class="line"></span><br><span class="line">ProjectPos = pos[<span class="number">2</span>].xyz;</span><br><span class="line">gl_Position = pos[<span class="number">2</span>];</span><br><span class="line">voxelPos = viewProjectInverse[projectIndex] * gl_Position;</span><br><span class="line">FragPos = voxelPos.xyz;</span><br><span class="line">    EmitVertex();</span><br><span class="line"></span><br><span class="line">    EndPrimitive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后的最后，我们还需要在片元着色器剔除无关的片元，具体原因我已经在前面说了，如果不做这一步的剔除操作，将出现如下图12所示的情况。在片元着色器中，我们根据传入的三角形包围盒与当前的片元位置判断是否需要丢弃该片元。具体看下面代码的第19行、第20行。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/15.png" width="60%"></div></p><center> 图12 保守光栅化出现的边边角角 </center><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 430 core</span></span><br><span class="line"></span><br><span class="line">in vec3 FragPos;</span><br><span class="line">in vec3 ProjectPos;</span><br><span class="line">in vec4 BoundingBox;</span><br><span class="line"></span><br><span class="line">layout (std430, binding = <span class="number">0</span>) buffer CountBuffer&#123;</span><br><span class="line">    <span class="keyword">int</span> cnts[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">bool</span> conservate;</span><br><span class="line">uniform <span class="keyword">float</span> step;</span><br><span class="line">uniform vec3 boxMin;</span><br><span class="line">uniform vec3 resolution;</span><br><span class="line"></span><br><span class="line">out vec4 color;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ProjectPos.x &lt; BoundingBox.x || ProjectPos.y &lt; BoundingBox.y || ProjectPos.x &gt; BoundingBox.z || ProjectPos.y &gt; BoundingBox.w)</span><br><span class="line">discard;</span><br><span class="line"></span><br><span class="line">uint x = uint((FragPos.x - boxMin.x)/step);</span><br><span class="line">uint y = uint((FragPos.y - boxMin.y)/step);</span><br><span class="line">uint z = uint((FragPos.z - boxMin.z)/step);</span><br><span class="line">uint index = uint(y * (resolution.z * resolution.x) + z * resolution.x + x);</span><br><span class="line">atomicAdd(cnts[index], <span class="number">1</span>);</span><br><span class="line">color = vec4(<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最终，修复了孔洞的效果的如下图，可以看到，对比前面的图9，孔洞基本都被“补”上了。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/16.jpg" width="90%"></div></p><center> 图13 保守光栅化出现的边边角角 </center><p>&emsp;&emsp;下面就是一些模型的体素化效果。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/17.png" width="90%"></div></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/18.png" width="90%"></div></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/19.png" width="90%"></div></p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>$[1]$ <a href="https://developer.nvidia.com/content/basics-gpu-voxelization" target="_blank" rel="noopener">The Basics of GPU Voxelization</a></p><p>$[2]$ <a href="https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter42.html" target="_blank" rel="noopener">《GPU Gems 2》： Chapter 42. Conservative Rasterization</a></p><p>$[3]$ <a href="https://blog.csdn.net/xiewenzhao123/article/details/79875855" target="_blank" rel="noopener">https://blog.csdn.net/xiewenzhao123/article/details/79875855</a></p></div>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Voxelization </category>
          
          <category> Position Based Dynamics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> Voxelization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流体模拟Fluid Simulation：Position Based Fluid</title>
      <link href="/2019/06/04/PositionBasedFluid/"/>
      <url>/2019/06/04/PositionBasedFluid/</url>
      
        <content type="html"><![CDATA[<p>本篇文章主要是关于Position Based Dynamics的流体模拟方法，这类方法依旧采用基于拉格朗日的视角，把流体看成由一个一个粒子组成，易于并行化，适用于实时的流体模拟。目前实现的只是CPU版本，考虑在后面利用cuda挪到GPU上做模拟计算。相关的完整代码请看<a href="https://github.com/ZeusYang/PositionBasedFluid" target="_blank" rel="noopener">这里</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/header.gif" alt="header"></p><a id="more"></a><ul><li>基于位置动力学的物理模拟</li><li>基于位置动力学的流体模拟</li><li>流体模拟算法实现</li><li>实现效果</li><li>参考资料</li></ul><h1 id="一、基于位置动力学的物理模拟"><a href="#一、基于位置动力学的物理模拟" class="headerlink" title="一、基于位置动力学的物理模拟"></a>一、基于位置动力学的物理模拟</h1><p>&emsp;&emsp;传统的物理模拟方法都是基于力的方法，这类方法通过计算内部力（如流体内部的粘性力、压力）和外部力（如重力和碰撞力）的合力，然后根据牛顿第二定律计算出加速度，最后根据数值计算方法求出物体的速度和位置。这种方法基本上针对每一种动态物体，会由一个独立的求解器，各种求解器按照一定的顺序计算，从而得到模拟的结果，这样会带来大量冗余的工作。基于位置动力学（Position Based Dynamics）的方法将这些物理运动通过约束表达出来，这样只需要一个求解器即可，更加方便地进行物理模拟。</p><p>&emsp;&emsp;下图1是基于力和基于位置动力学的物体碰撞更新过程的对比，可以看到基于力的碰撞检测首先在穿透发生时更新物体的速度，然后更新物体的位置。而基于位置动力学的碰撞检测首先只检测是否发生穿透，然后移动位置使之不发生穿透，最后再据此更新物体的速度信息。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/1.jpg" width="60%"></div></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/2.jpg" width="60%"></div></p><p><center> 图1 两种碰撞更新过程对比 </center></p><h2 id="1、基于位置动力学的模拟算法"><a href="#1、基于位置动力学的模拟算法" class="headerlink" title="1、基于位置动力学的模拟算法"></a>1、基于位置动力学的模拟算法</h2><p>&emsp;&emsp;基于位置动力学英文全称为Position Based Dynamics，以下简称为PBD。接下来我们介绍经典的PBD算法。在PBD算法中，运动的物体由$N$个顶点和$M$个约束组成。顶点$i\in [1,…,N]$的质量为$m_i$，位置为$x_i$，速度为$v_i$，每个约束$j\in [1,…,M]$有如下五个性质：</p><ul><li>约束的基数为$n_j$，即第$j$个约束所影响的顶点数目为$n_j$个；</li><li>约束函数$C_j:\ R^{3n_j}\to R$；</li><li>受约束影响的顶点索引值集合$\{i_1,…,i_{n_j}\},i_k\in [1,…N]$；</li><li>每个约束都有对应的刚度参数$k_j\in [0,1]$，这里我们可以理解为约束的强度；</li><li>约束分为两种，一类是等式约束即$C_j(x_{i1},x_{i_2},…,x_{i_{n_j}})=0$，另一类是不等式约束$C_j(x_{i_1},x_{i_2},…,x_{i_{n_j}})\geq 0$。</li></ul><p>&emsp;&emsp;给定时间步长$\Delta t$，PBD的运动物体模拟的算法伪代码如下所示：</p><script type="math/tex; mode=display">\begin{align}&1.forall\ \ vertices\ \ i:\\&2.\ \ \ \ initialize\ \ x_i=x_i^0,v_i=v_i^0,w_i=1/m_i\\&3.endfor\\&4.loop\\&5.\ \ \ \ forall\ \ vertices\ \ i\ \ do\ \  v_i\leftarrow v_i+\Delta tw_if_{ext}(x_i)\\&6.\ \ \ \ dampVelocities(v_1,...,v_N)\\&7.\ \ \ \ forall\ \ vertices\ \ i\ \ do\ \ p_i\leftarrow x_i+\Delta t v_i\\&8.\ \ \ \ forall\ \ vertices\ \ i\ \ do\ \ generateCollisionConstraints(x_i\to p_i)\\&9.\ \ \ \ loop\ \ solverIterations\ \ times\\&10.\ \ \ \ \ \ \ \ projectConstraints(C1,...,C_{M+M_{coll}},p_1,...,p_N)\\&11.\ \ \ endloop\\&12.\ \ \ forall\ \ vertices\ \ i\\&13.\ \ \ \ \ \ \ \ v_i\leftarrow (p_i-x_i)\Delta t\\&14.\ \ \ \ \ \ \ \ x_i\leftarrow p_i\\&15.\ \ \ endfor\\&16.\ \ \ velocityUpdate(v1,...,v_N)\\&17.endloop\\\end{align}</script><p>&emsp;&emsp;在上面的算法第1步到第3步中，我们首先对顶点的位置、速度和质量倒数进行初始化，其中质量的倒数$w_i=1/m_i$，除了可以避免冗余的除法操作外，还可以使用于静态的物体，对于静态的物体我们设为$w_i=0$，这样在后续的更新中都不会产生位置和速度的变化量。第5步中的$f_{ext}$代表不能转换成约束形式的力（如重力），我们根据$f_{ext}$进行一次数值计算预测在$f_{ext}$的作用下的速度$v_i$。紧接着在第6步中我们添加阻尼的作用，阻尼可以理解为物体在运动中发生了能量耗散，从而导致速度有所衰减。第8行主要是生成碰撞约束，物体会与周围的环境发生碰撞，例如布料落在地板上，水碰上一面墙等，这些碰撞约束在每个时间步长都发生改变，所以每一次都需要重新生成碰撞约束。有了内部约束（如不可压缩流体的密度约束）和外部约束（如流体与地面的碰撞约束）之后，我们需要根据这些约束做一个迭代求解，也就是上面伪代码中的第9行到第11行，这里我们称为<strong>约束投影步骤</strong>。从约束投影步骤我们得到服从给定约束的粒子位置，然后再第12行到第15行更新顶点粒子的速度和位置信息。最后在第16行根据摩擦系数（friction）和恢复系数（restitution）更新速度，如下图2所示。这样，一个完整的PBD物理模拟步骤就完成了。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/3.jpg" width="60%"></div></p><p><center> 图2 friction和restitution </center></p><h2 id="2、约束投影步骤"><a href="#2、约束投影步骤" class="headerlink" title="2、约束投影步骤"></a>2、约束投影步骤</h2><p>&emsp;&emsp;接下来我们就针对约束投影步骤详细展开相关的内容，约束投影是PBD中的最难理解的核心部分，涉及的数学内容比较多一点。设有一个基数为n（也就是前面提到的$n_j$，受到该约束影响的顶点数目或者说粒子数目）的约束，关联的粒子点为$p_1,…,p_n$，约束函数记为$C$，刚度系数（stiffness）为$k$。记$p=[p_1^T,…,p_n^T]^T$，则等式约束函数表示为：</p><script type="math/tex; mode=display">C(p)=0 \tag {1}</script><p>&emsp;&emsp;我们的目标是计算这样的一个位移偏移量$\Delta p$，使得粒子顶点在$p+\Delta p$处约束条件依然满足，即：</p><script type="math/tex; mode=display">C(p+\Delta p)=0 \tag {2}</script><p>&emsp;&emsp;对约束函数$C$做一阶泰勒展开（或者导数的定义），则可得:</p><script type="math/tex; mode=display">C(p+\Delta p)\approx C(p)+\nabla_pC(p)\cdot\Delta p=0 \tag {3}</script><p>&emsp;&emsp;为了使粒子在$p+\Delta p$处依然满足约束条件，我们要求解方程$(3)$得到$\Delta p$。PBD算法的一个巧妙之处在于它将$\Delta p$的方向限制在约束函数的梯度方向$\nabla_p C(p)$上。如下图3所示，约束$C$所涉及到的粒子位置会形成一个高维空间，下图为该空间中满足不同约束条件的粒子位置形成的二维等值线示意图，其中满足$C$约束条件的是黑色等值线。故当粒子处于下图的黑色点的位置时，不满足约束条件，如果我们沿着点所在的等值线（灰色曲线）移动，此时刚体模态（Rigid body modes）的方向与该等值线相同，新得到的位置仍然在该灰色等值线上，依然不在黑色曲线 $C=0$上，即不满足约束条件。这可以理解为，约束中存在的误差依然没有得到修正。以两个粒子形成的距离约束为例，就好比同时移动了两个粒子或者该约束绕自身旋转，但是存在的误差并没有得到更正。而且这样一来还会引入系统中不存在的一种外力，导致系统动量不守恒。所以，我们希望该点的位移方向与刚体模态方向垂直，从而保证系统动量守恒，即从黑点指向红点的方向$\nabla C$。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/4.jpg" width="60%"></div></p><p><center> 图3 约束等值线 </center><br>&emsp;&emsp;因此，我们令位移向量$\Delta p$为约束函数的梯度向量$\nabla_p C$再乘上一个标量缩放系数$\lambda$：</p><script type="math/tex; mode=display">\Delta p=\lambda \nabla_p C(p) \tag {4}</script><p>&emsp;&emsp;其中的标量缩放系数$\lambda$我们称之为拉格朗日乘子（Lagrange multiplier）。联立公式$(3)$和$(4)$我们可得：</p><script type="math/tex; mode=display">\lambda=-\frac{C(p)}{|\nabla_pC(p)|^2} \tag {5}</script><p>&emsp;&emsp;然后将$\lambda$再代入公式$(4)$我们可得$\Delta p$的表达式：</p><script type="math/tex; mode=display">\Delta p=\lambda \nabla_pC(p)=-\frac{C(p)}{|\nabla_pC(p)|^2}\nabla_pC(p) \tag {6}</script><p>&emsp;&emsp;具体到粒子$i$，约束投影后其对应的位移向量为：</p><script type="math/tex; mode=display">\Delta p_i=-s\nabla_{p_i}C(p_1,...,p_n) \tag {7}</script><p>&emsp;&emsp;其中的$s$为如下所示，$s$的值对于约束函数$C$作用范围内的所有点都一样。</p><script type="math/tex; mode=display">s=\frac{C(p_1,...,p_n)}{\Sigma_j|\nabla_{p_j}C(p_1,...,p_n)|^2} \tag {8}</script><p>&emsp;&emsp;前面我们假定所有的粒子质量都相同，现在考虑粒子质量不同的情况。记粒子$i$的质量为$m_i$，其质量的倒数为$w_i=1/m_i$，则公式$(4)$变为：</p><script type="math/tex; mode=display">\Delta p_i=\lambda w_i\nabla_{p_i}C(p) \tag {9}</script><p>&emsp;&emsp;公式$(7)$和公式$(8)$变为：</p><script type="math/tex; mode=display">\Delta p_i=-s w_i\nabla_{p_i}C(p_1,...,p_n) \tag {10}</script><script type="math/tex; mode=display">s=\frac{C(p_1,...,p_n)}{\Sigma_jw_j|\nabla_{p_j}C(p_1,...,p_n)|^2} \tag {11}</script><p>&emsp;&emsp;为了便于理解，接下来我们举个简单的例子应用约束投影方法。如下图4所示。</p><p><div align="center"><img src="assets/5.png" width="60%"></div></p><p><center> 图4 简单的约束例子 </center><br>&emsp;&emsp;上面的约束可以表示为$C(p_1,p_2)=|p_1-p_2|-d$，位移向量记为$\Delta p_i$。根据约束投影方法，我们首先约束函数$C(p_1,p_2)$关于$p_1$和$p_2$的梯度，也就是求偏导数。注意到$C(p_1,p_2)=|p_1-p_2|-d=(\sqrt{(p_1-p_2)^2})-d$，我们可以求得以下的梯度向量表达式：</p><script type="math/tex; mode=display">\nabla_{p_1}C(p_1,p_2)=\frac{p_1-p_2}{|p_1-p_2|}\\\nabla_{p_2}C(p_1,p_2)=-\frac{p_1-p_2}{|p_1-p_2|} \tag {12}</script><p>&emsp;&emsp;注意，上面求到的是一个矢量，也就是我们说的梯度向量。将公式$(12)$代入公式$(11)$可得：</p><script type="math/tex; mode=display">\begin{align}s=&\frac{C(p_1,...,p_n)}{\Sigma_jw_j|\nabla_{p_j}C(p_1,...,p_n)|^2}\\=&\frac{|p_1-p_2|-d}{w_1|\nabla_{p_1}C(p_1,p_2)|^2+w_2|\nabla_{p_2}C(p_1,p_2)|^2}\\=&\frac{|p_1-p_2|-d}{w_1+w_2} \tag {13}\end{align}</script><p>&emsp;&emsp;最后，将公式$(13)$代入到公式$(10)$，可得约束投影计算得到的位移：</p><script type="math/tex; mode=display">\begin{align}\Delta p_1=&-\frac{|p_1-p_2|-d}{w_1+w_2}w_1\nabla_{p_1}C(p_1,p_2)\\=&-\frac{w_1}{w_1+w_2}(|p_1-p_2|-d)\frac{p_1-p_2}{|p_1-p_2|}\end{align}</script><p>&emsp;&emsp;同理$\Delta p_2$如下所示：</p><script type="math/tex; mode=display">\Delta p_2=+\frac{w_2}{w_1+w_2}(|p_1-p_2|-d)\frac{p_1-p_2}{|p_1-p_2|}</script><p>&emsp;&emsp;前面我们提到每个约束都有对应的刚度系数$k$，令$k’=1-(1-k)^{1/n_s}$去乘$\Delta p$，这里$n_s$迭代之后误差为$\Delta p(1-k’)^{n_s}=\Delta p(1-k)$，与刚度系数成线性关系，而与迭代次数$n_s$无关。下一个时间步的位置如下所示：</p><script type="math/tex; mode=display">p_1^{t+1}=p_1^t+k'\Delta p_1\\p_2^{t+1}=p_2^t+k'\Delta p_2</script><h2 id="3、约束投影求解器"><a href="#3、约束投影求解器" class="headerlink" title="3、约束投影求解器"></a>3、约束投影求解器</h2><p>&emsp;&emsp;前面的伪代码中我们可以看到约束投影的输入为$M+M_{coll}$个约束和$N个$点的预测位置$p1,…,p_N$，所需要求解的方程组是非线性非对称方程组或不等式组（碰撞约束产生的）。约束投影步骤的主要任务就是修正预测位置使新得到的校正位置满足所有约束。但是一般情况下很难找到一个适当的$\Delta p=[\Delta p_1^T,…,\Delta p_n^T]^T$恰好使得所有的约束都能够同时得到满足，故我们通常采用迭代的方法按顺序依次对约束进行求解。</p><p>&emsp;&emsp;我们可以采用非线性高斯-赛德尔（Non-Linear Gauss-Seidel，简称NGS）迭代方法。高斯赛德尔（Gauss-Sedel，简称GS）迭代方法只能求解线性方程组，NGS在依次求解德基础上，加入了约束投影求解这一非线性操作。与雅可比迭代方法（Jacobi method）不同，NGS求解器在一次迭代中对于顶点位置的修正立即被应用到下一个约束求解中，这样的好处就是显著加快了收敛速度。</p><p>&emsp;&emsp;但是NGS虽然稳定且容易实现，但是该方法收敛速度依然不是很快，不宜并行化。</p><h1 id="二、基于位置动力学的流体模拟"><a href="#二、基于位置动力学的流体模拟" class="headerlink" title="二、基于位置动力学的流体模拟"></a>二、基于位置动力学的流体模拟</h1><p>&emsp;&emsp;前面部分主要介绍了Position Based Dynamics算法相关的内容，接下来我们就看看如何将其PBD算法应用到流体模拟当中，主要是如何针对流体的物理特性构建相应的约束函数。基于位置动力学的流体全称为Position Based Fluid，简称PBF。</p><h2 id="1、不可压缩约束"><a href="#1、不可压缩约束" class="headerlink" title="1、不可压缩约束"></a>1、不可压缩约束</h2><p>&emsp;&emsp;在不可压缩性的流体模拟中，我们需要使粒子$i$的密度$\rho_i$尽量与静态的密度$\rho_0$相同，即$\rho_i=\rho_0$。因此，我们需要对每一个流体粒子都施加一个常量密度约束，PBF的常量密度约束如下所示：</p><script type="math/tex; mode=display">C_i(p_1,...,p_n)=\frac{\rho_i}{\rho_0}-1 \tag {14}</script><p>&emsp;&emsp;公式$(14)$中，我们记粒子$i$的位置为$p_i$，$p_1,…,p_n$是与粒子$i$相邻的粒子。可以看到当密度约束$C_i(p_1,…,p_n)=0$时有$\rho_i=\rho_0$，此时流体的体积即不压缩也不膨胀，从而保证了流体的不可压缩条件，这就是公式$(14)$的由来。流体粒子$i$的密度根据SPH（Smoothed Particle Hydrodynamics，光滑<em>粒子</em>流体动力学，简称SPH）方法的计算公式如下所示：</p><script type="math/tex; mode=display">\rho_i=\Sigma_jm_jW(p_i-p_j,h) \tag {15}</script><p>&emsp;&emsp;在公式$(15)$中，$m_j$是邻居粒子$j$的质量，$h$是指定的光滑核半径。$W$函数我们接下来会提到。将公式$(15)$代入公式$(14)$，我们有：</p><script type="math/tex; mode=display">C_i(p_1,...,p_n)=\frac{\Sigma_j m_jW(p_i-p_j,h)}{\rho_0}-1 \tag {16}</script><p>&emsp;&emsp;在公式$(15)$的密度计算中，PBF方法采用了Poly6核函数：</p><script type="math/tex; mode=display">W_{poly6}(r,h)=\frac{315}{64\pi h^9}\begin{cases}(h^2-|r|^2)^3\ \ \ \  0\leq|r|\leq h\\0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ otherwise \end{cases} \tag {17}</script><p>&emsp;&emsp;但是在计算密度的梯度时，却又采用了Spiky核函数：</p><script type="math/tex; mode=display">W_{spiky}(r,h)=\frac{15}{\pi h^6}\begin{cases}(h-|r|)^3\ \ \ \ 0\leq|r|\leq h\\0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 0therwise\end{cases} \tag {18}</script><p>&emsp;&emsp;对公式$(18)$求关于$r$的导数（注意，$|r|=\sqrt{r^2}$，不能直接对$|r|$求导），从而流体粒子密度的梯度如下所示：</p><script type="math/tex; mode=display">\nabla W_{spiky}(r,h)=-\frac{45}{\pi h^6}\begin{cases}(h-|r|)^2\frac{r}{|r|}\ \ \ \ 0\leq|r|\leq h\\0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ otherwise\end{cases} \tag {19}</script><p>&emsp;&emsp;因此，粒子$i$的约束函数$(16)$是一个关于$p_1,…,p_n$的非线性方程组$C_i(p_1,…,p_n)=0$，所有粒子$i$的约束组成了一个非线性方程组。在PBF方法中，我们只考虑粒子质量相同的情况，故我们可以省去公式$(15)$和公式$(16)$中的质量$m_j$，即：</p><script type="math/tex; mode=display">\rho_i=\Sigma_jW(p_i-p_j,h) \tag {20}</script><script type="math/tex; mode=display">C_i(p_1,...,p_n)=\frac{\Sigma_j W(p_i-p_j,h)}{\rho_0}-1 \tag {21}</script><p>&emsp;&emsp;然后求约束函数$C_i$关于$p_k$的梯度如下，其中$k\in\{1,2,…,n\}$：</p><script type="math/tex; mode=display">\nabla_{p_k}C_i=\frac1\rho_0\Sigma_j\nabla_{p_k}W(p_i-p_j,h) \tag {22}</script><p>&emsp;&emsp;显然，针对$k$的不同，分为两种情况。当$k=i$也就是粒子本身的时候，连加符号中的$W$均为关于$p_k$的函数；当$k=j$即邻居粒子的时候，只有$W(p_i-p_k,h)$才有意义，其他相对于$p_k$来说都是常量，故导数为0（注意用到了求导的链式法则）：</p><script type="math/tex; mode=display">\nabla_{p_k}C_i=\frac1\rho_0\begin{cases}\Sigma_j\nabla_{p_k}W(p_i-p_j,h)\ \ \ \ if\ \ k=i\\-\nabla_{p_k}W(p_i-p_j,h)\ \ \ \ \ if\ \ k=j\end{cases} \tag {23}</script><p>&emsp;&emsp;既然求出了约束函数的梯度，我们就把它应用到前面提到的拉格朗日乘子的计算公式中，联立公式$(5)$和公式$(23)$，我们有：</p><script type="math/tex; mode=display">\lambda_i=-\frac{C_i(p_1,...,p_n)}{\Sigma_k|\nabla_{p_k}C_i|^2} \tag {24}</script><h2 id="2、混合约束"><a href="#2、混合约束" class="headerlink" title="2、混合约束"></a>2、混合约束</h2><p>&emsp;&emsp;如果一个约束条件不能被违背，我们称之为硬约束；而能一定程度上被违背的约束称为软约束。在理想的情况下，我们都希望约束始终是硬约束，但是由于误差或者数值方法的不稳定等原因，我们有时不得不向软约束妥协。</p><p>&emsp;&emsp;在PBF中，当$|r|=h$，粒子$i$与粒子$j$之间的距离等于光滑核半径时，粒子$i$和粒子$j$处于即将分离的状态。注意观察公式$(19)$的密度梯度计算公式，此时$\nabla W_{spiky}(r,h)=0$。若所有的邻居粒子与粒子$i$都处于这种状态，那么必将导致约束函数的梯度即公式$(22)$取值为0：</p><script type="math/tex; mode=display">\nabla_{p_k}C_i=\frac1\rho_0\Sigma_j\nabla_{p_k}W(p_i-p_j,h) = 0</script><p>&emsp;&emsp;从而导致公式$(24)$中的分母$\Sigma_k|\nabla_{p_k}C_i|^2$为0，出现除零错误，这将导致PBF方法出现潜在的不稳定性。为了解决这个问题，PBF采用混合约束的方法，使密度硬约束转变成软约束。具体的做法就是将根据密度函数求解得到的约束力再加入到原始的约束函数中，这里在PBF的常量密度约束中得到的拉格朗日乘子$\lambda$有类似的作用，故将$\lambda$加入到初始的约束方程（即公式$(3)$）：</p><script type="math/tex; mode=display">C(p+\Delta p)\approx C(p)+\nabla C^T\nabla C \lambda + \epsilon\lambda=0 \tag {25}</script><p>&emsp;&emsp;公式$(25)$中的$\epsilon$是松弛参数，可以由用户指定。引入公式$(25)$后，拉格朗日乘子的计算公式$(24)$就变为：</p><script type="math/tex; mode=display">\lambda_i=-\frac{C_i(p_1,...,p_n)}{\Sigma_k|\nabla_{p_k}C_i|^2+\epsilon} \tag {26}</script><p>&emsp;&emsp;从而可得粒子$i$在经过上述约束投影后对应的位移向量（包括自身密度约束以及邻居粒子密度约束共同作用的结果。注意，这里对应的上面的公式$(4)$，结合公式$(23)$）：</p><script type="math/tex; mode=display">\begin{align}\Delta p_i&=\lambda_i \nabla_{p_i}C_i+\Sigma_j\lambda_j\nabla_{p_j}C_i\\&=\frac1\rho_0\Sigma_j\lambda_i\nabla_{p_i}W(r,h)+(-\frac1\rho_0\Sigma_j\lambda_j\nabla_{p_j}W(r,h))\\&=\frac1\rho_0\Sigma_j\lambda_i\nabla_{p_i}W(r,h)+\frac1\rho_0\Sigma_j\lambda_j\nabla_{p_i}W(r,h)\\&=\frac{1}{\rho_0}\Sigma_j(\lambda_i+\lambda_j)\nabla_{p_i}W(r,h)\end{align} \tag {27}</script><h2 id="3、拉伸不稳定性"><a href="#3、拉伸不稳定性" class="headerlink" title="3、拉伸不稳定性"></a>3、拉伸不稳定性</h2><p>&emsp;&emsp;PBF采用SPH的方法来计算流体粒子的密度，但是该方法通常需要30~40个邻居粒子才能使密度求值结果趋于静态密度。在邻居粒子数量较少的情况下，通过该方法计算得到的流体密度低于静态密度，由此会造成流体内部压强为负数，原本粒子间的压力变为吸引力，使得流体粒子凝聚在一起，导致流体表面的模拟效果失真。PBF采用了一种人工排斥力的计算模型，当流体粒子距离过近时该排斥力会使它们分开，避免产生粒子聚集的现象。在公式$(24)$的基础上，加入一个排斥项（repulsive term）$s_{corr}$：</p><script type="math/tex; mode=display">\Delta p_i=\frac1\rho_0\Sigma_j(\lambda_i+\lambda_j+s_{corr})\nabla_{p_i}W(p_i-p_j,h) \tag {28}</script><p>&emsp;&emsp;其中的$s_{corr}$计算方式如下：</p><script type="math/tex; mode=display">s_{corr}=-k(\frac{W(p_i-p_j,h)}{W(\Delta q,h)})^n \tag {29}</script><p>&emsp;&emsp;公式$(29)$中，$\Delta q$表示到粒子$i$的一个固定距离，通常取$|\Delta q|=0.1h,…,0.3h$，$h$即前面提到的光滑核半径。此外，公式中的$k$可以看作表面张力参数，取值$k=0.1$，而$n=4$。公式$(28)$中的排斥项会使得流体粒子的密度稍微低于静态密度，从而产生类似于表面张力的效果，使得流体表面的的粒子分布均匀。通过这个排斥项，我们不再需要硬性规定流体的邻居数量必须在30~40个，进一步提升算法的流体模拟效率。</p><h2 id="4、涡轮控制和人工粘性"><a href="#4、涡轮控制和人工粘性" class="headerlink" title="4、涡轮控制和人工粘性"></a>4、涡轮控制和人工粘性</h2><p>&emsp;&emsp;由于数值耗散，PBD的方法会引入额外的阻尼，使得整个系统的能量损耗太快，导致本来应该由的一些涡流细节迅速消失。在这里，PBF通过涡轮控制方法向整个系统重新注入能量：</p><script type="math/tex; mode=display">f_i^{vorticity}=\epsilon (N\times \omega_i) \tag {30}</script><p>&emsp;&emsp;上述的公式中，$N=\frac{\eta}{|\eta|},\ \eta=\nabla|\omega|_i$，而流体粒子的旋度$\omega_i$计算公式如下：</p><script type="math/tex; mode=display">\omega_i=\nabla\times v=\Sigma_j(v_j-v_i)\times \nabla_{p_j}W(p_i-p_j,h) \tag {31}</script><p>&emsp;&emsp;涡轮控制方法的基本思路就是：通过添加一个体积力$f_i^{vorticity}$（在算法的第一步），在旋度粒子（可直观理解为比周围粒子旋转快的粒子，旋度$\omega_i$指向粒子$i$的旋转轴）处加速粒子的旋转运动，通过这种方式来增加系统的旋度细节。公式$(30)$中的$\epsilon$用于控制涡轮控制力的强度。</p><p>&emsp;&emsp;最后，PBF方法采用XSPH的粘度方法直接更新速度，从而产生粘性阻尼。人工粘性除了可以增加模拟的数值稳定性，还可以消除非物理的流体振荡。拉格朗日流体模拟方法中，人工粘性本质上会对流体粒子的相对运动产生阻尼作用，使流体的动能转化为热能：</p><script type="math/tex; mode=display">v_i^{new}=v_i+c\Sigma_j(v_i-v_j)\cdot W(p_i-p_j,h) \tag {32}</script><p>&emsp;&emsp;在流体模拟中，我们取公式$(32)$中的$c=0.01$。</p><h2 id="5、PBF算法"><a href="#5、PBF算法" class="headerlink" title="5、PBF算法"></a>5、PBF算法</h2><p>&emsp;&emsp;PBF算法的总体框架就是按照前面提到的PBD算法，只是经典PBD算法采用了顺序高斯-赛德尔（Sequential Gauss-Seidel，SGS）迭代求解，而SGS不容易被GPU并行化，因此基于CUDA实现的PBF求解器使用了雅克比（Jacobi）迭代方法并行求解。</p><p>&emsp;&emsp;PBF的算法伪代码如下所示：</p><script type="math/tex; mode=display">\begin{align}&1.\ forall\ \ particles\ \ i\ \ do\\&2.\ \ \ \ \ apply\ \ force\ \ v_i\leftarrow v_i+\Delta tf_{ext}(x_i)\\&3.\ \ \ \ \ predict\ \ position\ \ x_i^*\leftarrow x_i+\Delta t v_i\\&4.\ endfor\\&5.\ forall\ \ particles\ \ i\ \ do\\&6.\ \ \ \ \ find\ \ neighboring\ \ particles\ \ N_i(x_i^*)\\&7.\ endfor\\&8.\ while\ \ iter\ \ <\ \ solverIterations\ \ do\\&9.\ \ \ \ \ forall\ \ particles\ \ i\ \ do\\&10.\ \ \ \ \ \ \ \ calculate\ \ \lambda_i\\\&11.\ \ \ \ endfor\\&12.\ \ \ \ forall\ \ particles\ \ i\ \ do\\&13.\ \ \ \ \ \ \ \ calculate\ \ \Delta p_i\\&14.\ \ \ \ \ \ \ \ perform\ \ collision\ \ detection\ \ and\ \ response\\&15.\ \ \ \ endfor\\&16.\ \ \ \ forall\ \ particles\ \ i\ \ do\\&17.\ \ \ \ \ \ \ \ update\ \ position\ \ x_i^*\leftarrow x_i^*+\Delta p_i\\&18.\ \ \ \ endfor\\&19.endwhile\\&20.forall\ \ particles\ \ i\ \ do\\&21.\ \ \ \ update\ \ velocity\ \ v_i\leftarrow\frac1{\Delta t}(x_i^*-x_i)\\&22.\ \ \ \ apply\ \ vorticity\ \ confinement\ \ and\ \ XSPH\ \ viscosity\\&23.\ \ \ \ update\ \ position\ \ x_i\leftarrow x_i^*\\&24.endfor\end{align}</script><h1 id="三、流体模拟算法实现"><a href="#三、流体模拟算法实现" class="headerlink" title="三、流体模拟算法实现"></a>三、流体模拟算法实现</h1><p>&emsp;&emsp;在前面的理论讨论部分我们没有提到流体与固体边界的交互作用，实际上这对于流体模拟来说是非常重要，一般丰富的流体细节都要通过与刚体、软体以及其他流体的相互作用表现出来，目前我们仅考虑流体与刚体的交互效果。一般做刚体碰撞都是采用的射线与三角形求交，检测是否发生了穿透，然后根据交点修正物体的位置，从而表现出碰撞反弹的效果。这里我们并不采用这种方法，而是采用像流体一样的表示方法，将固体用一个一个粒子表示，流体与刚体的碰撞通过流体粒子与刚体粒子的属性作用间接地表现出来。这种方法非常自然，可以对任意形状的物体做碰撞， 只要将刚体表示成粒子表示，非常适用于在GPU上实现，当然缺点就是增大了内存开销。</p><p>&emsp;&emsp;加入了刚体边界粒子，在计算密度、拉格朗日乘子、流体密度约束的时候，我们就需要考虑刚体粒子对流体粒子这些属性的贡献。在计算流体密度时，公式变成如下：</p><script type="math/tex; mode=display">\rho_i=\Sigma_jm_jW(x_i-x_j,h)+\Sigma_k\phi_{b_k}W(x_i-x_k,h) \tag {33}</script><p>&emsp;&emsp;可以看到，除了邻居的流体粒子，还加入了刚体刚体粒子的属性计算，即公式最右边的那一项，其中$\phi_{b_k}$计算如下：</p><script type="math/tex; mode=display">\phi_{b_k}=\rho_0\frac{m_{b_k}}{\Sigma_lm_{b_l}W(x_k-x_l,h)} \tag {34}</script><p>&emsp;&emsp;对于流体粒子，我们可以把$\phi_{b_k}$看成是刚体粒子的质量，对于每一个固体粒子$b_k$，我们可以提前计算好它的$\phi_{b_k}$值，避免每一步的模拟都重新计算。同样地，计算拉格朗日乘子也要考虑刚体粒子的作用：</p><script type="math/tex; mode=display">\lambda_i=-\frac{C_i(p_1,...,p_n)}{\Sigma_k|\nabla_{p_k}C_i|^2+\Sigma_l|\nabla_{p_l}C_i|^2+\epsilon}</script><p>&emsp;&emsp;最后，在做密度约束投影时，加入刚体粒子的贡献：</p><script type="math/tex; mode=display">\Delta p_i=\frac{1}{\rho_0}\Sigma_j(\lambda_i+\lambda_j)\nabla_{p_i}W(r,h)+\frac{1}{\rho_0}\Sigma_k\lambda_i\nabla_{p_i}W(r,h) \tag {35}</script><p>&emsp;&emsp;因为刚体粒子并没有流体的拉格朗日乘子，所以公式$(35)$中的刚体粒子项没有加上刚体粒子的拉格朗日乘子。接下来就是流体模拟算法的实现细节叙述，多线程库我采用了tbb。</p><h2 id="1、三次样条核函数"><a href="#1、三次样条核函数" class="headerlink" title="1、三次样条核函数"></a>1、三次样条核函数</h2><p>&emsp;&emsp;在计算流体密度时及其梯度时，我采用三次样条核函数：</p><script type="math/tex; mode=display">W(r,h)=\begin{cases}\frac8{\pi h^3}(6\frac{|r|^3}{h^3}-6\frac{|r|^2}{h^2}+1)\\\frac{16}{\pi h^3}(1-\frac{|r|}{h})^3 \end{cases} \tag {36}</script><p>&emsp;&emsp;相应地，其梯度为：</p><script type="math/tex; mode=display">\nabla W(r,h)=\begin{cases}\frac{48}{\pi h^3}(3(\frac{|r|}{h})^2-2(\frac{|r|}{h}))\frac{r}{h\cdot|r|}\\\frac{48}{\pi h^3}(1-\frac{|r|}{h})^2(-\frac{r}{h|r|}) \end{cases} \tag {37}</script><p>&emsp;&emsp;故核函数的计算代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">real SPHKernels::poly6WKernel(<span class="keyword">const</span> glm::vec3 &amp; r)</span><br><span class="line">&#123;</span><br><span class="line">real ret = <span class="number">0.0</span>;</span><br><span class="line">real rl = glm::length(r);</span><br><span class="line">real q = rl / m_radius;</span><br><span class="line">real h3 = m_radius * m_radius * m_radius;</span><br><span class="line"><span class="keyword">if</span> (q &lt;= <span class="number">0.5</span>)</span><br><span class="line">&#123;</span><br><span class="line">real q2 = q * q;</span><br><span class="line">real q3 = q2 * q;</span><br><span class="line">ret = <span class="number">8.0</span> / (M_PI * h3) * (<span class="number">6.0</span> * q3 - <span class="number">6.0</span> * q2 + <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ret = <span class="number">16.0</span> / (M_PI * h3) * <span class="built_in">pow</span>(<span class="number">1</span> - q, <span class="number">3.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">glm::vec3 SPHKernels::spikyWKernelGrad(<span class="keyword">const</span> glm::vec3 &amp; r)</span><br><span class="line">&#123;</span><br><span class="line">glm::<span class="function">vec3 <span class="title">ret</span><span class="params">(<span class="number">0.0f</span>)</span></span>;</span><br><span class="line">real rl = glm::length(r);</span><br><span class="line">real q = rl / m_radius;</span><br><span class="line">real h3 = m_radius * m_radius * m_radius;</span><br><span class="line"><span class="keyword">if</span> (rl &gt; <span class="number">1.0e-6</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> glm::vec3 gradq = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="number">1.0</span> / (rl * m_radius)) * r;</span><br><span class="line"><span class="keyword">if</span> (q &lt;= <span class="number">0.5</span>)</span><br><span class="line">&#123;</span><br><span class="line">ret = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="number">48.0</span> / (M_PI * h3) * q * (<span class="number">3.0</span> * q - <span class="number">2.0</span>)) * gradq;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">real factor = <span class="number">1.0</span> - q;</span><br><span class="line">ret = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="number">48.0</span> / (M_PI * h3) * (-factor * factor)) * gradq;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、粒子表示"><a href="#2、粒子表示" class="headerlink" title="2、粒子表示"></a>2、粒子表示</h2><p>&emsp;&emsp;在实现时，除了流体粒子，我们还要存储刚体粒子，但是刚体粒子又跟流体粒子稍微有点不同。刚体粒子的属性不需要每次重新计算，为此，我采用的方法是将流体粒子和刚体粒子统一存储，流体粒子在前面部分，刚体粒子在后面部分，这样可以通过索引下标判断当前是哪种粒子。</p><p>&emsp;&emsp;对于每一个粒子，我们需要存储它的质量、当前位置、上一次位置、静止时的位置、速度、加速度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParticleGroup</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;real&gt; m_masses;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;real&gt; m_invMasses;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt; m_position;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt; m_velocity;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt; m_oldPosition;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt; m_restPosition;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt; m_lastPosition;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt; m_acceleration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">.....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3、粒子领域搜索"><a href="#3、粒子领域搜索" class="headerlink" title="3、粒子领域搜索"></a>3、粒子领域搜索</h2><p>&emsp;&emsp;由前面的算法伪代码可以看到，在做流体约束投影之前，我们需要首先搜索每个粒子的邻居粒子。最简单暴力的方法是直接遍历每一个粒子，判断每一个粒子是否与当前的粒子相邻，这种算法的复杂度为$O(n^2)$（即对每一个粒子都要遍历$n$次），随着粒子数量的增多，搜索时间迅速增长。为此，我参考了<a href="https://github.com/InteractiveComputerGraphics/PositionBasedDynamics" target="_blank" rel="noopener">InteractiveComputerGraphics</a>的开源代码，采用一种<strong>空间哈希</strong>的算法，将算法的复杂度降低到$O(n)$。</p><p>&emsp;&emsp;每一个粒子都有它的位置向量$(x,y,z)$，我们将空间做一个网格分割，每个网格单元是边长为$e$的立方体，这样可以将整个三维空间都看成由一个一个网格单元的立方体构成（其实就是三维网格），每个单元按照立方体顶点位置最小的那个点做一个编号。那么如何知道每个粒子落在哪个网格呢？只需将粒子的位置向量除以网格单元边长即可，$(x/e,y/e,z/e)$就是粒子所在单元的编号，接下来有两种做法：一种就是根据$(x/e,y/e,z/e)$做一个随机哈希映射得到哈希索引值，将该粒子存储到哈希索引值指向的一个线性表；另一种方法是根据$(x/e,y/e,z/e)$直接按照某一个顺序存储到线性表中。显然前者会产生哈希冲突，故需要考虑冲突处理，这里我直接采用拉链法；而后者需要申请的存储空间依赖于包围盒的大小，而且一般情况下很多的存储空间都是没有粒子的。目前我采用前者的方法。每次我们存储到线性表中的是粒子的下标索引，避免大量的内存拷贝，因为这很耗时。</p><p>&emsp;&emsp;将每个粒子映射到一个线性表之后，我们就根据这个线性表获取每个粒子的邻居，此时我们只需查看粒子所在网格周围的$3\times 3\times 3=27$个网格，算法复杂度变为$O(27*n)=O(n)$。可以看到，这个算法思想很简单，而且效率很高。算法分成两个步骤，分别是粒子映射、邻域搜索。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NeighborSearch::neighborhoodSearch(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt;&amp; particles,</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;start, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> real factor = <span class="number">1.0</span> / m_cellGridSize;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> numParticles = particles.size();</span><br><span class="line">m_neighbors.assign(numParticles, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;());</span><br><span class="line"><span class="comment">// hash mapping.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; numParticles; ++x)</span><br><span class="line">&#123;</span><br><span class="line">glm::ivec3 cellPos;</span><br><span class="line">cellPos.x = <span class="built_in">floor</span>(particles[x].x * factor) + <span class="number">1</span>;</span><br><span class="line">cellPos.y = <span class="built_in">floor</span>(particles[x].y * factor) + <span class="number">1</span>;</span><br><span class="line">cellPos.z = <span class="built_in">floor</span>(particles[x].z * factor) + <span class="number">1</span>;</span><br><span class="line">SpatialCell *&amp;entry = m_spatialMap[&amp;cellPos];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (entry != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (entry-&gt;m_timeStamp != m_currentTimestamp)</span><br><span class="line">&#123;</span><br><span class="line">entry-&gt;m_timeStamp = m_currentTimestamp;</span><br><span class="line">entry-&gt;m_particleIndices.clear();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">SpatialCell *newEntry = <span class="keyword">new</span> SpatialCell();</span><br><span class="line">newEntry-&gt;m_particleIndices.reserve(m_maxParticlesPerCell);</span><br><span class="line">newEntry-&gt;m_timeStamp = m_currentTimestamp;</span><br><span class="line">entry = newEntry;</span><br><span class="line">&#125;</span><br><span class="line">entry-&gt;m_particleIndices.push_back(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash lookup.</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> end = start + num;</span><br><span class="line">parallel_for(blocked_range&lt;<span class="keyword">size_t</span>&gt;(start, end, <span class="number">5000</span>),</span><br><span class="line">[&amp;](blocked_range&lt;<span class="keyword">size_t</span>&gt; &amp;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> x = r.begin(); x != r.end(); ++x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cellPos1 = <span class="built_in">floor</span>(particles[x].x * factor);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cellPos2 = <span class="built_in">floor</span>(particles[x].y * factor);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cellPos3 = <span class="built_in">floor</span>(particles[x].z * factor);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++k)</span><br><span class="line">&#123;</span><br><span class="line">glm::ivec3 cellPos(cellPos1 + i, cellPos2 + j, cellPos3 + k);</span><br><span class="line">SpatialCell * <span class="keyword">const</span> *entry = m_spatialMap.query(&amp;cellPos);</span><br><span class="line"><span class="keyword">if</span> ((entry != <span class="literal">nullptr</span>) &amp;&amp; (*entry != <span class="literal">nullptr</span>) &amp;&amp;</span><br><span class="line">((*entry)-&gt;m_timeStamp == m_currentTimestamp))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> m = <span class="number">0</span>; m &lt; (*entry)-&gt;m_particleIndices.size(); ++m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> index = (*entry)-&gt;m_particleIndices[m];</span><br><span class="line"><span class="comment">// not consider itself.</span></span><br><span class="line"><span class="keyword">if</span> (index != x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> real dist = glm::length(particles[x] - particles[index]);</span><br><span class="line"><span class="keyword">if</span> (dist &lt; m_radius)</span><br><span class="line">&#123;</span><br><span class="line">m_neighbors[x].push_back(index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意，对于每个邻居网格的粒子我们还要判断一下目标粒子和当前粒子的距离，超过光滑核函数的半径不视为邻居粒子。采用的哈希映射函数如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> hashFunction&lt;glm::ivec3*&gt;(glm::ivec3* <span class="keyword">const</span> &amp;key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p1 = <span class="number">73856093</span> * key-&gt;x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p2 = <span class="number">19349663</span> * key-&gt;y;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p3 = <span class="number">83492791</span> * key-&gt;z;</span><br><span class="line"><span class="keyword">return</span> p1 + p2 + p3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、密度计算"><a href="#4、密度计算" class="headerlink" title="4、密度计算"></a>4、密度计算</h2><p>&emsp;&emsp;根据前面我们提到的考虑了刚体粒子的密度公式$(33)$，密度计算的代码如下所示。注意neighbors并不包含自己在内，还要在最开始加入自己的密度。比较简单，不再赘述。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> PositionBasedFluids::computeFluidDensity(</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>&amp; particleIndex,</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>&amp; numFluidParticle,</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt;&amp; position,</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;real&gt;&amp; mass,</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;&amp; neighbors,</span><br><span class="line"><span class="keyword">const</span> real &amp; density0,</span><br><span class="line">real &amp; density_err,</span><br><span class="line">real &amp; density)</span><br><span class="line">&#123;</span><br><span class="line">density = mass[particleIndex] * SPHKernels::getZeroWKenel();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; neighbors.size(); ++x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> neighborIndex = neighbors[x];</span><br><span class="line"><span class="keyword">if</span> (neighborIndex &lt; numFluidParticle)</span><br><span class="line">&#123;</span><br><span class="line">density += mass[neighborIndex] * SPHKernels::poly6WKernel(</span><br><span class="line">position[particleIndex] - position[neighborIndex]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">density += mass[neighborIndex] * SPHKernels::poly6WKernel(</span><br><span class="line">position[particleIndex] - position[neighborIndex]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">density_err = <span class="built_in">std</span>::max(density, density0) - density0;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的流体密度计算过程中，将会用到刚体粒子的质量值，也就是前面提到的公式$(34)$，不需要每一步重新生成，只需初始时预先计算好即可。注意公式$(34)$的计算只涉及到刚体粒子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calculate boundary's properties.</span></span><br><span class="line"><span class="function">NeighborSearch <span class="title">neighborhood</span><span class="params">(nBoundaryParticles, m_sphRadius)</span></span>;</span><br><span class="line">neighborhood.neighborhoodSearch(boundaryParticles, <span class="number">0</span>, nBoundaryParticles);</span><br><span class="line">parallel_for(blocked_range&lt;<span class="keyword">size_t</span>&gt;(<span class="number">0</span>, nBoundaryParticles, <span class="number">5000</span>),</span><br><span class="line">[&amp;](blocked_range&lt;<span class="keyword">size_t</span>&gt; &amp;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> x = r.begin(); x != r.end(); ++x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; &amp;neighbors = neighborhood.getNeighbors(x);</span><br><span class="line">real delta = SPHKernels::getZeroWKenel();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; neighbors.size(); ++y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> neighborIndex = neighbors[y];</span><br><span class="line">delta += SPHKernels::poly6WKernel(boundaryParticles[x] </span><br><span class="line">- boundaryParticles[neighborIndex]);</span><br><span class="line">&#125;</span><br><span class="line">delta = m_density0 / delta;</span><br><span class="line">m_particles.setMass(x + nFluidPartiles, delta);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="5、拉格朗日乘子计算"><a href="#5、拉格朗日乘子计算" class="headerlink" title="5、拉格朗日乘子计算"></a>5、拉格朗日乘子计算</h2><p>&emsp;&emsp;前面我们在讨论PBF的约束时，采用了等式约束，也就是$C_i(p_1,…,p_n)=0$，当不等于0时我们就做约束投影进行位移修正。但当$C_i(p_1,…,p_n)&lt;0$即$\rho_i&lt;\rho_0$时没有必要做约束投影，这是因为当$\rho_i&lt;\rho_0$时，粒子之间距离比较远，从而使得计算出来得密度小于静止密度。直观理解就是只有在粒子靠得比较近的（流体被压缩了）时候才需要将粒子分开，从而使流体表现出不可压缩的特性。如下图所示：</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/6.jpg" width="60%"></div></p><p>&emsp;&emsp;所以我们对约束函数做了clamp操作，小于等于0一致当成等于0，具体看下面代码的第12行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> PositionBasedFluids::computeLagrangeMultiplier(</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>&amp; particleIndex,</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>&amp; numFluidParticle,</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt;&amp; position,</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;real&gt;&amp; mass,</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;&amp; neighbors,</span><br><span class="line"><span class="keyword">const</span> real &amp; density,</span><br><span class="line"><span class="keyword">const</span> real &amp; density0,</span><br><span class="line">real &amp; lambda)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> real eps = <span class="number">1.0e-6</span>;</span><br><span class="line"><span class="keyword">const</span> real constraint = <span class="built_in">std</span>::max(density / density0 - <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">if</span> (constraint != <span class="number">0.0</span>)</span><br><span class="line">&#123;</span><br><span class="line">real sum_grad_cj = <span class="number">0.0</span>;</span><br><span class="line">glm::<span class="function">vec3 <span class="title">grad_ci</span><span class="params">(<span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; neighbors.size(); ++x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> neighborIndex = neighbors[x];</span><br><span class="line"><span class="keyword">if</span> (neighborIndex &lt; numFluidParticle)</span><br><span class="line">&#123;</span><br><span class="line">glm::vec3 grad_cj = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(+mass[neighborIndex] / density0)</span><br><span class="line">* SPHKernels::spikyWKernelGrad(position[particleIndex] - position[neighborIndex]);</span><br><span class="line">sum_grad_cj += <span class="built_in">pow</span>(glm::length(grad_cj), <span class="number">2.0</span>);</span><br><span class="line">grad_ci += grad_cj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">glm::vec3 grad_cj = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(+mass[neighborIndex] / density0)</span><br><span class="line">* SPHKernels::spikyWKernelGrad(position[particleIndex] - position[neighborIndex]);</span><br><span class="line">sum_grad_cj += <span class="built_in">pow</span>(glm::length(grad_cj), <span class="number">2.0</span>);</span><br><span class="line">grad_ci += grad_cj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum_grad_cj += <span class="built_in">pow</span>(glm::length(grad_ci), <span class="number">2.0</span>);</span><br><span class="line">lambda = -constraint / (sum_grad_cj + eps);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">lambda = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、密度约束投影"><a href="#6、密度约束投影" class="headerlink" title="6、密度约束投影"></a>6、密度约束投影</h2><p>&emsp;&emsp;对于每一个粒子，我们根据前面计算得到的密度和拉格朗日乘子做约束投影，对应前面的公式$(35)$，密度约束投影得到的是一个用于后面做修正的位置偏移向量，从而使得粒子位移后依然满足约束条件，这就是约束投影的本质。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> PositionBasedFluids::solveDensityConstraint(</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>&amp; particleIndex,</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>&amp; numFluidParticle,</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt;&amp; position,</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;real&gt;&amp; mass,</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;&amp; neighbors,</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;real&gt;&amp; lambda,</span><br><span class="line"><span class="keyword">const</span> real &amp;sphRadius,</span><br><span class="line"><span class="keyword">const</span> real &amp;density0,</span><br><span class="line">glm::vec3 &amp;deltaPos)</span><br><span class="line">&#123;</span><br><span class="line">deltaPos = glm::vec3(<span class="number">0.0f</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; neighbors.size(); ++x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> neighborIndex = neighbors[x];</span><br><span class="line"><span class="keyword">if</span> (neighborIndex &lt; numFluidParticle)</span><br><span class="line">&#123;</span><br><span class="line">glm::vec3 grad_cj = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(mass[neighborIndex] / density0) </span><br><span class="line">* SPHKernels::spikyWKernelGrad(position[particleIndex] - position[neighborIndex]);</span><br><span class="line">deltaPos += <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(lambda[particleIndex] + lambda[neighborIndex]) * grad_cj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">glm::vec3 grad_cj = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(mass[neighborIndex] / density0)</span><br><span class="line">* SPHKernels::spikyWKernelGrad(position[particleIndex] - position[neighborIndex]);</span><br><span class="line">deltaPos += <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(lambda[particleIndex]) * grad_cj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后我们按照算法伪代码的第8行到第19行的步骤将上述的三个步骤串联起来，迭代方法是雅可比迭代方式，按照先后顺序分别是密度计算、拉格朗日乘子计算、约束投影计算、位置修正。如下所示，在代码的第63行到第71行，我们根据约束投影计算得到的位移偏移量修正当前的粒子位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FluidModelSolver::constraintProjection()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> iter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nFluidParticles = m_lambda.size();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (iter &lt; m_maxIter)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// calculate density and lagrange multiplier.</span></span><br><span class="line">parallel_for(blocked_range&lt;<span class="keyword">size_t</span>&gt;(<span class="number">0</span>, nFluidParticles, <span class="number">1000</span>),</span><br><span class="line">[&amp;](blocked_range&lt;<span class="keyword">size_t</span>&gt; &amp;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> x = r.begin(); x != r.end(); ++x)</span><br><span class="line">&#123;</span><br><span class="line">real density_err;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; &amp;neighbors = m_neighborSearch-&gt;getNeighbors(x);</span><br><span class="line">PositionBasedFluids::computeFluidDensity</span><br><span class="line">(</span><br><span class="line">x,</span><br><span class="line">nFluidParticles,</span><br><span class="line">m_particles.getPositionGroup(),</span><br><span class="line">m_particles.getMassGroup(),</span><br><span class="line">neighbors,</span><br><span class="line">m_density0,</span><br><span class="line">density_err,</span><br><span class="line">m_density[x]</span><br><span class="line">);</span><br><span class="line">PositionBasedFluids::computeLagrangeMultiplier</span><br><span class="line">(</span><br><span class="line">x,</span><br><span class="line">nFluidParticles,</span><br><span class="line">m_particles.getPositionGroup(),</span><br><span class="line">m_particles.getMassGroup(),</span><br><span class="line">neighbors,</span><br><span class="line">m_density[x],</span><br><span class="line">m_density0,</span><br><span class="line">m_lambda[x]</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// perform density constraint.</span></span><br><span class="line">parallel_for(blocked_range&lt;<span class="keyword">size_t</span>&gt;(<span class="number">0</span>, nFluidParticles, <span class="number">1000</span>),</span><br><span class="line">[&amp;](blocked_range&lt;<span class="keyword">size_t</span>&gt; &amp;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> x = r.begin(); x != r.end(); ++x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; &amp;neighbors = m_neighborSearch-&gt;getNeighbors(x);</span><br><span class="line">PositionBasedFluids::solveDensityConstraint</span><br><span class="line">(</span><br><span class="line">x,</span><br><span class="line">nFluidParticles,</span><br><span class="line">m_particles.getPositionGroup(),</span><br><span class="line">m_particles.getMassGroup(),</span><br><span class="line">neighbors,</span><br><span class="line">m_lambda,</span><br><span class="line">m_sphRadius,</span><br><span class="line">m_density0,</span><br><span class="line">m_deltaPos[x]</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add the delta position to particles' position.</span></span><br><span class="line">parallel_for(blocked_range&lt;<span class="keyword">size_t</span>&gt;(<span class="number">0</span>, nFluidParticles, <span class="number">10000</span>),</span><br><span class="line">[&amp;](blocked_range&lt;<span class="keyword">size_t</span>&gt; &amp;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> x = r.begin(); x != r.end(); ++x)</span><br><span class="line">&#123;</span><br><span class="line">m_particles.getPosition(x) += m_deltaPos[x];</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">++iter;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、更新粒子速度"><a href="#7、更新粒子速度" class="headerlink" title="7、更新粒子速度"></a>7、更新粒子速度</h2><p>&emsp;&emsp;由前面的步骤我们得到了正确的粒子位置，接下来我们根据前一帧的位置和当前的粒子位置更新每个粒子的速度向量，这样就能得到正确的粒子速度向量。计算速度是直接根据速度的定义进行的，见下面代码里的velocityUpdateFirstOrder函数，注意这种方式计算速度只有一阶精度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// update velocities.</span></span><br><span class="line">parallel_for(blocked_range&lt;<span class="keyword">size_t</span>&gt;(<span class="number">0</span>, nFluidParticles, <span class="number">5000</span>),</span><br><span class="line">[&amp;](blocked_range&lt;<span class="keyword">size_t</span>&gt; &amp;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> x = r.begin(); x != r.end(); ++x)</span><br><span class="line">&#123;</span><br><span class="line">PositionBasedFluids::velocityUpdateFirstOrder(</span><br><span class="line">m_timeStep,</span><br><span class="line">m_particles.getMass(x),</span><br><span class="line">m_particles.getPosition(x),</span><br><span class="line">m_particles.getOldPosition(x),</span><br><span class="line">m_particles.getVelocity(x)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PositionBasedFluids::velocityUpdateFirstOrder(</span><br><span class="line"><span class="keyword">const</span> real &amp; h, </span><br><span class="line"><span class="keyword">const</span> real &amp; mass,</span><br><span class="line"><span class="keyword">const</span> glm::vec3 &amp; position,</span><br><span class="line"><span class="keyword">const</span> glm::vec3 &amp; oldPosition,</span><br><span class="line">glm::vec3 &amp; velocity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mass != <span class="number">0.0</span>)</span><br><span class="line">velocity = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="number">1.0</span> / h) * (position - oldPosition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、旋度控制"><a href="#8、旋度控制" class="headerlink" title="8、旋度控制"></a>8、旋度控制</h2><p>&emsp;&emsp;接下来我们给流体加上旋度细节，它的基本思路就是：通过添加一个体积力$f_i^{vorticity}$，在旋度粒子（可直观理解为比周围粒子旋转快的粒子，旋度$\omega_i$指向粒子$i$的旋转轴）处加速粒子的旋转运动，通过这种方式来增加系统的旋度细节。这个我们在前面已经讨论过，旋度控制力的计算方式如下：</p><script type="math/tex; mode=display">f_i^{vorticity}=\epsilon (N\times \omega_i) \\\omega_i=\nabla\times v=\Sigma_j(v_j-v_i)\times \nabla_{p_j}W(p_i-p_j,h) \\N=\frac{\eta}{|\eta|},\ \eta=\nabla|\omega|_i</script><p>&emsp;&emsp;关于这方面的内容，论文$[2]$的作者并没有作详细的说明，计算得到的旋度体积力$f_i^{vorticity}$如何作用到流体粒子上。所以我将计算得到的$f_i^{vorticity}$用于更新流体粒子的速度向量，感觉有点不太对劲，暂时先这样。代码见下面，首先计算流体的旋度向量，然后据此计算旋度体积力向量，最后给每个粒子加上在旋度体积力下的速度场偏移。代码不知道哪里有错，$\epsilon$一旦设置得有点大，整个流体就飞溅，很不正常。错误稍后再查。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FluidModelSolver::computeVorticityConfinement()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nFluidParticles = m_lambda.size();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> test = <span class="literal">true</span>;</span><br><span class="line">glm::<span class="function">vec3 <span class="title">record</span><span class="params">(-FLT_MAX)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt; deltaVelocity(nFluidParticles, glm::vec3(<span class="number">0.0f</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; nFluidParticles; ++x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; &amp;neighbors = m_neighborSearch-&gt;getNeighbors(x);</span><br><span class="line">glm::<span class="function">vec3 <span class="title">N</span><span class="params">(<span class="number">0.0f</span>)</span></span>;</span><br><span class="line">glm::<span class="function">vec3 <span class="title">curl</span><span class="params">(<span class="number">0.0f</span>)</span></span>;</span><br><span class="line">glm::<span class="function">vec3 <span class="title">curlX</span><span class="params">(<span class="number">0.0f</span>)</span></span>;</span><br><span class="line">glm::<span class="function">vec3 <span class="title">curlY</span><span class="params">(<span class="number">0.0f</span>)</span></span>;</span><br><span class="line">glm::<span class="function">vec3 <span class="title">curlZ</span><span class="params">(<span class="number">0.0f</span>)</span></span>;</span><br><span class="line"><span class="keyword">const</span> glm::vec3 &amp;velocity_i = m_particles.getVelocity(x);</span><br><span class="line"><span class="keyword">const</span> glm::vec3 &amp;position_i = m_particles.getPosition(x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; neighbors.size(); ++y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> neighborIndex = neighbors[y];</span><br><span class="line"><span class="keyword">if</span> (neighborIndex &gt;= nFluidParticles)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">const</span> glm::vec3 velGap = m_particles.getVelocity(neighborIndex) - velocity_i;</span><br><span class="line">curl += glm::cross(velGap, SPHKernels::spikyWKernelGrad(position_i - </span><br><span class="line">m_particles.getPosition(neighborIndex)));</span><br><span class="line">curlX += glm::cross(velGap, SPHKernels::spikyWKernelGrad(position_i + glm::vec3(<span class="number">0.01</span>, <span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">- m_particles.getPosition(neighborIndex)));</span><br><span class="line">curlY += glm::cross(velGap, SPHKernels::spikyWKernelGrad(position_i + glm::vec3(<span class="number">0.0</span>, <span class="number">0.01</span>, <span class="number">0.0</span>)</span><br><span class="line">- m_particles.getPosition(neighborIndex)));</span><br><span class="line">curlZ += glm::cross(velGap, SPHKernels::spikyWKernelGrad(position_i + glm::vec3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.01</span>)</span><br><span class="line">- m_particles.getPosition(neighborIndex)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (glm::isnan(curl).x || glm::isnan(curl).y || glm::isnan(curl).z)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">real curlLen = glm::length(curl);</span><br><span class="line">N.x = glm::length(curlX) - curlLen;</span><br><span class="line">N.y = glm::length(curlY) - curlLen;</span><br><span class="line">N.z = glm::length(curlZ) - curlLen;</span><br><span class="line">N = glm::normalize(N);</span><br><span class="line"><span class="keyword">if</span> (glm::isnan(N).x || glm::isnan(N).y || glm::isnan(N).z)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">glm::vec3 force = <span class="number">0.000010f</span> * glm::cross(N, curl);</span><br><span class="line">deltaVelocity[x] = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_timeMgr-&gt;getTimeStepSize()) * force;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; nFluidParticles; ++x)</span><br><span class="line">&#123;</span><br><span class="line">m_particles.getVelocity(x) += deltaVelocity[x];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9、流体粘性"><a href="#9、流体粘性" class="headerlink" title="9、流体粘性"></a>9、流体粘性</h2><p>&emsp;&emsp;然后就是人工粘性的计算，计算公式即前面讨论的公式$(32)$，如下所示。</p><script type="math/tex; mode=display">v_i^{new}=v_i+c\Sigma_j(v_i-v_j)\cdot W(p_i-p_j,h)</script><p>&emsp;&emsp;其中的$c$就是流体的粘性系数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FluidModelSolver::computeXSPHViscosity()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nFluidParticles = m_lambda.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; nFluidParticles; ++x)</span><br><span class="line">&#123;</span><br><span class="line">glm::vec3 &amp;velocity = m_particles.getVelocity(x);</span><br><span class="line"><span class="keyword">const</span> glm::vec3 &amp;position = m_particles.getPosition(x);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; &amp;neighbors = m_neighborSearch-&gt;getNeighbors(x);</span><br><span class="line">glm::<span class="function">vec3 <span class="title">sum_value</span><span class="params">(<span class="number">0.0f</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; neighbors.size(); ++y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> neighborIndex = neighbors[y];</span><br><span class="line"><span class="keyword">if</span> (neighborIndex &lt; nFluidParticles)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> real density_j = m_density[neighborIndex];</span><br><span class="line"><span class="keyword">const</span> glm::vec3 &amp;position_j = m_particles.getPosition(neighborIndex);</span><br><span class="line"><span class="keyword">const</span> glm::vec3 &amp;velocity_j = m_particles.getVelocity(neighborIndex);</span><br><span class="line">glm::vec3 tmp = velocity - velocity_j;</span><br><span class="line">tmp *= SPHKernels::poly6WKernel(position - position_j) </span><br><span class="line">* (m_particles.getMass(neighborIndex) / density_j);</span><br><span class="line">sum_value -= tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum_value *= m_viscosity;</span><br><span class="line">m_particles.setVelocity(x, velocity + sum_value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10、流体模拟"><a href="#10、流体模拟" class="headerlink" title="10、流体模拟"></a>10、流体模拟</h2><p>&emsp;&emsp;最后就是将以上的步骤串联起来，构成模拟一帧流体的全部步骤，代码如下所示，对应了前面PBF的伪代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FluidModelSolver::simulate()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nFluidParticles = m_lambda.size();</span><br><span class="line"><span class="keyword">const</span> real m_timeStep = m_timeMgr-&gt;getTimeStepSize();</span><br><span class="line"></span><br><span class="line"><span class="comment">// gravity acceleration.</span></span><br><span class="line">clearAccelerations();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update time step size by CFL condition</span></span><br><span class="line">updateTimeStepSizeCFL(<span class="number">0.0001</span>, <span class="number">0.005</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// predict particles' position and velocity.</span></span><br><span class="line">parallel_for(blocked_range&lt;<span class="keyword">size_t</span>&gt;(<span class="number">0</span>, nFluidParticles, <span class="number">5000</span>),</span><br><span class="line">[&amp;](blocked_range&lt;<span class="keyword">size_t</span>&gt; &amp;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> x = r.begin(); x != r.end(); ++x)</span><br><span class="line">&#123;</span><br><span class="line">m_deltaPos[x] = glm::vec3(<span class="number">0.0</span>);</span><br><span class="line">m_particles.setLastPosition(x, m_particles.getOldPosition(x));</span><br><span class="line">m_particles.setOldPosition(x, m_particles.getPosition(x));</span><br><span class="line">PositionBasedFluids::semiImplicitEuler(</span><br><span class="line">m_timeStep,</span><br><span class="line">m_particles.getMass(x),</span><br><span class="line">m_particles.getPosition(x),</span><br><span class="line">m_particles.getVelocity(x),</span><br><span class="line">m_particles.getAcceleration(x));</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// search each particle's neighborhood.</span></span><br><span class="line">m_neighborSearch-&gt;neighborhoodSearch(m_particles.getPositionGroup(),</span><br><span class="line"><span class="number">0</span>, nFluidParticles);</span><br><span class="line"></span><br><span class="line"><span class="comment">// perform density constraint.</span></span><br><span class="line">constraintProjection();</span><br><span class="line"></span><br><span class="line"><span class="comment">// update velocities.</span></span><br><span class="line">parallel_for(blocked_range&lt;<span class="keyword">size_t</span>&gt;(<span class="number">0</span>, nFluidParticles, <span class="number">5000</span>),</span><br><span class="line">[&amp;](blocked_range&lt;<span class="keyword">size_t</span>&gt; &amp;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> x = r.begin(); x != r.end(); ++x)</span><br><span class="line">&#123;</span><br><span class="line">PositionBasedFluids::velocityUpdateFirstOrder(</span><br><span class="line">m_timeStep,</span><br><span class="line">m_particles.getMass(x),</span><br><span class="line">m_particles.getPosition(x),</span><br><span class="line">m_particles.getOldPosition(x),</span><br><span class="line">m_particles.getVelocity(x)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute viscoity.</span></span><br><span class="line">computeXSPHViscosity();</span><br><span class="line">computeVorticityConfinement();</span><br><span class="line"></span><br><span class="line"><span class="comment">// update time stamp.</span></span><br><span class="line">m_neighborSearch-&gt;updateTimestamp();</span><br><span class="line">m_timeMgr-&gt;setTime(m_timeMgr-&gt;getTime() + m_timeStep);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、实现效果"><a href="#四、实现效果" class="headerlink" title="四、实现效果"></a>四、实现效果</h1><p>&emsp;&emsp;目前尚未了解流体渲染，所以只是简单地将流体粒子绘制出来，查看模拟的效果如何。绘制API采用了OpenGL的实例化渲染，UI界面则是接用的ImGui库。测试的场景是一个长方体的流体落下来，碰撞到盒子边界。</p><p>&emsp;&emsp;这是初始的流体块，长方体形状</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/7.png" width="60%"></div></p><p>&emsp;&emsp;然后是容器边界，如下所示，它将流体包含在内，也是采用粒子的形式表示。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/8.png" width="60%"></div></p><p>&emsp;&emsp;初始时由于重力加速度的作用，流体将落下来，碰撞到容器边界，然后流体翻滚，最终经过一段时间后趋于平静。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/ret1.png" width="60%"></div></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/ret2.png" width="60%"></div></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/ret3.png" width="60%"></div></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/ret4.png" width="60%"></div></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/ret5.png" width="60%"></div></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/ret6.png" width="60%"></div></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/ret7.png" width="60%"></div></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/ret8.png" width="60%"></div></p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>$[1]$ Müller, Matthias, et al. “Position based dynamics.” Journal of Visual Communication and Image Representation 18.2 (2007): 109-118.</p><p>$[2]$ Macklin, Miles, and Matthias Müller. “Position based fluids.” ACM Transactions on Graphics (TOG) 32.4 (2013): 104.</p><p>$[3]$ M¨ULLER, M., CHARYPAR, D., AND GROSS, M. 2003. Particlebased fluid simulation for interactive applications. In Proceedings of the 2003 ACM SIGGRAPH/Eurographics symposium on Computer animation, Eurographics Association, Aire-la-Ville, Switzerland, Switzerland, SCA ’03, 154–159.</p><p>$[4]$ Akinci, Nadir, et al. “Versatile rigid-fluid coupling for incompressible SPH.” ACM Transactions on Graphics (TOG) 31.4 (2012): 62.</p><p>$[5]$ <a href="https://zhuanlan.zhihu.com/p/48737753" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/48737753</a></p><p>$[6]$ <a href="https://zhuanlan.zhihu.com/p/49536480" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/49536480</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Fluid Simulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> Fluid Simulation </tag>
            
            <tag> Position Based Dynamics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光线追踪器Ray Tracer：进阶篇</title>
      <link href="/2019/05/23/RayTracer-Advance/"/>
      <url>/2019/05/23/RayTracer-Advance/</url>
      
        <content type="html"><![CDATA[<p>本篇文章在前面的基础上，丰富光线追踪器的各种特性。本篇内容主要包含添加纹理映射、平面光源和球形光源、三角网格模型渲染、增加天空盒背景、构建BVH树、tbb多线程渲染加速、蒙特卡罗积分方法、重要性采样，后面部分涉及的高等数学和概率论内容较多。相关的全部代码在<a href="https://github.com/ZeusYang/Ray-Tracer/releases/tag/1.1.0" target="_blank" rel="noopener">这里</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.10/blog/RayTracer-Advance/header.png" alt="header"></p><a id="more"></a><ul><li>纹理映射</li><li>三角网格模型</li><li>添加光源</li><li>天空盒背景</li><li>构建BVH树</li><li>tbb多线程渲染</li><li>蒙特卡罗积分</li><li>重要性采样</li><li>MC光线追踪</li><li>程序效果</li><li>参考资料</li></ul><h1 id="一、纹理映射"><a href="#一、纹理映射" class="headerlink" title="一、纹理映射"></a>一、纹理映射</h1><p>&emsp;&emsp;纹理映射对渲染的重要性不言而喻，为了丰富物体表面的细节，我们在这里创建一个纹理加载和采样的类。实际上，除了图片纹理，还有一些过程式产生的纹理。我们创建一个虚类$Texture$，并将$sample$类作为虚接口。然后创建子类$ImageTexture$，图片的加载我采用了stb_image库。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Texture</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Texture&gt; ptr;</span><br><span class="line">    </span><br><span class="line">    Texture() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Texture() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector3D <span class="title">sample</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span> &amp;u, <span class="keyword">const</span> <span class="keyword">float</span> &amp;v, <span class="keyword">const</span> Vector3D &amp;p)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageTexture</span> :</span> <span class="keyword">public</span> Texture</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *m_data;</span><br><span class="line">    <span class="keyword">int</span> m_width, m_height, m_channel;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ImageTexture&gt; ptr;</span><br><span class="line">    </span><br><span class="line">    ImageTexture() = <span class="keyword">default</span>;</span><br><span class="line">    ImageTexture(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;path);</span><br><span class="line">    <span class="keyword">virtual</span> ~ImageTexture();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector3D <span class="title">sample</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span> &amp;u, <span class="keyword">const</span> <span class="keyword">float</span> &amp;v, <span class="keyword">const</span> Vector3D &amp;p)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ImageTexture::ImageTexture(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;path)</span><br><span class="line">&#123;</span><br><span class="line">    m_data = stbi_load(path.c_str(), &amp;m_width, &amp;m_height, &amp;m_channel, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (m_data == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to load the image-&gt;"</span> &lt;&lt; path.c_str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector3D ImageTexture::sample(<span class="keyword">const</span> <span class="keyword">float</span> &amp;u, <span class="keyword">const</span> <span class="keyword">float</span> &amp;v, <span class="keyword">const</span> Vector3D &amp;p) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(u * m_width);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((<span class="number">1.0f</span> - v)*m_height) - <span class="number">0.001</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span>) i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; <span class="number">0</span>) j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; m_width - <span class="number">1</span>) i = m_width - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; m_height - <span class="number">1</span>) j = m_height - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = (j * m_width + i) * m_channel;</span><br><span class="line">    <span class="keyword">float</span> r = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(m_data[index + <span class="number">0</span>]) / <span class="number">255.0f</span>;</span><br><span class="line">    <span class="keyword">float</span> g = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(m_data[index + <span class="number">1</span>]) / <span class="number">255.0f</span>;</span><br><span class="line">    <span class="keyword">float</span> b = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(m_data[index + <span class="number">2</span>]) / <span class="number">255.0f</span>;</span><br><span class="line">    <span class="keyword">return</span> Vector3D(r, g, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;纹理坐标转换为像素数组下标要注意是否越界了，这里实现的纹理环绕方式是clamp。然后对于球体，我们要计算球体上每个点的纹理坐标，这里采用球面坐标的一个技巧。球体的上每一个点，都对应着一组唯一的方向角和天顶角$(\theta,\phi)$，我们把$(\theta,\phi)$映射到二维纹理坐标即可。映射方法如下：</p><script type="math/tex; mode=display">u = \phi/(2\pi) \\v = \theta/\pi \tag {1}</script><p>&emsp;&emsp;那么如何根据一个球面的点计算它的方向角和天顶角呢？从球面坐标$(\theta, \phi)$转到笛卡尔坐标$(x,y,z)$，不难理解，有如下关系：</p><script type="math/tex; mode=display">x = cos(\phi)cos(\theta) \\y = sin(\phi)cos(\theta) \\z = sin(\theta) \tag {2}</script><p>&emsp;&emsp;注意到$y/x=tan(\phi)$，所以我们可以采用下面的方式得到球面上点的天顶角和方位角：</p><script type="math/tex; mode=display">\phi=atan2(y,x)\\\theta=asin(2) \tag {3}</script><p>&emsp;&emsp;需要注意的是，$atan2$函数返回的角度范围是$[-\pi,+\pi]$，$asin$返回的角度范围是$[-\pi/2,\pi/2]$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getSphereUV</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;p, Vector2D &amp;tex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> phi = <span class="built_in">atan2</span>(p.z, p.x);</span><br><span class="line">    <span class="keyword">float</span> theta = <span class="built_in">asin</span>(p.y);</span><br><span class="line">    tex.x = <span class="number">1</span> - (phi + M_PI) / (<span class="number">2</span>*M_PI);</span><br><span class="line">    tex.y = (theta + M_PI/<span class="number">2</span>) / M_PI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、三角网格模型"><a href="#二、三角网格模型" class="headerlink" title="二、三角网格模型"></a>二、三角网格模型</h1><p>&emsp;&emsp;除了像球体、圆柱、圆锥等等这类有显示数学表达式的几何体，我们接触到更多的是没有表达式的网格模型。有显示的数学表达式当然好，因为我们直接直接求交点的解析解，非常准确。这里我们构建一个通用的网格模型类，它由一个个三角形构成。obj模型的导入我不再赘述，这里重点讲述了射线与三角形求交的推导过程。</p><p>&emsp;&emsp;一个三角形由空间中的三个顶点$P_0$、$P_1$、$P_2$的位置表示，三角形所在平面的法向量$N$可由下式计算而得：</p><script type="math/tex; mode=display">N=(P_1-P_0)\times(P_2-P_0) \tag {4}</script><p>&emsp;&emsp;平面与原点的距离$d$等于平面法向量$N$与平面中任意一点的内积的负数，这里选$P_0$，则$d$为：</p><script type="math/tex; mode=display">d = -N\cdot P_0 \tag {5}</script><p>&emsp;&emsp;则三角形所在的平面可以用四维向量$(N, -N\cdot P_0)$表示，实际上三角形所在平面的表达式为$N\cdot(x,y,z)+d=0$，首先我们求射线与该平面的交点，然后再判断交点是否在三角形内部。将射线方程$P(t) = S+tV$带入平面的方程，则有：</p><script type="math/tex; mode=display">N\cdot P(t)+d=0\\\to N\cdot S +(N\cdot V)t +d=0\\\to t=-\frac{(N\cdot S+d)}{N\cdot V}</script><p>&emsp;&emsp;通过以上的方程我们就可以得到射线在平面$L$上的交点处的$t$值。<strong>需要注意的是，当$N\cdot V=0$时，射线与平面平行，不存在交点。</strong>然后我们把$t$值带入射线方程即可求出射线与平面的交点$P$。接下来的问题是判断点$P$是否位于三角形内部，通过计算点$P$对于三角形的三个顶点$P_0$、$P_1$、$P_2$的重心坐标可以完成该判断。重心坐标是三角形顶点加权平均值，由三个标量$\omega_0$、$\omega_1$和$\omega_2$组成，有：</p><script type="math/tex; mode=display">P=\omega_0 P_0+\omega_1 P_1 + \omega_2 P_2 \tag {6}</script><p>&emsp;&emsp;其中，$\omega_0+\omega_1+\omega_2 =1$，用$1-\omega_1-\omega_2$代替$\omega_0$，可得：</p><script type="math/tex; mode=display">P=(1-\omega_1-\omega_2)P_0+\omega_1P_1+\omega_2P_2 \\=P_0+\omega_1(P_1-P_0)+\omega_2(P_2-P_0) \tag {7}</script><p>&emsp;&emsp;定义以下的等式：</p><script type="math/tex; mode=display">R=P-P_0\\Q_1=P_1-P_0\\Q_2=P_2-P_0 \tag {8}</script><p>&emsp;&emsp;将公式$(9)$带入公式$(8)$，可得：</p><script type="math/tex; mode=display">R=\omega_1Q_1+\omega_2Q_2 \tag {9}</script><p>&emsp;&emsp;分别给式$(10)$两边乘$Q_1$和$Q_2$可得以下两个方程：</p><script type="math/tex; mode=display">R\cdot Q_1=\omega_1Q_1^2+\omega_2(Q_1\cdot Q_2)\\R\cdot Q_2=\omega_1(Q_1\cdot Q_2)+\omega_2Q_2^2 \tag {10}</script><p>&emsp;&emsp;写成矩阵形式如下：</p><script type="math/tex; mode=display">\left[\begin{matrix}Q_1^2 & Q_1\cdot Q_2\\Q_1\cdot Q_2 & Q^2_2\end{matrix}\right]\left[\begin{matrix}\omega_1\\\omega_2\end{matrix}\right]=\left[\begin{matrix}R\cdot Q_1\\R\cdot Q_2\end{matrix}\right] \tag {11}</script><p>&emsp;&emsp;解以上关于$\omega_1$和$\omega_2$的方程，可得：</p><script type="math/tex; mode=display">\left[\begin{matrix}\omega_1\\\omega_2\end{matrix}\right]=\left[\begin{matrix}Q_1^2 & Q_1\cdot Q_2\\Q_1\cdot Q_2 & Q^2_2\end{matrix}\right]^{-1}\left[\begin{matrix}R\cdot Q_1\\R\cdot Q_2\end{matrix}\right] \\=\frac1{Q^2_1Q^2_2-(Q_1\cdot Q_2)^2}\left[\begin{matrix}Q_2^2 & -Q_1\cdot Q_2 \\-Q_1\cdot Q_2 & Q_1^2\end{matrix}\right]\left[\begin{matrix}R\cdot Q_1\\R\cdot Q_2\end{matrix}\right] \tag {12}</script><p>&emsp;&emsp;<strong>当且仅当$\omega_0$、$\omega_1$和$\omega_2$三个权值均为非负值时，点$R$位于三角形内部，由于$\omega_0=1-\omega_1-\omega_2$，则此时应有$\omega_1+\omega_2\leq 1$且$\omega1 \geq 0\  and\ \omega_2\geq0$。</strong>若顶点$P_0$、$P_1$和$P_2$上关联有一些属性信息，如颜色、法向量或者纹理坐标，则可以利用权值$\omega_0$、$\omega_1$和$\omega_2$对这些属性信息进行插值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MeshHitable::triangleHit(<span class="keyword">const</span> Ray &amp;ray, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t_min, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t_max,</span><br><span class="line">    HitRecord &amp;ret, <span class="keyword">const</span> Vertex &amp;p0, <span class="keyword">const</span> Vertex &amp;p1,</span><br><span class="line">    <span class="keyword">const</span> Vertex &amp;p2, <span class="keyword">const</span> Vector3D &amp;normal) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">float</span> n_dot_dir = normal.dotProduct(ray.getDirection());</span><br><span class="line">    <span class="comment">// no intersection.</span></span><br><span class="line">    <span class="keyword">if</span> (equal(n_dot_dir, <span class="number">0.0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">float</span> d = -normal.dotProduct(p0.m_position);</span><br><span class="line">    <span class="keyword">float</span> t = -(normal.dotProduct(ray.getOrigin()) + d) / n_dot_dir;</span><br><span class="line">    <span class="keyword">if</span> (t &lt; t_min || t &gt; t_max)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ret.<span class="keyword">m_t</span> = t;</span><br><span class="line">    ret.m_position = ray.pointAt(t);</span><br><span class="line">    ret.m_material = m_material;</span><br><span class="line">    <span class="comment">// judge inside or not.</span></span><br><span class="line">    Vector3D r = ret.m_position - p0.m_position;</span><br><span class="line">    Vector3D q1 = p1.m_position - p0.m_position;</span><br><span class="line">    Vector3D q2 = p2.m_position - p0.m_position;</span><br><span class="line">    <span class="keyword">float</span> q1_squaredLen = q1.getSquaredLength();</span><br><span class="line">    <span class="keyword">float</span> q2_squaredLen = q2.getSquaredLength();</span><br><span class="line">    <span class="keyword">float</span> q1_dot_q2 = q1.dotProduct(q2);</span><br><span class="line">    <span class="keyword">float</span> r_dot_q1 = r.dotProduct(q1);</span><br><span class="line">    <span class="keyword">float</span> r_dot_q2 = r.dotProduct(q2);</span><br><span class="line">    <span class="keyword">float</span> determinant = <span class="number">1.0f</span> / (q1_squaredLen * q2_squaredLen - q1_dot_q2 * q1_dot_q2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> omega1 = determinant * (q2_squaredLen * r_dot_q1 - q1_dot_q2 * r_dot_q2);</span><br><span class="line">    <span class="keyword">float</span> omega2 = determinant * (-q1_dot_q2 * r_dot_q1 + q1_squaredLen * r_dot_q2);</span><br><span class="line">    <span class="keyword">if</span> (omega1 + omega2 &gt; <span class="number">1.0f</span> || omega1 &lt; <span class="number">0.0f</span> || omega2 &lt; <span class="number">0.0f</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ret.m_normal = p0.m_normal * (<span class="number">1.0f</span> - omega1 - omega2) + p1.m_normal * omega1 + p2.m_normal * omega2;</span><br><span class="line">    ret.m_texcoord = p0.m_texcoord * (<span class="number">1.0f</span> - omega1 - omega2) + p1.m_texcoord * omega1 + p2.m_texcoord * omega2;</span><br><span class="line">    <span class="keyword">if</span> (ret.m_normal.dotProduct(ray.getDirection()) &gt; <span class="number">0.0f</span>)</span><br><span class="line">        ret.m_normal = -ret.m_normal;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;既然模型是由一个个三角形组成，那么在判断射线与当前的模型是否存在交点时，我们就遍历所有的三角形，一个一个三角形与射线做相交判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MeshHitable::hit(<span class="keyword">const</span> Ray &amp;ray, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t_min, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t_max, HitRecord &amp;ret) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    HitRecord tmpRec;</span><br><span class="line">    <span class="keyword">bool</span> hitAny = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">float</span> closestSoFar = t_max;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; m_indices.size(); x += <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> index1 = m_indices[x + <span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> index2 = m_indices[x + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> index3 = m_indices[x + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (triangleHit(ray, t_min, closestSoFar, tmpRec,</span><br><span class="line">            m_vertices[index1],</span><br><span class="line">            m_vertices[index2],</span><br><span class="line">            m_vertices[index3],</span><br><span class="line">            m_faceNormal[x / <span class="number">3</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            hitAny = <span class="literal">true</span>;</span><br><span class="line">            closestSoFar = tmpRec.<span class="keyword">m_t</span>;</span><br><span class="line">            ret = tmpRec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hitAny;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、添加光源"><a href="#三、添加光源" class="headerlink" title="三、添加光源"></a>三、添加光源</h1><p>&emsp;&emsp;光源是一种特殊的物体，一般情况下它不反射、折射光线，而是自身发射光线。因此，为了实现一个光源，当我们的射线碰撞到光源表面时，我们直接返回光源的碰撞点的颜色，不再做折射和反射。我们将发光的逻辑放到材质中，并将发光这一行为抽象为$emitted$函数。对于非光源物体，我们可以看成发出的光rgb均为0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Material</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Material&gt; ptr;</span><br><span class="line">    </span><br><span class="line">    Material() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Material() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(<span class="keyword">const</span> Ray &amp;in, <span class="keyword">const</span> HitRecord &amp;rec, ScatterRecord &amp;srec)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">scattering_pdf</span><span class="params">(<span class="keyword">const</span> Ray &amp;in, <span class="keyword">const</span> HitRecord &amp;rec,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> Ray &amp;scattered)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="number">1.0f</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector3D <span class="title">emitted</span><span class="params">(<span class="keyword">const</span> Ray &amp;in, <span class="keyword">const</span> HitRecord &amp;rec, <span class="keyword">const</span> <span class="keyword">float</span> &amp;u,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> <span class="keyword">float</span> &amp;v, <span class="keyword">const</span> Vector3D &amp;p)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> Vector3D(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiffuseLight</span> :</span> <span class="keyword">public</span> Material</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> m_emitTex;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;DiffuseLight&gt; ptr;</span><br><span class="line">    </span><br><span class="line">    DiffuseLight(<span class="keyword">unsigned</span> <span class="keyword">int</span> a) : m_emitTex(a) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(<span class="keyword">const</span> Ray &amp;in, <span class="keyword">const</span> HitRecord &amp;rec, ScatterRecord &amp;srec)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector3D <span class="title">emitted</span><span class="params">(<span class="keyword">const</span> Ray &amp;in, <span class="keyword">const</span> HitRecord &amp;rec, <span class="keyword">const</span> <span class="keyword">float</span> &amp;u,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> <span class="keyword">float</span> &amp;v, <span class="keyword">const</span> Vector3D &amp;p)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vector3D DiffuseLight::emitted(<span class="keyword">const</span> Ray &amp;in, <span class="keyword">const</span> HitRecord &amp;rec, <span class="keyword">const</span> <span class="keyword">float</span> &amp; u,</span><br><span class="line">                               <span class="keyword">const</span> <span class="keyword">float</span> &amp; v, <span class="keyword">const</span> Vector3D &amp; p) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> TextureMgr::getSingleton()-&gt;getTexture(m_emitTex)-&gt;sample(u, v, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样，对于任意的物体，我们都可以把它当作一个光源，只要给这个物体赋予的材质为$DiffuseLight$即可，同时要注意给发光材质设置一个纹理。</p><h1 id="四、天空盒背景"><a href="#四、天空盒背景" class="headerlink" title="四、天空盒背景"></a>四、天空盒背景</h1><p>&emsp;&emsp;之前在光线投射到背景中时，我们是直接返回设定的背景颜色（或通过插值、或直接指定背景）。同样，我们可以通过天空盒来丰富我们的场景细节。天空盒的相关原理比较简单，不再赘述。一个天空盒用边长为1的立方体表示，一个立方体我采用多个三角形构成立方体网格。这里有个问题，就是如何实现天空盒永远无法靠近的效果。在实时渲染时我们直接移除视图矩阵的位移，在光追这里我们直接将光源的出发点设为原点，方向保持不变，这样的一条射线再与天空盒立方体做求交并采样纹理即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Vector3D Skybox::sampleBackground(<span class="keyword">const</span> Ray &amp;ray)</span><br><span class="line">&#123;</span><br><span class="line">    HitRecord rec;</span><br><span class="line">    <span class="function">Ray <span class="title">r</span><span class="params">(Vector3D(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), ray.getDirection())</span></span>;</span><br><span class="line">    TextureMgr::ptr texMgr = TextureMgr::getSingleton();</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; m_indices.size(); x += <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> index1 = m_indices[x + <span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> index2 = m_indices[x + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> index3 = m_indices[x + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (triangleHit(r, <span class="number">0.001f</span>, FLT_MAX, rec,</span><br><span class="line">            m_vertices[index1], m_vertices[index2], m_vertices[index3],</span><br><span class="line">            m_vertices[index1].m_normal))</span><br><span class="line">        &#123;</span><br><span class="line">            index = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">map</span> = index / <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">return</span> texMgr-&gt;getTexture(m_cubemap[<span class="built_in">map</span>])</span><br><span class="line">                -&gt;sample(rec.m_texcoord.x, rec.m_texcoord.y, rec.m_position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Vector3D(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、构建BVH树"><a href="#五、构建BVH树" class="headerlink" title="五、构建BVH树"></a>五、构建BVH树</h1><p>&emsp;&emsp;在整个光线追踪算法的渲染过程中，计算量最大的就是光线与场景图元的求交过程。如果不采用一些特殊的数据结构而只是用线性表存储场景物体的话，那么每一条射线都需要对这个存储场景物体的线性表遍历一次，这个射线碰撞检测的算法时间复杂度是$O(n)$的，当$n$比较大时，那么射线碰撞检测需要耗费绝大部分的光线追踪算法时间。射线相交检测的时间是目前光线追踪算法从理论到大规模实际应用过渡的主要瓶颈。为此，我们需要一些特殊的场景管理数据结构来加速这个过程，BVH树（全称为bounding volume hierachy，即层次包围体）是光线追踪领域常用的一种3D场景管理数据结构。它的启发思路就是通过一个简单的包围盒把物体包围起来，射线和场景中的物体求交之前，会先和这个包围盒进行求交，如果该射线没有碰到该包围盒，表明该直线一定不会和包围盒里的物体相交；如果该射线碰到该包围盒，那么再来计算射线是否和包围盒中的物体相交。我们采用包围体是AABB包围盒（即axis-aligned minimum bounding box，轴对齐的最小包围盒，简称轴向包围盒）。</p><p>&emsp;&emsp;BVH树本质上是对空间做分割，然后采用二分搜索快速判断射线会与哪些包围盒发生碰撞，从而使得算法的时间复杂度从$O(n)$降到了$O(log(n))$，这是一个非常明显的算法效率的提升，特别是当$n$数量逐渐增大的时候。每一次的判断过程如下列伪代码所示。如果射线与父节点的包围盒有交点，则进一步判断子节点与射线的相交情况，否则直接退出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ray hits bounding object)</span><br><span class="line">    <span class="keyword">return</span> whether ray hits bounded objects</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;BVH树全称是层次包围盒，故名思意，它是一个树形的层次结构，父节点的包围盒包围全部子节点所在的空间，正如下图11所示。蓝色和红色的包围盒被包含在紫色的大包围盒中，它们可能重叠，并且它们不是有序的，它们只是单纯地被包含在内部。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.11/blog/RayTracer-Advance/4.png" width="50%"></div></p><center> 图1 层次包围盒 </center><p>&emsp;&emsp;对于图1，检测的伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hits purple)</span><br><span class="line">    hit0 = hits blue enclosed objects</span><br><span class="line">    hit1 = hits red enclosed objects</span><br><span class="line"><span class="keyword">if</span> (hit0 <span class="keyword">or</span> hit1)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span> <span class="keyword">and</span> info of closer hit</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h4 id="1、射线与包围盒相交判断"><a href="#1、射线与包围盒相交判断" class="headerlink" title="1、射线与包围盒相交判断"></a>1、射线与包围盒相交判断</h4><p>&emsp;&emsp;我们采用的紧凑的包围盒是AABB包围盒，计算出了包围盒之后，我们还需要一个判断射线是否与包围盒相交的办法，不需要求出射线与包围盒的交点，只需判断是否存在交点即可！我们采用一种常见的”slab“方法，它是基于AABB包围盒的。三维的AABB包围盒由三个轴的区间表示，假设分别为$[x_0,x_1]$、$[y_0,y_1]$、$[z_0,z_1]$。</p><p>&emsp;&emsp;对于每一个区间，我们首先判断射线在边界的投影交点情况。三维空间中，$x=x_0$和$x=x_1$是一个平面，射线在这两个平面上的交点的$x$值可以通过将$x=x_0$和$x=x_1$带入射线的方程$P(t)=S+tV$的$x$分量得到：</p><script type="math/tex; mode=display">x_0=S_x+t_0*V_x \\x_1=S_x+t_1*V_x \tag {13}</script><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.11/blog/RayTracer-Advance/hit.png" alt="1558612929075"></p><center> 图2 射线与边界的交点 </center><p>&emsp;&emsp;从而可以求出$t_0$和$t_1$如下所示：</p><script type="math/tex; mode=display">t_0=\frac{x_0-S_x}{V_x} \\t_1=\frac{x_1-S_x}{V_x} \tag {14}</script><p>&emsp;&emsp;关于$y$轴和$z$轴同理，我们求出了每条轴的交点分量，那么如何快速判断射线与包围盒区域是否存在相交的情况呢？为了便于理解，我们以二维的情况为例，则射线与二维的包围区域相交由如下三种情况：</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.11/blog/RayTracer-Advance/1.png" width="50%"></div></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.11/blog/RayTracer-Advance/2.png" width="50%"></div></p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.11/blog/RayTracer-Advance/3.png" width="50%"></div></p><center> 图3 射线与边界相交的三种情况 </center><p>&emsp;&emsp;我们求得$t$值是关于射线上的电到射线原点的距离，通过仔细观察上面的三张图片，我们可以发现在二维的情况下，当$max(t_0,t_2)&gt;min(t_1,t_3)$时，射线一定和区域存在交点，即射线与每个轴区间的左端点中的最大$t$值大于射线与每个轴区域间的右端点中的最小$t$值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hit</span><span class="params">(<span class="keyword">const</span> Ray &amp;ray, <span class="keyword">float</span> tmin, <span class="keyword">float</span> tmax)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> t0, t1, invD;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// x</span></span><br><span class="line">    invD = <span class="number">1.0f</span> / ray.getDirection().x;</span><br><span class="line">    t0 = (m_min.x - ray.getOrigin().x) * invD;</span><br><span class="line">    t1 = (m_max.x - ray.getOrigin().x) * invD;</span><br><span class="line">    <span class="keyword">if</span> (invD &lt; <span class="number">0.0f</span>)</span><br><span class="line">        <span class="built_in">std</span>::swap(t0, t1);</span><br><span class="line">    tmin = t0 &gt; tmin ? t0 : tmin;</span><br><span class="line">    tmax = t1 &lt; tmax ? t1 : tmax;</span><br><span class="line">    <span class="keyword">if</span> (tmax &lt;= tmin) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// y</span></span><br><span class="line">    invD = <span class="number">1.0f</span> / ray.getDirection().y;</span><br><span class="line">    t0 = (m_min.y - ray.getOrigin().y) * invD;</span><br><span class="line">    t1 = (m_max.y - ray.getOrigin().y) * invD;</span><br><span class="line">    <span class="keyword">if</span> (invD &lt; <span class="number">0.0f</span>)</span><br><span class="line">        <span class="built_in">std</span>::swap(t0, t1);</span><br><span class="line">    tmin = t0 &gt; tmin ? t0 : tmin;</span><br><span class="line">    tmax = t1 &lt; tmax ? t1 : tmax;</span><br><span class="line">    <span class="keyword">if</span> (tmax &lt;= tmin) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// z</span></span><br><span class="line">    invD = <span class="number">1.0f</span> / ray.getDirection().z;</span><br><span class="line">    t0 = (m_min.z - ray.getOrigin().z) * invD;</span><br><span class="line">    t1 = (m_max.z - ray.getOrigin().z) * invD;</span><br><span class="line">    <span class="keyword">if</span> (invD &lt; <span class="number">0.0f</span>)</span><br><span class="line">        <span class="built_in">std</span>::swap(t0, t1);</span><br><span class="line">    tmin = t0 &gt; tmin ? t0 : tmin;</span><br><span class="line">    tmax = t1 &lt; tmax ? t1 : tmax;</span><br><span class="line">    <span class="keyword">if</span> (tmax &lt;= tmin) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、BVH树的构建"><a href="#2、BVH树的构建" class="headerlink" title="2、BVH树的构建"></a>2、BVH树的构建</h4><p>&emsp;&emsp;首先我们要考虑如何构建一颗BVH树，BVH数据结构本质就是一颗二叉树。每个树节点右两个子节点，当然子节点之间不存在空间上的顺序关系。树的内部节点都不存储实际的场景物体，仅存储一个包围盒，叶子节点才存储真正的场景物体。构建BVH树的工作考虑的是如何构造一棵可以有效描述当前场景信息的二叉树。这当中的关键是如何对毫无规律地散落在场景中的众物体进行划分，即决定哪些物体该划分到左子树上，哪些物体该划分到右子树上。我们可以把这个问题抽象成一个”划分策略“——我们总会按照某种”策略“划分场景的，待会再考虑具体有哪些策略。另外，由于我们是在3D空间中工作，为了将问题简化，用分而治之的角度看，我们可以首先建立一个”原则“：即决定在哪根轴（x,y,z）上进行划分。”原则“与”策略“的不同之处在于，不管用何种”策略“，总是遵守同一种”原则“。</p><p>&emsp;&emsp;决定在哪根轴（x,y,z）上进行划分，取决于场景中的物体在各个轴上分布的“散度”。如果这些物体沿着某根轴分布得最为“松散”（即落在该轴上靠一侧最近的物体与另一侧最近的物体，二者距离为最大），那么就沿该轴进行划分。还有一种方式，即采用随机的方式选取划分的轴，这样当场景物体分散的很随机时，实现的效果还不错。这里我采用随机选取一个轴的方法进行划分。</p><p>&emsp;&emsp;确定了以哪根轴进行划分，接下来就要考虑“怎么划分”。我们目前暂时实现按终点划分的策略，顾名思义，取中点划分的意思就是在先前选取的轴上取其中点作为划分点，中点以左划分到左子树，中点以右划分到右子树。这种划分的实现方式最为简单，但往往效果不是太好：因为物体的分布往往不是均匀的。其中一种糟糕的情况（a）是，某侧子树上可能会拥挤过多的物体，而另一侧子树上却太少，这对查找效率影响很大。另外还有一种糟糕的情况（b），就是包围盒之间互相“重叠”（overlapped）的情况。如果两棵子树对应的包围盒“重叠”的越多，那么一条射线穿过该区域时同时击中两子树的概率也就越大，这就意味着两棵子树都得进行相交测试。当然我们目前实现的BVH树没有考虑那么多。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">BVHNode::BVHNode(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Hitable *&gt; &amp;<span class="built_in">list</span>, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// sort it randomly depend on</span></span><br><span class="line">    <span class="keyword">int</span> axis = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span> * drand48());</span><br><span class="line">    <span class="keyword">if</span> (axis == <span class="number">0</span>)</span><br><span class="line">        sort(&amp;<span class="built_in">list</span>[start], &amp;<span class="built_in">list</span>[end], boxCompareX);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (axis == <span class="number">1</span>)</span><br><span class="line">        sort(&amp;<span class="built_in">list</span>[start], &amp;<span class="built_in">list</span>[end], boxCompareY);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (axis == <span class="number">2</span>)</span><br><span class="line">        sort(&amp;<span class="built_in">list</span>[start], &amp;<span class="built_in">list</span>[end], boxCompareZ);</span><br><span class="line">    <span class="keyword">int</span> length = end - start;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">1</span>)</span><br><span class="line">        m_left = m_right = <span class="built_in">list</span>[start];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (length == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_left = <span class="built_in">list</span>[start];</span><br><span class="line">        m_right = <span class="built_in">list</span>[start + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_left = <span class="keyword">new</span> BVHNode(<span class="built_in">list</span>, start, start + length / <span class="number">2</span>);</span><br><span class="line">        m_right = <span class="keyword">new</span> BVHNode(<span class="built_in">list</span>, start + length / <span class="number">2</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bounding box.</span></span><br><span class="line">    AABB boxLeft, boxRight;</span><br><span class="line">    <span class="keyword">if</span> (!m_left-&gt;boundingBox(<span class="number">0</span>, <span class="number">0</span>, boxLeft) || !m_right-&gt;boundingBox(<span class="number">0</span>, <span class="number">0</span>, boxRight))</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"no bounding box in BVHNode constructor\n"</span>;</span><br><span class="line">    m_box = AABB::surroundingBox(boxLeft, boxRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、BVH树的遍历"><a href="#3、BVH树的遍历" class="headerlink" title="3、BVH树的遍历"></a>3、BVH树的遍历</h4><p>&emsp;&emsp;遍历BVH差不多是件直截了当的事情。在遍历的过程中，当发现射线与某个子节点相交的话，那么有无必要再检测下与另一子节点是否相交？答案是要的。因为两个节点无法保证完全“不重叠”，如下图所示，很有可能在检测另一子节点时发现了更近的交点。</p><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.11/blog/RayTracer-Advance/5.gif" width="60%"></div></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> BVHNode::hit(<span class="keyword">const</span> Ray &amp;ray, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t_min, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t_max, HitRecord &amp;ret) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_box.hit(ray, t_min, t_max))</span><br><span class="line">    &#123;</span><br><span class="line">        HitRecord leftRec, rightRec;</span><br><span class="line">        <span class="keyword">bool</span> hitLeft = m_left-&gt;hit(ray, t_min, t_max, leftRec);</span><br><span class="line">        <span class="keyword">bool</span> hitRight = m_right-&gt;hit(ray, t_min, t_max, rightRec);</span><br><span class="line">        <span class="comment">// both hit.</span></span><br><span class="line">        <span class="keyword">if</span> (hitLeft &amp;&amp; hitRight)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftRec.<span class="keyword">m_t</span> &lt; rightRec.<span class="keyword">m_t</span>)</span><br><span class="line">                ret = leftRec;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ret = rightRec;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// only left child.</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (hitLeft)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = leftRec;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (hitRight)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = rightRec;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、tbb多线程渲染"><a href="#六、tbb多线程渲染" class="headerlink" title="六、tbb多线程渲染"></a>六、tbb多线程渲染</h1><p>&emsp;&emsp;到目前为止我们实现的光追渲染逻辑都是串行的，只能利用单核cpu运行我们的渲染程序。对于简单的场景来说，渲染的速度还是挺快的。但是当我们渲染复杂的模型时，单核光追的渲染速度慢到爆炸，渲染时间随着模型的面片数迅速增长，渲染时间动不动就数十小时！为此，我们迫切需要加速渲染程序。我们可以看到，每个像素着色之间是没有联系的，一个像素的着色值与其周围的像素计算无关，所以像素的着色计算是可以并行计算的。我们首先实现在cpu上利用多核加速我们的渲染程序。直接操纵原生的线程API不是非常好，因为这样的话我们必须知道当前电脑的核心数，并据此将循环做一个分割，以便充分利用每个cpu核心。Intel开发的TBB是非常有用的线程库，它屏蔽了底层的线程细节，自动根据我们给定的工作量做线程分割，充分利用电脑的全部cpu资源，而且使用起来也非常简单。这里利用多核线程的渲染速度加速比大致是当前电脑的核心数，也就是说，电脑的cpu核心越多，渲染速度越快。tbb的官方网站请看<a href="https://www.threadingbuildingblocks.org/" target="_blank" rel="noopener">这里</a>。</p><p>&emsp;&emsp;tbb的全称是Thread Building Blocks，这里我们只用了tbb的parallel_for接口，它对一个给定的for循环做划分，然后每个划分并行计算。我采用的parallel_for接口函数如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_for</span><span class="params">( <span class="keyword">const</span> Range&amp; range, <span class="keyword">const</span> Body&amp; body, <span class="keyword">const</span> auto_partitioner&amp; partitioner )</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到出现了三个参数：range、body和partitioner。range就是我们要做并行的for循环下标范围，通常采用一维的迭代器blocked_range指定。这里我把二重循环展开成一重循环。然后body就是函数执行体，这里我通过c++11的lambda表达式指定。最后的partitioner是线程的划分方法，通常直接采用auto_partitioner。并行版的光追渲染如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Tracer::parallelThreadRender(Hitable *scene)</span><br><span class="line">&#123;</span><br><span class="line">    parallel_for(blocked_range&lt;<span class="keyword">size_t</span>&gt;(<span class="number">0</span>, m_config.m_height * m_config.m_width, <span class="number">10000</span>),</span><br><span class="line">        [&amp;](blocked_range&lt;<span class="keyword">size_t</span>&gt;&amp; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = r.begin(); i != r.end(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            Vector4D color;</span><br><span class="line">            <span class="keyword">size_t</span> col = i % m_config.m_width;</span><br><span class="line">            <span class="keyword">size_t</span> row = i / m_config.m_width;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; m_config.m_samplings; ++x)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">float</span> u = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(col + drand48()) / <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_config.m_width);</span><br><span class="line">                <span class="keyword">float</span> v = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(row + drand48()) / <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_config.m_height);</span><br><span class="line">                Ray ray = m_config.m_camera-&gt;getRay(u, v);</span><br><span class="line">                color += deNan(tracing(ray, scene, &amp;m_samplingList,<span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            color /= <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_config.m_samplings);</span><br><span class="line">            color.w = <span class="number">1.0f</span>;</span><br><span class="line">            <span class="comment">// gamma correction.</span></span><br><span class="line">            color = Vector4D(<span class="built_in">sqrt</span>(color.x), <span class="built_in">sqrt</span>(color.y), <span class="built_in">sqrt</span>(color.z), color.w);</span><br><span class="line">            <span class="keyword">if</span>(color.x &gt; <span class="number">1.0f</span>) color.x = <span class="number">1.0f</span>;</span><br><span class="line">            <span class="keyword">if</span>(color.y &gt; <span class="number">1.0f</span>) color.y = <span class="number">1.0f</span>;</span><br><span class="line">            <span class="keyword">if</span>(color.z &gt; <span class="number">1.0f</span>) color.z = <span class="number">1.0f</span>;</span><br><span class="line">            drawPixel(col, row, color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, auto_partitioner());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七、蒙特卡罗积分"><a href="#七、蒙特卡罗积分" class="headerlink" title="七、蒙特卡罗积分"></a>七、蒙特卡罗积分</h1><p>&emsp;&emsp;蒙特卡罗积分方法（Monte Carlo method）是数值分析中的一个重要分支，它的核心概念是使用随机性来解决确定性的问题。大数定律告诉我们，对于满足某个概率分布的随机变量，其数学期望所描述的积分可以使用这个随机变量随机抽样的样本均值来近似，因此在一定的误差范围内，我们能够使用大量的随机数来近似积分运算的结果。在计算机图形学中， 蒙特卡罗方法主要被应用于物理模拟以及光照传输中的积分运算，在离线渲染领域， 渲染方程几乎只能使用蒙特卡洛方法来进行计算。为了深入理解蒙特卡罗方法，我们首先要复习概率论相关的一些基础内容。以下的内容主要参考秦春林的那本书《全局光照技术：从离线到实时渲染》。</p><h2 id="1、概率密度函数、概率分布函数"><a href="#1、概率密度函数、概率分布函数" class="headerlink" title="1、概率密度函数、概率分布函数"></a>1、概率密度函数、概率分布函数</h2><p>&emsp;&emsp;概率密度函数（probability density function, 简称PDF）用于描述连续型随机变量所服从的概率分布，对于连续随机变量$X$，其概率密度函数$p(x)$是通过落于$x$附近的区间$[x,x+dx]$内的随机数的概率$p(x)dx$来定义的，然而这种定义方式并不直观，所以连续随机变量的概率分布一般通过更直观的称为概率分布函数或者累积分布函数（cumulative distribution function, 简称CDF）来定义，连续随机变量$X$的累积分布函数用大写字母$P$表示，其定义如下：</p><script type="math/tex; mode=display">P(y)=Pr\{x\leq y\}=\int_{-\infty}^yp(x)dx \tag {15}</script><p>&emsp;&emsp;可以看到，概率分布函数$P(y)$定义的是所有随机数的值中小于或等于$y$的随机变量的概率的积分，即理解成对于一个随机数$x$，其小于等于$y$的概率。因此，概率分布函数是一个递增函数。连续随机变量的概率密度函数$p(x)$具有以下的属性：</p><script type="math/tex; mode=display">\forall x:p(x) \geq 0 \tag {16}</script><script type="math/tex; mode=display">\int _{-\infty}^{+\infty}p(x)dx = 1 \tag {17}</script><script type="math/tex; mode=display">p(x)=\frac{dP(x)}{dx} \tag {18}</script><p>&emsp;&emsp;其中，式$(8)$说明了$p(x)$和$P(x)$的关系，前者是后者的导数。那么给定一个随机变量的区间范围$[a,b]$，随机变量的值$x$落在这个区间的概率计算如下：</p><script type="math/tex; mode=display">Pr\{a\leq x\leq b\}=Pr(x\leq b)-Pr(x\leq a)\\=P(b)-P(a)=\int_a^b p(z)dz \tag {19}</script><p>&emsp;&emsp;注意，这里的$Pr$函数是概率函数，而不是概率分布函数。直观来讲，概率密度函数$p(x)$给定的并不是随机变量取值$x$的概率，概率密度函数与轴围成的面积才是给定的概率。如下所示，图(a)是概率分布函数，而图$(b)$则是概率密度函数，给定区间的$[a,b]$的概率就是下图(b)中的面积，这也对应了公式$(19)$中的积分形式（积分的几何意义就是面积）。</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.11/blog/RayTracer-Advance/6.png" alt="6"></p><p>&emsp;&emsp;在这里，我们要特别关注的一个分布，那就是均匀分布！对于$[a,b]$区间上的均匀分，其概率密度函数为常数$\frac{1}{b-a}$，它表示随机抽样结果落于区间$[x,x+dx]$的概率在每个$x$处都相同。均匀分布的随机变量是整个蒙特卡罗方法的基础，在计算机模拟中，通过都是由系统提供的random()函数生成某个区间内的均匀分布，然后通过一些方法将均匀分布的随机变量转换为具有任意概率密度分布的随机变量。</p><h2 id="2、数学期望"><a href="#2、数学期望" class="headerlink" title="2、数学期望"></a>2、数学期望</h2><p>&emsp;&emsp;对于离散随机变量$X$，假设其值$x_i$对应的抽样概率为$p_i$，则该随机变量$X$的数学期望，或称为均值，为：</p><script type="math/tex; mode=display">E[X]=\Sigma_{i=1}^np_ix_i \tag {20}</script><p>&emsp;&emsp;数学期望代表的是对一个随机变量$X$进行抽样的平均结果。例如，对于骰子的例子，它的数学期望为：</p><script type="math/tex; mode=display">E[X_{die}]=\Sigma_{i=1}^6p_i x_i\\=\Sigma_{i=1}^6\frac16x_i=\frac16(1+2+3+4+5+6)=3.5 \tag {21}</script><p>&emsp;&emsp;相应地，对于连续随机变量$X$，其期望值为随机变量值$x$与其概率密度函数$p(x)$的乘积在全定义域上的积分：</p><script type="math/tex; mode=display">E[X]=\int_{-\infty}^{+\infty}xp(x)dx \tag {22}</script><p>&emsp;&emsp;连续随机变量$X$的数学期望为什么上面的公式$(22)$形式呢？这其实可以通过离散划分连续随便变量的定义域，然后按照离散数学期望得到一个近似的公式，当划分数趋向于无穷大且划分区间趋向于无穷小时，就是公式$(22)$的积分定义。如下所示：</p><script type="math/tex; mode=display">E[X]\approx\frac{b-a}{n}\Sigma_{i=1}^{n}x_ip(x_i) \\n\to+\infty,\ \frac{b-a}{n}\Sigma_{i=1}^{n}x_ip(x_i)=\int_a^bxp(x)dx=E[X]</script><p>&emsp;&emsp;通常我们对随机变量的函数更感兴趣。考虑以随机变量$X$为自变量的函数$Y=g(X)$，我们只知道随机变量$X$的概率分布，怎样求出随机变量$Y$的数学期望值呢？我们可以通过无意识的统计规律（law of the unconsicious statistician）来求随机变量函数的数学期望：设$Y$是随机变量$X$的函数$Y=g(X)$，且函数$g$是连续函数。若$X$是离散型随机变量，它的概率函数为$P\{X=x_i\}=p_i,i=1,2,…$，则有：</p><script type="math/tex; mode=display">E[Y]=E[g(X)]=\Sigma_{i=1}^{\infty}g(x_i)p_i \tag {23}</script><p>&emsp;&emsp;若$X$是连续型随机变量，它的概率密度函数为$p(x)$，则有：</p><script type="math/tex; mode=display">E[Y]=E[g(X)]=\int_{-\infty}^{+\infty}g(x)p(x)dx \tag {24}</script><p>&emsp;&emsp;该方法的重要意义在于：当求$E[Y]$时，我们不必求出$Y$的分布律或概率密度函数，只需利用$X$的分布律或概率密度即可。</p><h2 id="3、大数定律"><a href="#3、大数定律" class="headerlink" title="3、大数定律"></a>3、大数定律</h2><p>&emsp;&emsp;在统计学中，很多问题涉及对大量独立的随机变量抽样$x_i$的和进行处理，这些随机变量拥有相同的概率密度函数$p(x)$，这样的随机变量称为独立同分布的随机变量。当这些随机变量抽样的和被除以这些随机变量抽样的数量$N$时，我们就得到该随机变量的期望值的一个估计：</p><script type="math/tex; mode=display">E[X]\approx\overline X=\frac1N\Sigma_{i=1}^Nx_i \tag {25}</script><p>&emsp;&emsp;随着抽象数量$N$的增大，该估计的方差逐渐减小。当$N$的值足够大时，该估计的值就能够充分接近实际数学期望的值，这样我们就能够将统计方法用于解决确定性问题。大数定律（law of large numbers）告诉我们，当$N\to\infty$时，我们可以确定随机变量的统计平均值趋近于数学期望的值，即：</p><script type="math/tex; mode=display">P\{E[X]=lim_{N\to \infty}\frac1N\Sigma_{i=1}^Nx_i\} = 1 \tag {26}</script><p>&emsp;&emsp;因此，随机变量的数学期望可以通过对随机变量执行大量的重复抽样来近似计算得到。</p><h2 id="4、蒙特卡罗积分"><a href="#4、蒙特卡罗积分" class="headerlink" title="4、蒙特卡罗积分"></a>4、蒙特卡罗积分</h2><p>&emsp;&emsp;假设我们要计算一个一维函数的积分，如$\int_a^bf(x)dx$，数值分析方法通常采用一些近似方法来计算积分。一种最简单的求积分的方法就是采用梯形法，它通过将被积函数沿作用域上划分成多个区域，然后计算这些区域面积的和。这种方法不适用于多维积分的计算，计算机图形学领域用的最多的还是蒙特卡罗方法。大数定律用于对数学期望的积分公式进行估计，即对积分$\int_{-\infty}^{+\infty}xf(x)dx$进行估计。但是通常情况下我们要求的积分公式是对任意的一个函数积分，假设函数$g(x)$的定义域为$x\in S$（可以是一个多维空间），我们希望计算如下的积分：</p><script type="math/tex; mode=display">I=\int_{x\in S}g(x)dx \tag {27}</script><p>&emsp;&emsp;现在先不管公式$(27)$。由前面我们知道，给定任意一个关于随机变量的实数函数$f$以及服从$p(x)$概率密度函数的随机变量$x$，我们可以采用如下的公式来近似计算随机变量函数$f(x)$的数学期望：</p><script type="math/tex; mode=display">E[f(x)]=\int_{x\in S}f(x)p(x)dx\approx\frac1N\Sigma_{i=1}^Nf(x_i) \tag {28}</script><p>&emsp;&emsp;现在我们令公式$(27)$的被积函数$g(x)=f(x)p(x)$，则$f(x)=\frac{g(x)}{p(x)}$，那么公式$(28)$即可转变对公式$(27)$的形式，如下所示：</p><script type="math/tex; mode=display">\int_{x\in S}f(x)p(x)dx=\int_{x\in S}g(x)dx\approx\frac1N\Sigma_{i=1}^N\frac{g(x_i)}{p(x_i)} \tag {29}</script><p>&emsp;&emsp;可以看到通过这个变换，我们巧妙地转换成我们要求的积分公式，这就是蒙特卡洛方法求积分的核心思想。公式$(29)$的期望值为：</p><script type="math/tex; mode=display">E[\frac1N\Sigma_{i=1}^N\frac{g(x_i)}{p(x_i)}]=\frac1N\Sigma_{i=1}^NE[\frac{g(x_i)}{p(x_i)}]\\=\frac1NN\int\frac{g(x)}{p(x)}p(x)dx=\int g(x)dx \tag {30}</script><p>&emsp;&emsp;而公式$(29)$的估计方差为：</p><script type="math/tex; mode=display">\sigma^2=\frac1N\int(\frac{g(x)}{p(x)}-I)^2p(x)dx \tag {31}</script><p>&emsp;&emsp;可以看到，随着$N$的增大，公式$(31)$的方差随之降低（成反比），这就是一般蒙特卡罗方法的特点。实际上蒙特卡罗方法最大的问题就是估计逼近正确结果的速度非常慢。理论上，公式$(29)$的$p(x)$函数的选择可以是任意的，这也是蒙特卡罗方法的优点，因为通常很难生成与被积函数具有一致分布的随机数。从公式$(31)$也可以看出，通过使$g(x_i)$和$p(x_i)$的比值尽可能地小也可以减少估计误差，在实践上通常我们尽可能地使$p(x)$的分布接近于$g(x)$。综上，蒙特卡洛积分方法计算任意函数的积分步骤如下：</p><ul><li>首先对一个满足某种概率分布的随机数进行抽样；</li><li>使用该抽样值计算$\frac{g(x_i)}{p(x_i)}$的值，这称为该样本的贡献值；</li><li>最后对所有抽样点计算的结果求平均值。</li></ul><p>&emsp;&emsp;上面的步骤中，最困难的就是怎么样对一个具有任意分布函数的随机变量进行抽样。</p><h2 id="5、随机抽样"><a href="#5、随机抽样" class="headerlink" title="5、随机抽样"></a>5、随机抽样</h2><p>&emsp;&emsp;首先定义什么是抽样。给定一个定于域空间$\Omega_0$及其概率密度函数$p(x)$，其中$x\in \Omega_0$，则应有：</p><script type="math/tex; mode=display">\int_{\Omega_0}p(x)dx=1 \tag {32}</script><p>&emsp;&emsp;抽样是这样的一个算法，它能够从$p(x)$对应的随机变量$X$中产生一系列随机数$X1,X2,…$，使得对任意的$\Omega \in \Omega_0$满足如下：</p><script type="math/tex; mode=display">P\{X_k\in\Omega\}=\int_{\Omega}p(x)dx\leq 1 \tag {33}</script><p>&emsp;&emsp;在实现中我们并不能直接从$p(x)$产生随机数，在计算机程序中这个过程必须要求首先具有某些基础随机数的一个序列。我们通常采用均匀随机数random来产生一个均匀分布的随机数，然后用来作为抽象所需的基础随机数。目前抽象方法根据不同情况有不同的方法，这里目前只介绍逆变换算法。</p><p>&emsp;&emsp;逆变换算法的定义为：设$X$是连续随机变量，其概率分布函数为$P_X$，若随机变量$Y$是一个$[0,1]$上的均匀分布，则随机变量$P_X^{-1}(Y)$具有和$X$一样的概率分布。即我们通过概率分布函数的反函数来获取服从$p(x)$概率密度函数的随机变量，注意是概率分布函数$P(x)$的反函数，而不是概率密度函数$p(x)$的反函数。有时我们不知道概率分布函数，这时我们可以通过概率密度函数来求它的概率分布函数。</p><p>&emsp;&emsp;逆变换算法从一个概率密度函数$p(x)$产生随机数$X_i$的步骤如下：</p><ul><li>首先计算$p(x)$的概率分布函数：$P(x)=\int_0^xp(t)dt$；</li><li>其次计算累计分布函数的反函数：$P^{-1}(x)$；</li><li>然后从一个$[0,1]$上的均匀分布产生一个随机数$\phi$；</li><li>最后将随机数$\phi$代入$P^{-1}(x)$求出服从$p(x)$分布的随机数：$X_i=P^{-1}(\phi)$。</li></ul><h1 id="八、重要性采样"><a href="#八、重要性采样" class="headerlink" title="八、重要性采样"></a>八、重要性采样</h1><p>&emsp;&emsp;重要性采样（importance sampling）是蒙特卡罗方法中最重要的方差缩减方法，它通过选择对一个与目标概率分布具有相似形状的分布函数进行抽样来减少方差。<strong>重要性采样试图在被积函数中贡献较多的区域放置更多的采样点，以体现这部分区域的重要性。</strong>给定一个概率密度函数$p(x)$以及根据该概率密度函数抽样得到的$N$个随机数$x_i$，根据蒙特卡洛方法，被积函数$f(x)$的积分$I$（即前面的公式（27），被积函数换成$f(x)$）可以通过以下公式来近似估计：</p><script type="math/tex; mode=display">I_{N}=\frac1N\Sigma_{i=1}^N\frac{f(x_i)}{p(x_i)} \tag {34}</script><p>&emsp;&emsp;一个理想的估计的方差应该为$0$，即：</p><script type="math/tex; mode=display">\sigma^2=\frac1N\int(\frac{f(x)}{p(x)}-I)^2p(x)dx=0 \tag {35}</script><p>&emsp;&emsp;注意到公式$(35)$中，被积函数部分的$p(x)&gt;0$，故应有$(\frac{f(x)}{p(x)}-I)^2=0$，从而有如下的推导：</p><script type="math/tex; mode=display">p(x)=\frac{|f(x)|}{I} \tag {36}</script><p>&emsp;&emsp;若我们采用公式$(36)$得到的概率密度函数进行采样，那么方差就会被完全消除。但是公式$(36)$要求我们首先计算$I$的值，而这正是我们尝试去求解的，因而行不通。<strong>但是我们可以通过选取与被积函数$f(x)$具有相似形状的概率密度函数来减少方差。</strong>选择用于抽样的概率密度函数非常重要，尽管蒙特卡罗方法本身没有限制对概率密度函数的选择，但是选择不好的概率密度函数会大大增加蒙特卡罗估计的方差。</p><p>&emsp;&emsp;直观来讲，重要性采样就是根据被积函数$f(x)$的值来调整$p(x)$的概率分布。$f(x)$值大的地方，就多采样几个点；$f(x)$值小的地方，就少采样一些点。$p(x)$概率密度函数越是接近$f(x)$，蒙特卡罗方法估算的结果就越精确。</p><h2 id="1、复合重要性采样"><a href="#1、复合重要性采样" class="headerlink" title="1、复合重要性采样"></a>1、复合重要性采样</h2><p>&emsp;&emsp;在实际的情景中，计算机图形学中的被积函数通常非常复杂，它们可能是不连续的，通常在少数区间拥有奇点或者一些较大的值，所以很难找到一个简单的与被积函数相似的分布来做重要性采样。例如，我们考虑渲染中最普通的直接光源的计算公式，如下所示：</p><script type="math/tex; mode=display">L_o(p,v)=\int_{\Omega}f_r(l,v)\times L_i(p,l)cos\theta_id\omega_i \tag {37}</script><p>&emsp;&emsp;我们可以选取$L_i$或者$f_r$来做重要性采样，但是这种方式表现效果并不佳。考虑一个接近镜面的BRDF表面被一个球形面积光照亮的例子。如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.11/blog/RayTracer-Advance/7.png" alt="7"></p><p>&emsp;&emsp;若将面积光源的分布$L_i$作为重要性采样概率密度函数，因为物体表面几乎是镜面的，所以除了沿镜面反射光方向$\omega_i$，大部分光源上的采样对在最终的光照贡献都为0，因此估计的方差会非常大；而若采用BRDF分布作为重要性采样分布，那么对于小面积光源，依然会导致很大的方差。</p><p>&emsp;&emsp;因此，我们通常使用更复杂的采样方式，从而降低估算的方差。通常是根据被积函数的分布特征对其进行区域划分，然后在不同特征的区域上使用不同的分布函数进行采样，最后将这些结果以某种方式进行混合。复合重要性采样就是这一类的采样方法，它提供了一个策略使得可以从多个不同的分布中采样，然后对这些不同的采样结果进行加权组合。复合重要性采样可以简单地分成以下几步：</p><ul><li>首先，选取一系列的重要性分布$p1,…,p_n$，使得对于被积函数$f$的每一个函数值比较大的区域$\Omega_i$，在这个区域$\Omega_i$，分布函数$p_i$近似为被积函数$f$。通常一个复杂的被积函数是多个不相关的简单分布的乘积形式，所以这些重要性分布来源于这些简单分布。</li><li>然后，从每个分布$p_i$产生$n_i$个随机数$X_{i,1},…,X_{i,n_i}$；</li><li>最后，将所有的分布估算结果通过加权组合起来。</li></ul><p>&emsp;&emsp;复合重要性采样加权组合公式如下所示：</p><script type="math/tex; mode=display">I_N=\Sigma_{i=1}^n\frac1n_i\Sigma_{j=1}^{n_i}\omega_i(X_{i,j})\frac{f(X_{i,j})}{p_i(X_{i,j})} \tag {38}</script><p>&emsp;&emsp;公式$(38)$中的$\Sigma_{i=1}^n$表明结果是由$n$个采样技术的叠加，$\frac1n_i\Sigma_{j=1}^{n_i}\omega_i(X_{i,j})\frac{f(X_{i,j})}{p_i(X_{i,j})}$即表示一种特定的采样分布$p_i$的蒙特卡罗估算结果。可以看到，这里还乘上了一个权重系数$\omega_i(X_{i,j})$，$w_i(x)$可以在每个$x$处的值不一样，只要保证对于给定的$x$值，满足$\Sigma_{i=1}^n\omega_i(x)=1$即可。</p><h2 id="2、平衡启发式"><a href="#2、平衡启发式" class="headerlink" title="2、平衡启发式"></a>2、平衡启发式</h2><p>&emsp;&emsp;现在我们需要确定公式$(38)$中的权重系数计算方法。假设我们采用两个采样分布$p_1(x)$和$p_2(x)$，两个采样分布单独的采样估算结果分别为$\frac1{n_1}\Sigma\frac{f(x)}{p_1(x)}$和$\frac{1}{n_2}\Sigma\frac{f(x)}{p_2(x)}$，它们各自的方差都很大，所以我们给它们各自乘上一个系数进行加权组合。为了尽可能地发挥每个采样分布的优势，我们往往尽可能地保证在每个区域贡献较大的采样分布拥有更大的权值系数。考虑如下的权重系数函数：</p><script type="math/tex; mode=display">\omega_i(x)=\frac{c_ip_i(x)}{\Sigma_j^nc_jp_j(x)} \tag {39}</script><p>&emsp;&emsp;其中$c_i$是每个采样分布$p_i$对应的采样数量占比，即$c_i=\frac{n_i}{N}$，故$\Sigma_ic_i=1$，$c_i$在采样之前我们就可以确定得到。公式$(39)$被称为平衡启发式，将$c_i=\frac{n_i}{N}$和公式$(39)$代入到公式$(38)$，可以推导出如下的标准的蒙特卡洛估算方法（做一些消去）：</p><script type="math/tex; mode=display">I_N=\Sigma_{i=1}^n\frac1n_i\Sigma_{j=1}^{n_i}\omega_i(X_{i,j})\frac{f(X_{i,j})}{p_i(X_{i,j})}\\=\Sigma_{i=1}^n\Sigma_{j=1}^{n_i}\frac1n_i\frac{c_ip_i(X_{i,j})}{\Sigma_j^nc_jp_j(X_{i,j})}\frac{f(X_{i,j})}{p_i(X_{i,j})}\\=\Sigma_{i=1}^n\Sigma_{j=1}^{n_i}\frac1n_i\frac{\frac{n_i}{N}p_i(X_{i,j})}{\Sigma_j^nc_jp_j(X_{i,j})}\frac{f(X_{i,j})}{p_i(X_{i,j})}\\=\frac{1}{N}\Sigma_{i=1}^n\Sigma_{j=1}^{n_i}\frac{f(X_{i,j})}{\Sigma_j^nc_jp_j(X_{i,j})}\\=\frac{1}{N}\Sigma_{i=1}^n\Sigma_{j=1}^{n_i}\frac{f(X_{i,j})}{\overline p(X_{i,j})} \tag {40}</script><p>&emsp;&emsp;其中，$\overline p(x)$又被称为联合抽样分布，其数学公式如下所示。总的采样数$N$，每个分布$p_i$采集$n_i$个随机数$X_{i,j}$。以上就是平衡启发式的核心思想，一种很自然地组合多种采样分布的方式。我们采用一个单一的与$i$无关的分布$\overline p(x)$来表述这种组合方式。</p><script type="math/tex; mode=display">\overline p(x)=\Sigma_{i=1}^nc_ip_i(x) \tag {41}</script><h1 id="九、MC光线追踪"><a href="#九、MC光线追踪" class="headerlink" title="九、MC光线追踪"></a>九、MC光线追踪</h1><p>&emsp;&emsp;了解了相关的原理，接下来我们就实现一个MC（Monte Carlo，蒙特卡罗）光线追踪，主要的参考资料是Peter Shirley的《Ray Tracing_ the Rest of Your Life.pdf》。采样方法是复合重要性采样，复合的采样分布为Lambertian材质BRDF采样分布加上光源采样分布。</p><h2 id="1、立体角"><a href="#1、立体角" class="headerlink" title="1、立体角"></a>1、立体角</h2><p>&emsp;&emsp;在球面坐标中，一个方向向量我们通常采用$(\theta, \phi)$来唯一地表示，分别是天顶角和方位角。在衡量发光强度和辐射辐射度量学中，立体角有着广泛的应用。立体角描述了站在某一点的观察者观测到的物体大小的尺度，它被定义为球表面截取的面积微分与球半径平方之比，单位为球面度，写作$sr$。显然，立体角是二维圆心角的三维扩展：</p><script type="math/tex; mode=display">d\omega=\frac{dA}{r^2} \tag {42}</script><p>&emsp;&emsp;更一般的情况，立体角通常转换为$(\theta, \phi)$来表示，在单位球体上，$d\omega=dA$，我们转换成用$(\theta,\phi)$求微分面积$dA$。我们知道二维的弧长公式为：圆心角弧度数*半径（注意圆心角要换成弧度制）。如下所示，$\theta$和$\phi$对应的弧长为：</p><script type="math/tex; mode=display">s_{\theta}=\theta * r_{\theta} \\s_{\phi}=\phi * r_{\phi} \tag {43}</script><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.11/blog/RayTracer-Advance/8.png" alt="8"></p><center> 图4 求弧长 </center><p>&emsp;&emsp;公式$(43)$中的$r_\theta$其实就是球体半径，$r_\phi$与$r_\theta$的关系为：$r_\phi=r_\theta * sin\theta$。微分面积$dA$可以看成是一个矩形，宽和高分别为对应的弧长$d_{r_\phi}$和$d_{r_\theta}$，根据公式$(43)$我们可知$d_{r_\phi}$、$d_{r_\theta}$计算方法如下：</p><script type="math/tex; mode=display">d_{s_\theta}=r_{\theta}d\theta\\d_{s_\phi}=r_{\phi}d\phi \tag {44}</script><p>&emsp;&emsp;对于单位球体，$r_\theta=r=1,r_\phi=r_\theta*sin\theta=sin\theta$，从而立体角微分可转换成如下表示：</p><script type="math/tex; mode=display">d\omega=dA=d_{s_\theta}*d_{s_\phi}=sin\theta d\theta d\phi \tag {45}</script><h2 id="2、Lambertian材质BRDF采样"><a href="#2、Lambertian材质BRDF采样" class="headerlink" title="2、Lambertian材质BRDF采样"></a>2、Lambertian材质BRDF采样</h2><p>&emsp;&emsp;对于Lambertian材质我们假定其光线的散射分布与$cos\theta$成正比，这里的$\theta$是光线与表面法向量的夹角，也就是说在靠近法线的方向光线散射得比较多。当光线与表面法线夹角大于90度时，不发生光线散射。我们记得光线得散射概率密度函数pdf为$C*cos\theta$，其中$C$为某个常数。对于概率密度函数，我们必须保证其在全定义域上的（这里就是整个半球方向）积分为1，即有（涉及到了立体角转球面坐标表示形式和求定积分）：</p><script type="math/tex; mode=display">\int_{\Omega}C*cos\theta d\omega=C\int_0^{2\pi}d\phi\int_0^{\frac\pi2}cos\theta sin\theta d\theta\\=C*2\pi\int_0^{\frac\pi2}sin\theta d(\sin\theta)=C*2\pi * \frac12=1\\\to C=\frac{1}{\pi} \tag {46}</script><p>&emsp;&emsp;从而，Lambertian材质的光线散射概率密度函数PDF，记为$pS(direction)$，如下所示：</p><script type="math/tex; mode=display">pS(direction)=\frac{cos\theta}{\pi} \tag {47}</script><p>&emsp;&emsp;现在我们要根据这个概率密度函数生成服从该分布的随机半球向量，根据前面随机抽样部分，我们首先要求出它的概率分布函数。根据定义，概率分布函数就是对概率密度函数积分：</p><script type="math/tex; mode=display">P=\int_{\Omega}\frac{cos\theta}{\pi}d\omega=\int_0^{2\pi}d\phi\int_0^\theta \frac{cos\ t}{\pi}sin\ t\ dt\\=2\pi * \frac1\pi \int_0^{\theta}sin\ td(sin\ t)=sin^2\theta=1-cos^2\theta \tag {48}</script><p>&emsp;&emsp;根据逆变换算法，我们要取概率分布函数的反函数。这里有个小技巧，我们不需要调用反三角函数得到反函数，我们只需得到$cos\theta$即可。因为即便调用反三角函数得到$\theta$，后面我们将$(\theta,\phi)$转换成笛卡尔坐标向量的时候还是要调用三角函数$cos$，我们直接避免这个比较费时的过程。所以，任取一个$[0,1]$上均匀随机数$r_2$：</p><script type="math/tex; mode=display">cos\theta =\sqrt{1-r_2} \tag {49}</script><p>&emsp;&emsp;公式$(49)$只得到随机方向向量的$\theta$，我们还需要$\phi$。对于Lamberatian材质，光线在方向角上是均匀分布的，故其概率密度函数为$\frac{1}{2\pi}$，概率分布函数为$\frac{\phi}{2\pi}$。故对$\phi$的随机采样如下，任取一个$[0,1]$上的均匀随机数$r_1$：</p><script type="math/tex; mode=display">\frac{\phi}{2\pi}=r_1 \to \phi=r_1*2\pi \tag {50}</script><p>&emsp;&emsp;采样得方向向量的$(\theta,\phi)$，我们还要将其转换到笛卡尔坐标系的形式，这个过程不难理解，仔细观察图4，不再赘述。从而，服从公式$(47)$采样方向向量的代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">static</span> Vector3D <span class="title">randomCosineDir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> r1 = drand48();</span><br><span class="line">    <span class="keyword">float</span> r2 = drand48();</span><br><span class="line">    <span class="keyword">float</span> z = <span class="built_in">sqrt</span>(<span class="number">1</span>-r2);</span><br><span class="line">    <span class="keyword">float</span> phi = <span class="number">2</span> * M_PI * r1;</span><br><span class="line">    <span class="keyword">float</span> x = <span class="built_in">cos</span>(phi) * <span class="number">2</span> * <span class="built_in">sqrt</span>(r2);</span><br><span class="line">    <span class="keyword">float</span> y = <span class="built_in">sin</span>(phi) * <span class="number">2</span> * <span class="built_in">sqrt</span>(r2);</span><br><span class="line">    <span class="keyword">return</span> Vector3D(x,y,z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;值得注意的是，我们的采样是以物体表面的切线和法线构成的坐标轴为参考系的，其中z轴方向是表面的法线向量。因此，通过上面的代码采样的得到方向向量还要转到该局部坐标系下。这个过程可以构建矩阵，也可以直接将方向向量三个分量与轴向量相乘，最后相加得到。我们采用了后者，首先构建一个局部坐标的正交基（Ortho-normal Bases）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ONB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Vector3D m_axis[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ONB() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function">Vector3D <span class="title">u</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_axis[<span class="number">0</span>]; &#125;</span><br><span class="line">    <span class="function">Vector3D <span class="title">v</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_axis[<span class="number">1</span>]; &#125;</span><br><span class="line">    <span class="function">Vector3D <span class="title">w</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_axis[<span class="number">2</span>]; &#125;</span><br><span class="line"></span><br><span class="line">    Vector3D <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_axis[i]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Vector3D <span class="title">local</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b, <span class="keyword">float</span> c)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> u() * a + v() * b + w() * c; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Vector3D <span class="title">local</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;a)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> u() * a.x + v() * a.y + w() * a.z; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildFromW</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;n)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ONB::buildFromW(<span class="keyword">const</span> Vector3D &amp;n)</span><br><span class="line">&#123;</span><br><span class="line">    m_axis[<span class="number">2</span>] = n;</span><br><span class="line">    m_axis[<span class="number">2</span>].normalize();</span><br><span class="line"></span><br><span class="line">    Vector3D a;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(w().x) &gt; <span class="number">0.9f</span>)</span><br><span class="line">        a = Vector3D(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a = Vector3D(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    m_axis[<span class="number">1</span>] = w().crossProduct(a);</span><br><span class="line">    m_axis[<span class="number">1</span>].normalize();</span><br><span class="line"></span><br><span class="line">    m_axis[<span class="number">0</span>] = w().crossProduct(v());</span><br><span class="line">    m_axis[<span class="number">0</span>].normalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再构建一个PDF虚类，将PDF函数的函数值和采样抽线为$value$接口和$generate$接口。并继承它创建CosinePDF类，可以看到CosinePDF的$value$是按照公式$(47)$计算的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PDF</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">value</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;driection)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector3D <span class="title">generate</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CosinePDF</span> :</span> <span class="keyword">public</span> PDF</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ONB uvw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CosinePDF(<span class="keyword">const</span> Vector3D &amp;w) &#123; uvw.buildFromW(w); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">value</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;driection)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector3D <span class="title">generate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> CosinePDF::value(<span class="keyword">const</span> Vector3D &amp;direction) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Vector3D dir = direction;</span><br><span class="line">    dir.normalize();</span><br><span class="line">    <span class="keyword">float</span> cosine = dir.dotProduct(uvw.w());</span><br><span class="line">    <span class="keyword">if</span>(cosine &gt; <span class="number">0.0f</span>)</span><br><span class="line">        <span class="keyword">return</span> cosine / M_PI;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector3D CosinePDF::generate() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> uvw.local(Vector3D::randomCosineDir());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、直接光源采样"><a href="#3、直接光源采样" class="headerlink" title="3、直接光源采样"></a>3、直接光源采样</h2><p>&emsp;&emsp;显然在靠近光源的方向上，光照值对物体表面的颜色贡献更大，因此直接对光源采样对减少蒙特卡洛积分的方差有非常重要的作用。直接光源采样需要我们首先求采样分布的概率密度函数，目前我们先讨论一个最简单的光源例子，即矩形光源。假设矩形光源的面积为A，那么这个矩形光源的直接均匀采样的概率密度函数PDF为$\frac1A$，但是通常我们采样的单位是立体角微分，如下所示，</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.11/blog/RayTracer-Advance/9.png" alt="9"></p><center> 图5 直接光源采样 </center><p>&emsp;&emsp;$d\omega$与$dA$存在着一个对应关系，实际上我们可以通过前面提到的立体角定义（即公式$(42)$）得到$d\omega$与$dA$的关系如下所示，这个公式不难理解。其中$\alpha$夹角是采样方向向量与矩形表面的法线向量的夹角，$dAcos\alpha$实际上是将矩形的微分面积$dA$投影到采样方向$pq$上，这是因为从$pq$方向看去只能看到$dAcos\alpha$这个大小的面积，然后再比上半径长度的平方$||pq||^2$，这是立体角的定义。</p><script type="math/tex; mode=display">d\omega=\frac{dA*cos\alpha}{||pq||^2} \tag {51}</script><p>&emsp;&emsp;现在对$dA$的采样概率为$\frac{dA}{A}$，在球体方向上对立体角$d\omega$采样的概率为$p(direction)d\omega$，其中$p(direction)$是我们假定的对光源直接采样的概率密度函数。理论上来说，$\frac{dA}{A}$应该等于$p(direction)d\omega$，即有：</p><script type="math/tex; mode=display">p(direction)*\frac{dA*cos\alpha}{||pq||^2}=\frac{dA}{A}\\\to p(direction)=\frac{||pq||^2}{Acos\alpha} \tag {52}</script><p>&emsp;&emsp;公式$(52)$推导出了我们要找的直接光源采样的概率密度函数。根据逆变换算法，我们还要求它的概率分布函数从而生成服从公式$(52)$概率密度函数的随机采样方向，但是这里其实没有必要。我们直接在矩形光源上随机采样一个点，然后将这个采样点与物体表面上的点连接起来就是我们的直接光源采样方向，通过这个方法省去了比较复杂的高数推导过程。</p><p>&emsp;&emsp;有了以上的理论基础，我们接下来就实现矩形的直接光源采样。我这里的定义的一个矩形平面是由两个三角形组成，默认是在xz平面上的边长为2的正方形。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Vector3D Plane::random(<span class="keyword">const</span> Vector3D &amp;o) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Vector3D center = m_transformation.translation();</span><br><span class="line">    Vector3D leftCorner;</span><br><span class="line">    <span class="keyword">float</span> width = m_transformation.scale().x * <span class="number">2.0f</span>;</span><br><span class="line">    <span class="keyword">float</span> height = m_transformation.scale().z * <span class="number">2.0f</span>;</span><br><span class="line">    leftCorner.x = center.x - m_transformation.scale().x;</span><br><span class="line">    leftCorner.z = center.z - m_transformation.scale().z;</span><br><span class="line">    leftCorner.y = center.y;</span><br><span class="line">    <span class="function">Vector3D <span class="title">random_point</span><span class="params">(leftCorner.x + drand48() * width, leftCorner.y,</span></span></span><br><span class="line"><span class="function"><span class="params">                          leftCorner.z + drand48() * height)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> random_point - o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> Plane::pdfValue(<span class="keyword">const</span> Vector3D &amp;o, <span class="keyword">const</span> Vector3D &amp;v) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    HitRecord rec;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;hit(Ray(o,v), <span class="number">0.001f</span>, FLT_MAX, rec))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> area = m_transformation.scale().x * <span class="number">2.0f</span> * m_transformation.scale().z * <span class="number">2.0f</span>;</span><br><span class="line">        <span class="keyword">float</span> distance_squared = v.getSquaredLength();</span><br><span class="line">        <span class="keyword">float</span> cosine = <span class="built_in">fabs</span>(v.dotProduct(rec.m_normal) / v.getLength());</span><br><span class="line">        <span class="keyword">float</span> ret = distance_squared / (cosine * area);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;除了矩形区域光源，我们接下来还添加一个对球形区域光源的重要性采样。我们采取的坐标系依然是球形光源的局部坐标，而且依然是对光源区域做均匀采样。设想我们从物体表面上的一点望向一个球形区域光源，我们能够看到的区域就是我们要做均匀采样的区域，采样方法依然是围绕$(\theta,\phi)$展开，其中$\theta$是采样方向向量与物体表面的点与球心构成的方向向量的夹角。</p><p>&emsp;&emsp;显然方位角$\phi$依然是$[0,2\pi]$的范围，不然我们不可能看到一个圆形。而$\theta$则需要做一些限制，它现在有个上界，如下图6所示，P是物体表面上的一点，C为球形光源的球心，R是球形光源的半径。</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.11/blog/RayTracer-Advance/10.png" alt="10"></p><center> 图6 球形区域光源采样 </center><p>&emsp;&emsp;由图6可知，$sin(\theta_{max})=\frac{R}{||C-P||}$，相应的$\theta_{max}$的余弦值如下所示：</p><script type="math/tex; mode=display">cos(\theta_{max})=\sqrt{1-\frac{R^2}{||C-P||^2}} \tag {53}</script><p>&emsp;&emsp;然后我们是对$\theta$和$\phi$做均匀采样，$\phi$的采样与前面Lambertian采样一样，这里不再赘述。对于$\theta$，因为是均匀采样，那么它的概率密度函数必然也是一个常数，我们设为$C$，那么其概率分布函数计算如下：</p><script type="math/tex; mode=display">P=\int_{\Omega}Cd\omega =\int_0^{2\pi}d\phi \int_0^{\theta}Csint\ dt\\=2\pi C(1-cos\theta) \tag {54}</script><p>&emsp;&emsp;根据逆变换算法，取$[0,1]$上的均匀随机数$r_2$，并结合公式$(54)$的反函数，可得采样的$cos\theta$如下：</p><script type="math/tex; mode=display">cos(\theta)=1-\frac{r_2}{2\pi C} \tag {55}</script><p>&emsp;&emsp;现在有个问题就是$C$这个具体是多少？我们已经知道$\theta$的上界$\theta_{max}$，当$\theta=\theta_{max}$时，应该取概率分布函数值$P(\theta_{max})$为1，也就是$r_2=1$。故将其代入公式$(55)$我们可以得到$C$的具体表达式：</p><script type="math/tex; mode=display">C=\frac{1}{2\pi (1-cos\theta_{max})} \tag {56}</script><p>&emsp;&emsp;然后再将公式$(56)$和公式$(53)$代入公式$(55)$，可得：</p><script type="math/tex; mode=display">cos(\theta)=1+r_2(cos(\theta_{max})-1)\\=1+r_2(\sqrt{1-\frac{R^2}{||C-P||^2}}-1)\tag {57}</script><p>&emsp;&emsp;公式$(56)$j就是我们所需的概率密度函数，可以看起来不是很直观，这里我稍微解释一下。公式$(56)$其实就是我们从物体表面上的一点观测到的球形光源所占的立体角的倒数（注意，这里的立体角是以物体表面上的一点为球心而不是球形光源的球面上的立体角）！立体角的几何意义是就是单位球体上的面积，然后做一个倒数是因为我们是做均匀随机采样。立体角的求法如下所示：</p><script type="math/tex; mode=display">SolidAngle =\int_0^{2\pi}d\phi\int_0^{\theta_{max}}sin\theta d\theta=2\pi(1-cos(\theta_{max})) \tag {58}</script><p>&emsp;&emsp;可以看到公式$(58)$求得的结果就是公式$(56)$中的分母。取球形光源上的随机一点采样算法如下，就是公式$(57)$的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Vector3D <span class="title">randomToSphere</span><span class="params">(<span class="keyword">float</span> radius, <span class="keyword">float</span> distance_squared)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> r1 = drand48();</span><br><span class="line">    <span class="keyword">float</span> r2 = drand48();</span><br><span class="line">    <span class="keyword">float</span> z = <span class="number">1</span> + r2 * (<span class="built_in">sqrt</span>(<span class="number">1</span> - radius * radius/distance_squared) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">float</span> phi = <span class="number">2</span> * M_PI * r1;</span><br><span class="line">    <span class="keyword">float</span> x = <span class="built_in">cos</span>(phi) * <span class="built_in">sqrt</span>(<span class="number">1</span> - z * z);</span><br><span class="line">    <span class="keyword">float</span> y = <span class="built_in">sin</span>(phi) * <span class="built_in">sqrt</span>(<span class="number">1</span> - z * z);</span><br><span class="line">    <span class="keyword">return</span> Vector3D(x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对球形光源的随机采样以及求取概率密度函数的值如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> Sphere::pdfValue(<span class="keyword">const</span> Vector3D &amp;o, <span class="keyword">const</span> Vector3D &amp;v) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    HitRecord rec;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;hit(Ray(o,v), <span class="number">0.001f</span>, FLT_MAX, rec))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> cos_theta_max = <span class="built_in">sqrt</span>(<span class="number">1</span>- m_radius * m_radius/(m_center - o).getSquaredLength());</span><br><span class="line">        <span class="keyword">float</span> solid_angle = <span class="number">2</span> * M_PI * (<span class="number">1</span> - cos_theta_max);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0f</span> / solid_angle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector3D Sphere::random(<span class="keyword">const</span> Vector3D &amp;o) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Vector3D dir = m_center - o;</span><br><span class="line">    <span class="keyword">float</span> distance_squared = dir.getSquaredLength();</span><br><span class="line">    ONB uvw;</span><br><span class="line">    uvw.buildFromW(dir);</span><br><span class="line">    <span class="keyword">return</span> uvw.local(Vector3D::randomToSphere(m_radius, distance_squared));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、复合重要性采样"><a href="#2、复合重要性采样" class="headerlink" title="2、复合重要性采样"></a>2、复合重要性采样</h2><p>&emsp;&emsp;上面我们分别讨论了Lambertian采样和直接光源采样，然后我们要把它复合到一起。场景中通常有多个光源，所以直接光源采样应该对多个光源进行采样，我们采取均匀随机的策略，对于一束光线，它采样哪个光源由均匀的随机数决定，这样就能雨露均沾。复合的权重套用前面提到的平衡启发式，Lambertian采样和直接光源采样的权值各0.5，也就是各占一半。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MixturePDF</span> :</span> <span class="keyword">public</span> PDF</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    PDF* m_pdf[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MixturePDF(PDF *p0, PDF *p1) &#123; m_pdf[<span class="number">0</span>] = p0;m_pdf[<span class="number">1</span>] = p1; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">value</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;direction)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5f</span> * m_pdf[<span class="number">0</span>]-&gt;value(direction) + <span class="number">0.5f</span> * m_pdf[<span class="number">1</span>]-&gt;value(direction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector3D <span class="title">generate</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(drand48() &lt; <span class="number">0.5f</span>)</span><br><span class="line">            <span class="keyword">return</span> m_pdf[<span class="number">0</span>]-&gt;generate();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> m_pdf[<span class="number">1</span>]-&gt;generate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于多个光源的直接采样，我们采取均匀随机的策略，那么PDF值也应该是这些直接光源采样概率密度函数的平均值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> HitableList::pdfValue(<span class="keyword">const</span> Vector3D &amp;o, <span class="keyword">const</span> Vector3D &amp;v) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">float</span> weight = <span class="number">1.0f</span> / m_list.size();</span><br><span class="line">    <span class="keyword">float</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>;x &lt; m_list.size();++ x)</span><br><span class="line">        sum += m_list[x]-&gt;pdfValue(o, v);</span><br><span class="line">    <span class="keyword">return</span> sum * weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector3D HitableList::random(<span class="keyword">const</span> Vector3D &amp;o) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(drand48() * m_list.size());</span><br><span class="line">    <span class="keyword">return</span> m_list[index]-&gt;random(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后在光线追踪递归函数中加上我们的复合重要性采样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Vector4D Tracer::tracing(<span class="keyword">const</span> Ray &amp;r, Hitable *world, Hitable *light, <span class="keyword">int</span> depth)</span><br><span class="line">&#123;</span><br><span class="line">    HitRecord rec;</span><br><span class="line">    <span class="keyword">if</span> (world-&gt;hit(r, <span class="number">0.001f</span>, FLT_MAX, rec))</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (depth &lt; m_config.m_maxDepth &amp;&amp; material-&gt;scatter(r, rec, srec))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(srec.m_isSpecular)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> srec.m_attenuation * tracing(srec.m_scatterRay, world, light, depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Vector3D dir;</span><br><span class="line">                <span class="keyword">float</span> pdf_val;</span><br><span class="line">                <span class="keyword">if</span>(!m_samplingList.isEmpty())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="function">HitablePDF <span class="title">light_pdf</span><span class="params">(light, rec.m_position)</span></span>;</span><br><span class="line">                    <span class="function">MixturePDF <span class="title">mix_pdf</span><span class="params">(&amp;light_pdf, srec.m_pdf.get())</span></span>;</span><br><span class="line">                    dir = mix_pdf.generate();</span><br><span class="line">                    pdf_val = mix_pdf.value(dir);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dir = srec.m_pdf-&gt;generate();</span><br><span class="line">                    pdf_val = srec.m_pdf-&gt;value(dir);</span><br><span class="line">                &#125;</span><br><span class="line">                Ray scattered = Ray(rec.m_position, dir);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> emitted + srec.m_attenuation * material-&gt;scattering_pdf(r, rec, scattered)</span><br><span class="line">                        * tracing(scattered, world, light, depth + <span class="number">1</span>) / pdf_val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> emitted;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// background color.</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="程序效果"><a href="#程序效果" class="headerlink" title="程序效果"></a>程序效果</h1><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.10/blog/RayTracer-Advance/ret1.png" alt="ret1"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.10/blog/RayTracer-Advance/ret2.png" alt="ret2"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.10/blog/RayTracer-Advance/ret3.png" alt="ret3"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.10/blog/RayTracer-Advance/ret4.png" alt="ret4"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.10/blog/RayTracer-Advance/ret5.png" alt="ret5"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.10/blog/RayTracer-Advance/ret6.png" alt="ret6"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.11/blog/RayTracer-Advance/ret7.png" alt="ret7"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.10/blog/RayTracer-Advance/ret8.png" alt="ret8"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.10/blog/RayTracer-Advance/header.png" alt="header"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>$[1$ <a href="http://www.thegibook.com/" target="_blank" rel="noopener">http://www.thegibook.com/</a></p><p>$[2]$ Peter Shirley. <a href="https://www.amazon.com/Ray-Tracing-Weekend-Minibooks-Book-ebook/dp/B01B5AODD8/ref=sr_1_1?ie=UTF8&amp;qid=1547695669&amp;sr=8-1&amp;keywords=Peter+Shirley" target="_blank" rel="noopener">Ray Tracing in One Weekend</a>. Amazon Digital Services LLC, January 26, 2016.</p><p>$[3]$ <a href="https://software.intel.com/en-us/node/506045?_ga=2.114625223.1582767698.1558613799-2057498546.1558613799" target="_blank" rel="noopener">https://software.intel.com/en-us/node/506045?_ga=2.114625223.1582767698.1558613799-2057498546.1558613799</a></p><p>$[4]$ <a href="https://blog.csdn.net/zoufeiyy/article/details/1887579" target="_blank" rel="noopener">https://blog.csdn.net/zoufeiyy/article/details/1887579</a></p><p>$[5]$ <a href="https://www.jianshu.com/p/b570b1ba92bb" target="_blank" rel="noopener">https://www.jianshu.com/p/b570b1ba92bb</a></p><p>$[6]$ <a href="https://blog.csdn.net/libing_zeng/article/details/74989755" target="_blank" rel="noopener">https://blog.csdn.net/libing_zeng/article/details/74989755</a></p><p>$[7]$ <a href="https://www.qiujiawei.com/solid-angle/" target="_blank" rel="noopener">https://www.qiujiawei.com/solid-angle/</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Ray Tracer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> Ray Tracer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光线追踪器Ray Tracer：入门篇</title>
      <link href="/2019/05/08/RayTracer-Basis/"/>
      <url>/2019/05/08/RayTracer-Basis/</url>
      
        <content type="html"><![CDATA[<p>光线追踪技术是计算机图形学的一类全局光照算法，目前的影视行业大多都采用光线追踪做离线渲染。本章开始构建一个光线追踪离线渲染器（路径追踪），深入理解光线追踪的技术原理。主要参考资料为Peter Shirley的《Ray Tracing in One Weekend》。数学库沿用之前自己写的3D数学库，这方面的东西不再赘述。相关的完全代码在<a href="https://github.com/ZeusYang/Ray-Tracer" target="_blank" rel="noopener">这里</a>。</p><p><div align="left"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.9/blog/RayTracer-Basis/header2.png"></div></p><a id="more"></a><ul><li>光线追踪纵览</li><li>实现光线追踪渲染器</li><li>程序结果</li></ul><h1 id="一、光线追踪纵览"><a href="#一、光线追踪纵览" class="headerlink" title="一、光线追踪纵览"></a>一、光线追踪纵览</h1><p>&emsp;&emsp;光线追踪 (Ray Tracing) 算法是一种基于真实光路模拟的计算机三维图形渲染算法，相比其它大部分渲染算法，光线追踪算法可以提供更为真实的光影效果。此算法由 Appel 在 1968 年初步提出，1980 年由Whitted 改良为递归算法并提出全局光照模型。直到今天，光线追踪算法仍是图形学的热点，大量的改进在不断涌现。基于对自然界光路的研究, 光线追踪采取逆向计算光路来还原真实颜色。追踪的过程中涵盖了光的反射、折射、吸收等特性 (精确计算)， 并辅以其它重要渲染思想 (进一步模拟)。 其中包含了重要方法，诸如冯氏光照模型 (Phong Shading)、辐射度(Radiosity)、光子映射 (Photon Mapping)、蒙特卡罗方法 (Monte Carlo) 等等。鉴于光线追踪算法对场景仿真程度之高，其被普遍认为是计算机图形学的核心内容， 以及游戏设计、电影特效等相关领域的未来方向。 近年来由于硬件系统的迅速改良， 基于分布式、GPU， 甚至实时渲染的光线追踪显卡也纷纷出现（本人就是入手了一块实时光追显卡rtx2070）。</p><p>&emsp;&emsp;光线追踪算法是一种非常自然的技术，相比于光栅化的方法，它更加简单、暴力、真实。与光栅化根据物体计算所在的像素的方式不同，光线路径追踪的方法是一个相反的过程，它在于用眼睛去看世界而不是世界如何到达眼中。如下图所示，从视点出发向屏幕上每一个像素发出一条光线View Ray，追踪此光路并计算其逆向光线的方向，映射到对应的像素上。通过计算光路上颜色衰减和叠加，即可基本确定每一个像素的颜色。</p><p><img src="https://img-my.csdn.net/uploads/201211/13/1352736355_8683.png" alt="img"></p><center> 图1 光线追踪示意图 </center><p>&emsp;&emsp;可以看到光线追踪是一个递归的过程。发射一束光线到场景，求出光线和几何图形间最近的交点，如果该交点的材质是反射性或折射性的，可以在该交点向反射方向或折射方向继续追踪，如此递归下去，直到设定的最大递归深度或者射线追踪到光源处（或者背景色），如此便计算处一个像素的着色值。</p><p>&emsp;&emsp;基本的光线追踪tracing()递归算法如下所示：</p><p>&emsp;&emsp;<strong>Algorithm 1: 光线追踪递归算法</strong></p><p>&emsp;&emsp;<strong>Input: 射线ray</strong></p><p>&emsp;&emsp;<strong>Output: 反向光颜色</strong></p><p>&emsp;&emsp;<strong>Function tracing():</strong></p><p>&emsp;&emsp;<strong>if no intersection with any object then</strong><br>&emsp;&emsp;&emsp;&emsp;<strong>return background color</strong><br>&emsp;&emsp;<strong>else</strong><br>&emsp;&emsp;&emsp;&emsp;<strong>obj $\leftarrow$  find nearest object from the ray;</strong><br>&emsp;&emsp;&emsp;&emsp;<strong>reflect ray $\leftarrow$getReflectRay(obj);</strong><br>&emsp;&emsp;&emsp;&emsp;<strong>refract ray $\leftarrow$ getRefractRay(obj);</strong><br>&emsp;&emsp;&emsp;&emsp;<strong>main color $\leftarrow$ the radiance of obj;</strong><br>&emsp;&emsp;&emsp;&emsp;<strong>reflect color $\leftarrow$ tracing(reflect ray);</strong><br>&emsp;&emsp;&emsp;&emsp;<strong>refract color $\leftarrow$ tracing(refract ray);</strong></p><p>&emsp;&emsp;&emsp;&emsp;<strong>return mix(main color, reflect color, refract color);</strong></p><h1 id="二、实现光线追踪渲染器"><a href="#二、实现光线追踪渲染器" class="headerlink" title="二、实现光线追踪渲染器"></a>二、实现光线追踪渲染器</h1><p>&emsp;&emsp;采用C++语言不借助第三方图形渲染API实现一个简易的光线追踪器，为了将最后的结果显示出来，我采用<a href="https://github.com/nothings/stb" target="_blank" rel="noopener">stb_image</a>将计算得到的像素矩阵保存为png图片。本篇实现的光线追踪只包含求交运行、计算光线反射和折射向量、反走样、景深等较为初级的方面，而实现的材质包含磨砂材质、玻璃材质和金属材质。</p><h2 id="1、摄像机"><a href="#1、摄像机" class="headerlink" title="1、摄像机"></a>1、摄像机</h2><p>&emsp;&emsp;与光栅化的空间变换过程相反，光线追踪大部分操作都是在世界空间中进行，因而需要将屏幕空间的像素坐标变换到世界空间中，并相应地发射出一条射线。在这里我们不再构建矩阵，直接求解出摄像机的三个坐标轴，然后根据视锥体的视域fov和屏幕的宽高比aspect得到每个像素发射出来的射线。</p><p>&emsp;&emsp;首先我们创建一个射线类$Ray$，射线通常用一个射线原点$m_origin$和射线方向$m_direction$表示，射线上的每个点则表示为$p(t)=m_origin+t*m_direction$，射线上每一个独立的点都有一个自己唯一的$t$值。因而创建的$Ray$类如下所示，其中$pointAt$函数根据给定的$t$值返回相应的射线上的点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Vector3D m_origin;</span><br><span class="line">    Vector3D m_direction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ctor/dtor.</span></span><br><span class="line">    Ray() = <span class="keyword">default</span>;</span><br><span class="line">    ~Ray() = <span class="keyword">default</span>;</span><br><span class="line">    Ray(<span class="keyword">const</span> Vector3D &amp;org, <span class="keyword">const</span> Vector3D &amp;dir)</span><br><span class="line">        :m_origin(org), m_direction(dir) &#123;</span><br><span class="line">        m_direction.normalize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter.</span></span><br><span class="line">    <span class="function">Vector3D <span class="title">getOrigin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_origin; &#125;</span><br><span class="line">    <span class="function">Vector3D <span class="title">getDirection</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_direction; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p(t) = origin + t*dir;</span></span><br><span class="line">    <span class="function">Vector3D <span class="title">pointAt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span> &amp;t)</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_origin + m_direction * t; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们实现的基于cpu的光线追踪核心渲染流程是对给定分辨率的像素矩阵，逐行逐列地遍历每个像素坐标，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *RayTracing::render()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>;row &lt; m_height;++ row)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>;col &lt; m_width;++ col)</span><br><span class="line">        &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因而对于每个给定的像素坐标$(x,y)$，我们需要获取这个像素坐标对应的发射出去的射线，首先我们把值域为$[0,m_width]$和$[0,m_height]$的像素坐标映射到$[0,1]$，正如如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> u = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(col) / <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_config.m_width);</span><br><span class="line"><span class="keyword">float</span> v = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(row) / <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_config.m_height);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来我们根据$u$和$v$获取射线方向向量，这涉及到两个方面，一个摄像机的坐标系统，另一个是关于视锥的大小设置。摄像机的坐标轴决定了当前的朝向，视锥的大小设定决定了当前视域的大小。为此，我把摄像机与视锥合并一起，坐标系类型依然是右手坐标系。创建的摄像机类如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Camera</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector3D m_pos;</span><br><span class="line">    Vector3D m_target;</span><br><span class="line">    Vector3D m_lowerLeftCorner;</span><br><span class="line">    Vector3D m_horizontal;</span><br><span class="line">    Vector3D m_vertical;</span><br><span class="line">    <span class="keyword">float</span> m_fovy, m_aspect;</span><br><span class="line">    Vector3D m_axisX, m_axisY, m_axisZ;</span><br><span class="line"></span><br><span class="line">    Camera(<span class="keyword">const</span> Vector3D &amp;cameraPos, <span class="keyword">const</span> Vector3D &amp;target,<span class="keyword">float</span> vfov,</span><br><span class="line">        <span class="keyword">float</span> aspect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter.</span></span><br><span class="line">    <span class="function">Ray <span class="title">getRay</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span> &amp;s, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Vector3D <span class="title">getPosition</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_pos; &#125;</span><br><span class="line">    <span class="function">Vector3D <span class="title">getTarget</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_target; &#125;</span><br><span class="line">    <span class="function">Vector3D <span class="title">getAxisX</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_axisX; &#125;</span><br><span class="line">    <span class="function">Vector3D <span class="title">getAxisY</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_axisY; &#125;</span><br><span class="line">    <span class="function">Vector3D <span class="title">getAxisZ</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_axisZ; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setter.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPosition</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;pos)</span> </span>&#123; m_pos = pos; update(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;_tar)</span> </span>&#123; m_target = _tar; update(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFovy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span> &amp;fov)</span> </span>&#123; m_fovy = fov; update(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAspect</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span> &amp;asp)</span> </span>&#123; m_aspect = asp; update(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中$m_pos$即摄像机的世界坐标位置，$m_target$即目标位置，而$m_lowerLeftCorner$表示视锥近平面的左下角位置，$m_horizontal$表示近平面在摄像机坐标系下水平方向的跨度，$m_vertical$则是近平面在摄像机坐标系下垂直方向的跨度。$m_fovy$和$m_aspect$分别是视锥的垂直视域和屏幕的宽高比。初始时我们传入摄像机坐标、目标点以及垂直视域和视口宽高比，然后我们根据这些计算摄像机的三个坐标轴，以及近平面的位置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Camera::update()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Vector3D <span class="title">worldUp</span><span class="params">(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line">    <span class="comment">// frustum.</span></span><br><span class="line">    <span class="keyword">float</span> theta = radians(m_fovy);</span><br><span class="line">    <span class="keyword">float</span> half_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">tan</span>(theta * <span class="number">0.5f</span>));</span><br><span class="line">    <span class="keyword">float</span> half_width = m_aspect * half_height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// camera coordinate system.</span></span><br><span class="line">    m_axisZ = m_pos - m_target;</span><br><span class="line">    m_axisZ.normalize();</span><br><span class="line">    m_axisX = worldUp.crossProduct(m_axisZ);</span><br><span class="line">    m_axisX.normalize();</span><br><span class="line">    m_axisY = m_axisZ.crossProduct(m_axisX);</span><br><span class="line">    m_axisY.normalize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// view port.</span></span><br><span class="line">    m_lowerLeftCorner = m_pos - m_axisX * half_width - m_axisY * half_height - m_axisZ;</span><br><span class="line">    m_horizontal = m_axisX * <span class="number">2.0f</span> * half_width;</span><br><span class="line">    m_vertical = m_axisY * <span class="number">2.0f</span> * half_height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后我们对于给定在$[0,1]$的$u$和$v$，就可以计算出一条对应的射线向量了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ray Camera::getRay(<span class="keyword">const</span> <span class="keyword">float</span> &amp;s, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Ray(m_pos , m_lowerLeftCorner + m_horizontal * s + m_vertical * t - m_pos );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = m_config.m_height - <span class="number">1</span>; row &gt;= <span class="number">0</span>; --row)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; m_config.m_width; ++col)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> u = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(col + drand48()) / <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_config.m_width);</span><br><span class="line">        <span class="keyword">float</span> v = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(row + drand48()) / <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_config.m_height);</span><br><span class="line">        Ray ray = camera.getRay(u, v);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、物体求交"><a href="#2、物体求交" class="headerlink" title="2、物体求交"></a>2、物体求交</h2><p>&emsp;&emsp;射线发射出去之后要与物体进行求交运行，对于这类能够被射线碰撞到的物体我们把它抽象为$Hitable$，并用一个虚函数$Hit$作为所有的碰撞求交的接口，创建$Hitable$虚类如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Material</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HitRecord</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> <span class="keyword">m_t</span>;</span><br><span class="line">    Vector3D m_position;</span><br><span class="line">    Vector3D m_normal;</span><br><span class="line">    Material *m_material;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hitable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Hitable() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Hitable() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(<span class="keyword">const</span> Ray &amp;ray, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t_min, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t_max, HitRecord &amp;ret)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到我们还创建了一个$HitRecord$结构体，它包含一次射线碰撞求交的结果记录，其中$m_t$是射线方程的参数$t$，$m_position$是交点的位置，$m_normal$是交点的法向量，而$m_material$则是交点所在物体的材质，求交之后我们需要根据这些记录来计算物体的折射、反射。</p><p>&emsp;&emsp;$Hitable$中的$hit$接口以一条射线$ray$作为输入参数，以一个$Hitable$的引用$ret$作为求交的结果记录，函数返回布尔值以表示是否发生了射线碰撞。此外，值得一提的是我们还输入了两个参数，分别是$t_min$和$t_max$，这个是我们自己对射线线段长度做的一个限制，可以分别去掉太近和太远的物体。</p><p>&emsp;&emsp;然后我们需要向场景中添加物体，光线追踪器的一个”Hello, world!”是球体。我们知道，一个球体的数学表达式为如下所示：</p><script type="math/tex; mode=display">(x-cx)^2+(y-cy)^2+(z-cz)^2=R^2 \tag {1}</script><p>&emsp;&emsp;其中$c=(cx,cy,cz)$是球体的球心，$R$为球体半径。我们现在要求的就是，对于射线上的一点$P(t)=S+tV$，使得$(x,y,z)=P(t)=S+tV$带入公式$(1)$成立，公式$(1)$可以写成点乘的形式如下：</p><script type="math/tex; mode=display">(P-c)\cdot (P-c) = R^2 \tag {2}</script><p>&emsp;&emsp;将$P=P(t)=S+tV$带入公式$(2)$可得：</p><script type="math/tex; mode=display">(V\cdot V)t^2+2(V\cdot(S-c))t+(S-c)\cdot(S-c)-R^2=0 \tag {3}</script><p>&emsp;&emsp;可以看到公式$(3)$中只有$t$未知，它是一个一元二次方程。对于任意的一元二次方程$at^2+bt+c=0$，其解有如下形式：</p><script type="math/tex; mode=display">t=\frac{-b\pm \sqrt{b^2-4ac}}{2a} \tag {4}</script><p>&emsp;&emsp;其中根号内的$D=b^2-4ac$称为根的判别式，它可以反应多项式根的数量。若$D&gt;0$则有两个实数根，若$D=0$则只有一个实数根，若$D&lt;0$则没有实数根。我们首先可以根据判别式判断是否存在交点，然后再求出具体的交点坐标。下面的$Hit$函数，我们首先求出多项式方程的常数项$a$、$b$和$c$，然后求判别式，最后再有解的情况下求取交点。注意，在有两个交点的情况下，我们首先取较近的点，不符合再取较远的那个点。只有一个交点的情况下（如下图2所示），我们不当作射线发生了碰撞（擦边而过）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sphere</span> :</span> <span class="keyword">public</span> Hitable</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="keyword">float</span> m_radius;</span><br><span class="line">       Vector3D m_center;</span><br><span class="line">       Material *m_material;</span><br><span class="line"></span><br><span class="line">       Sphere(<span class="keyword">const</span> Vector3D &amp;cen, <span class="keyword">const</span> <span class="keyword">float</span> r, Material *mat)</span><br><span class="line">           :m_center(cen), m_radius(r), m_material(mat) &#123;&#125;</span><br><span class="line">       ~Sphere() &#123; <span class="keyword">if</span> (m_material)<span class="keyword">delete</span> m_material; m_material = <span class="literal">nullptr</span>; &#125;;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(<span class="keyword">const</span> Ray &amp;ray, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t_min, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t_max, HitRecord &amp;ret)</span> <span class="keyword">const</span></span>;</span><br><span class="line">   &#125;;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Sphere::hit(<span class="keyword">const</span> Ray &amp;ray, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t_min, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t_max, HitRecord &amp;ret) <span class="keyword">const</span></span><br><span class="line">   &#123;</span><br><span class="line">       Vector3D oc = ray.getOrigin() - m_center;</span><br><span class="line">       <span class="keyword">float</span> a = ray.getDirection().dotProduct(ray.getDirection());</span><br><span class="line">       <span class="keyword">float</span> b = oc.dotProduct(ray.getDirection());</span><br><span class="line">       <span class="keyword">float</span> c = oc.dotProduct(oc) - m_radius * m_radius;</span><br><span class="line">       <span class="comment">// discriminant</span></span><br><span class="line">       <span class="keyword">float</span> discriminant = b * b - a * c;</span><br><span class="line">       <span class="keyword">if</span> (discriminant &gt; <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">float</span> temp = (-b - <span class="built_in">sqrt</span>(b * b - a * c)) / a;</span><br><span class="line">           <span class="keyword">if</span> (temp &gt; t_min &amp;&amp; temp &lt; t_max)</span><br><span class="line">           &#123;</span><br><span class="line">               ret.<span class="keyword">m_t</span> = temp;</span><br><span class="line">               ret.m_position = ray.pointAt(ret.<span class="keyword">m_t</span>);</span><br><span class="line">               ret.m_normal = (ret.m_position - m_center) / m_radius;</span><br><span class="line">               ret.m_material = m_material;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           temp = (-b + <span class="built_in">sqrt</span>(b * b - a * c)) / a;</span><br><span class="line">           <span class="keyword">if</span> (temp &gt; t_min &amp;&amp; temp &lt; t_max)</span><br><span class="line">           &#123;</span><br><span class="line">               ret.<span class="keyword">m_t</span> = temp;</span><br><span class="line">               ret.m_position = ray.pointAt(ret.<span class="keyword">m_t</span>);</span><br><span class="line">               ret.m_normal = (ret.m_position - m_center) / m_radius;</span><br><span class="line">               ret.m_material = m_material;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.9/blog/RayTracer-Basis/sphere1.png" alt="sphere1"></p><center> 图2 射线与球体的相交情况 </center><p>&emsp;&emsp;当场景中有多个物体时，当前的做法是在每次求交时遍历所有的物体，我们需要一个$HitableList$来存储这些物体。我们令$HitableList$继承自$Hitable$，这样$HitableList$就表现得好像只有一个很大的物体一样，并在实现$hit$函数中对场景得所有物体遍历调用他们的$Hit$方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HitableList</span> :</span> <span class="keyword">public</span> Hitable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Hitable*&gt; m_list;</span><br><span class="line"></span><br><span class="line">    HitableList() = <span class="keyword">default</span>;</span><br><span class="line">    ~HitableList() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addHitable</span><span class="params">(Hitable *target)</span> </span>&#123; m_list.push_back(target); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearHitable</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; m_list.size(); ++x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_list[x];</span><br><span class="line">            m_list[x] = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(<span class="keyword">const</span> Ray &amp;ray, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t_min, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t_max, HitRecord &amp;ret)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> HitableList::hit(<span class="keyword">const</span> Ray &amp;ray, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t_min, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t_max, HitRecord &amp;ret) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    HitRecord tempRec;</span><br><span class="line">    <span class="keyword">bool</span> hitAny = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">double</span> closestSoFar = t_max;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; m_list.size(); ++x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_list[x]-&gt;hit(ray, t_min, closestSoFar, tempRec))</span><br><span class="line">        &#123;</span><br><span class="line">            hitAny = <span class="literal">true</span>;</span><br><span class="line">            closestSoFar = tempRec.<span class="keyword">m_t</span>;</span><br><span class="line">            ret = tempRec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hitAny;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此外，值得一提的是，在$HitableList$的$hit$函数中我们需要做一个类似于深度测试的步骤，我们从摄像机发射的射线只能跟最靠近摄像机的那个交点做反射、折射，一条射线发射出去可能会与多个物体相交，我们必须取最近的交点。这个距离我们用射线方程中的$t$来描述，显然$t$越大则交点越远，因此用$closestSoFar$来记录当前获取的交点的最小$t$，以此作为$t$的上限，这样最终求出来的必然就是最近的交点。</p><h2 id="3、物体材质"><a href="#3、物体材质" class="headerlink" title="3、物体材质"></a>3、物体材质</h2><p>&emsp;&emsp;现在我们的一个问题就是求出交点之后，光线在交点上做什么样的反射和折射？这取决于物体的材质。若物体的材质是透明的玻璃，那么光线一般做折射；而若物体是光滑的镜面，则光线做完美的反射。针对不同物体的材质，光线的散射情况各不相同，为此我们创建一个虚类$Material$，并把光线散射的这一过程抽象为$sactter$函数接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Material</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Material() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Material() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(<span class="keyword">const</span> Ray &amp;in, <span class="keyword">const</span> HitRecord &amp;rec,</span></span></span><br><span class="line"><span class="function"><span class="params">        Vector3D &amp;attenuation, Ray &amp;scattered)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到，$scatter$函数接收入射射线$Ray$以及求交获得的$HitRecord$，计算散射光线的向量，返回的结果表示是否发生了散射。其中的$attenuation$本质上是物体自身的反射颜色，之所以叫$attenuation$是因为光线照射到物体上，物体一般会吸收光线中的大部分颜色，然后仅反射自身颜色的部分，这个过程使得光线在反射过程中不断衰减。</p><h3 id="3-1-Lambertian反射材质"><a href="#3-1-Lambertian反射材质" class="headerlink" title="3.1 Lambertian反射材质"></a>3.1 Lambertian反射材质</h3><p>&emsp;&emsp;首先我们要实现的是Lambertian反射的材质，Lambertian反射也叫理想散射。Lambertian表面是指在一个固定的照明分布下从所有的视场方向上观测都具有相同亮度的表面，Lambertian表面不吸收任何入射光。Lambertian反射也叫散光反射，不管照明分布如何，Lambertian表面在所有的表面方向上接收并发散所有的入射照明，结果是每一个方向上都能看到相同数量的能量。这是一种理想情况，现实中不存在完全漫反射，但Lambertian可以用来近似的模拟一些粗糙表面的效果，比如纸张。</p><p><img src="https://images2015.cnblogs.com/blog/305017/201511/305017-20151106030028617-1366640843.jpg" alt="img"></p><center> 图3 Lambertian反射 </center><p>&emsp;&emsp;为了实现Lambertian表面的均匀反射现象，我们令射线碰撞到表面之后，在交点的半球方向上随机地反射，只要随机性够均匀，我们就能模拟出理想散射的情况。为此，我们取一个正切于交点$P$表面的单位球体，在这个球体内随机取一个点$S$，则反射的向量就为$S-P$。这个正切于交点$P$表面的单位球体不难求得，设交点$P$的单位法向量为$N$，那么该正切球体的球心为$P+N$。我们首先在球心为原点的单位球内随机求得一个方向向量，然后将这个方向向量加上正切球体的球心即可得出反射的方向向量。（$drand48$是生成$[0,1)$之间的均匀随机数函数，一般linux下才有这个内建函数，windows下没有，所以我们就自己写了。）</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.9/blog/RayTracer-Basis/lambertian.png" alt="lambertian"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rndm 0x100000000LL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rndc 0xB16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rnda 0x5DEECE66DLL</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> seed = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">drand48</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        seed = (rnda * seed + rndc) &amp; <span class="number">0xFFFFFFFFFFFF</span>LL;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> x = seed &gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span>  ((<span class="keyword">double</span>)x / (<span class="keyword">double</span>)rndm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">===============================================================</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Vector3D randomInUnitSphere()</span><br><span class="line">&#123;</span><br><span class="line">Vector3D pos;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">pos = Vector3D(drand48(), drand48(), drand48()) * <span class="number">2.0f</span> - Vector3D(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (pos.getSquaredLength() &gt;= <span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">===============================================================</span><br><span class="line">    class Lambertian : <span class="keyword">public</span> Material</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Vector3D m_albedo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Lambertian(<span class="keyword">const</span> Vector3D &amp;a) : m_albedo(a) &#123;&#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~Lambertian() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(<span class="keyword">const</span> Ray &amp;in, <span class="keyword">const</span> HitRecord &amp;rec,</span></span></span><br><span class="line"><span class="function"><span class="params">            Vector3D &amp;attenuation, Ray &amp;scattered)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> Lambertian::scatter(<span class="keyword">const</span> Ray &amp;in, <span class="keyword">const</span> HitRecord &amp;rec,</span><br><span class="line">        Vector3D &amp;attenuation, Ray &amp;scattered) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3D target = rec.m_position + rec.m_normal + Vector3D::randomInUnitSphere();</span><br><span class="line">        scattered = Ray(rec.m_position, target - rec.m_position);</span><br><span class="line">        attenuation = m_albedo;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中的$m_albedo$为物体自身的反射颜色。</p><h3 id="3-2-金属镜面反射材质"><a href="#3-2-金属镜面反射材质" class="headerlink" title="3.2 金属镜面反射材质"></a>3.2 金属镜面反射材质</h3><p>&emsp;&emsp;金属的表面比较光滑，因而不会呈现出光线随机散射的情况。对于一个完美镜面的材质来说，入射光线和反射光线遵循反射定律，即光射到镜面上时，反射线跟入射线和法线在同一平面内，反射线和入射线分居法线两侧，并且与界面法线的夹角（分别叫做入射角和反射角）相等。反射角等于入射角。</p><p>&emsp;&emsp;求反射向量如下图4所示，比较简单，不再赘述。</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.11/blog/RayTracer-Basis/reflect.jpg" alt="img"></p><center> 图4 反射向量 </center><script type="math/tex; mode=display">R = I-2(N\cdot I)N \tag {5}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Vector3D <span class="title">reflect</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;ray, <span class="keyword">const</span> Vector3D &amp;normal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ray - normal * (ray.dotProduct(normal)) * <span class="number">2.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于一个完美镜面的金属材质来说，我们只需求出反射向量，然后按照这个反射向量递归下去就行了。但是有些金属并没有那么光滑，它的高光反射并没有那么锐利，为此我们对求出的反射向量做一定的扰动，使反射向量在一定的波瓣内随机，这个波瓣有多大由用户决定（波瓣越大则金属越粗糙）。废话不多说直接上图就明白了。</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.9/blog/RayTracer-Basis/metal.png" alt="metal"></p><p>&emsp;&emsp;我们在反射向量的终点上取一个给定半径的球体，在这个球体内随机选一个点作为新的反射向量的终点即可。这个半径的大小我们用$m_fuzz$变量存储，交给用户决定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Metal</span> :</span> <span class="keyword">public</span> Material</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> m_fuzz;</span><br><span class="line">    Vector3D m_albedo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Metal(<span class="keyword">const</span> Vector3D &amp;a, <span class="keyword">const</span> <span class="keyword">float</span> &amp;f) : m_albedo(a), m_fuzz(f) &#123; <span class="keyword">if</span> (f &gt; <span class="number">1.0f</span>)m_fuzz = <span class="number">1.0f</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Metal() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(<span class="keyword">const</span> Ray &amp;in, <span class="keyword">const</span> HitRecord &amp;rec,</span></span></span><br><span class="line"><span class="function"><span class="params">        Vector3D &amp;attenuation, Ray &amp;scattered)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Metal::scatter(<span class="keyword">const</span> Ray &amp;in, <span class="keyword">const</span> HitRecord &amp;rec,</span><br><span class="line">    Vector3D &amp;attenuation, Ray &amp;scattered) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Vector3D reflectedDir = Vector3D::reflect(in.getDirection(), rec.m_normal);</span><br><span class="line">    scattered = Ray(rec.m_position, reflectedDir + Vector3D::randomInUnitSphere() * m_fuzz);</span><br><span class="line">    attenuation = m_albedo;</span><br><span class="line">    <span class="keyword">return</span> (scattered.getDirection().dotProduct(rec.m_normal) &gt; <span class="number">0.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-透明玻璃折射材质"><a href="#3-3-透明玻璃折射材质" class="headerlink" title="3.3 透明玻璃折射材质"></a>3.3 透明玻璃折射材质</h3><p>&emsp;&emsp;对于水、玻璃和钻石等等物体的材质，光线照射到它们的表面时，它会把光线分成折射（也叫透射）光线和反射光线两部分。我们实现的材质采用随机的策略， 就是在折射和反射两个部分中随机选取一种。首先我们要根据入射向量、法线以及入射介质系数和折射介质系数计算折射方向向量，相比反射向量，推导计算的过程稍微有点复杂。折射表面有折射系数属性，根据Snell定律，如图5所示，入射角$\theta _L$和折射角$\theta _T$之间的关系有：</p><script type="math/tex; mode=display">\eta _Lsin\theta _L=\eta _rsin\theta _r \tag {6}</script><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.11/blog/RayTracer-Basis/refract.png" alt="img"></p><center> 图5 折射向量的计算 </center><p>&emsp;&emsp;其中，$\eta _L$时光线离开的介质的折射系数，$\eta _r$是光线进入的介质的折射系数。空气的折射系数通常定位$1.00$，折射系数越大，则在两种不同介质之间光线弯曲效果越明显。$N$和$L$都是单位方向向量。折射向量$T$可为与法向量平行的向量$-Ncos\theta_T$和垂直的向量$-Gsin\theta _T$，$G$是上图所示的单位向量。而$perp_NL$与$G$向量平行，且$||perp_NL=sin\theta_L||$，故有：</p><script type="math/tex; mode=display">G=\frac{perp_NL}{sin\theta_L}=\frac{L-(N\cdot L)N}{sin\theta_L} \tag {7}</script><p>&emsp;&emsp;折射向量$T$可以表示为：</p><script type="math/tex; mode=display">T=-Ncos\theta_T-Gsin\theta_T\\=-Ncos\theta_T-\frac{sin\theta_T}{sin\theta_L}[L-(N\cdot L)N] \tag {8}</script><p>&emsp;&emsp;利用公式$(6)$，我们可以将上式中的正弦商替换为$\eta _L/\eta _T$，可得：</p><script type="math/tex; mode=display">T=-Ncos\theta_T-\frac{\eta _L}{\eta _T}[L-(N\cdot L)N] \tag {9}</script><p>&emsp;&emsp;注意到公式$(9)$中的$cos\theta_T$未知，用$\sqrt{1-sin^2\theta_T}$替换$cos\theta_T$，再用$(\eta_L/\eta_r)sin\theta_L$代替$sin\theta_T$，可得：</p><script type="math/tex; mode=display">T=-N\sqrt{1-\frac{\eta^2_L}{\eta^2_T}sin^2\theta_L}-\frac{\eta_L}{\eta_T}[L-(N\cdot L)N] \tag {10}</script><p>&emsp;&emsp;最后再用$1-cos^2\theta_L=1-(N\cdot L)^2$代替$sin^2\theta_L$，得到最终的表达式为：</p><script type="math/tex; mode=display">T=(\frac{\eta_L}{\eta_T}N\cdot L-\sqrt{1-\frac{\eta^2_L}{\eta^2_T}[1-(N\cdot L)^2]}\ )N-\frac{\eta_L}{\eta_T}L \tag {11}</script><p>&emsp;&emsp;如果$\eta_L&gt;\eta_T$，则上式平方根里的数值可能为负，这种情况发生在当光线从一个大折射率的介质进入一个小折射率的介质时，此时光线与表面之间的入射角较大。特别的，若仅当$sin\theta_L\leq \eta_r/\eta_L$时，公式$(11)$有效，如果平方根里的数值为负，则会出现所谓的全内反射现象，也就是光线不被折射，仅在介质内部反射。<strong>此外，需要注意的是，我们在程序实现中的入射向量与图5中$L$是相反的，所以需要将公式中的$(11)$的入射向量取反，如下所示：</strong></p><script type="math/tex; mode=display">T=\frac{\eta_L}{\eta_T}(L-(N\cdot L)N)-N\sqrt{1-\frac{\eta^2_L}{\eta^2_T}[1-(N\cdot L)^2]}\  \tag {12}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">refract</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;ray, <span class="keyword">const</span> Vector3D &amp;normal,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">float</span> niOvernt, Vector3D &amp;refracted)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector3D uv = ray;</span><br><span class="line">    uv.normalize();</span><br><span class="line">    <span class="keyword">float</span> dt = uv.dotProduct(normal);</span><br><span class="line">    <span class="keyword">float</span> discriminant = <span class="number">1.0f</span> - niOvernt * niOvernt * (<span class="number">1.0f</span> - dt * dt);</span><br><span class="line">    <span class="keyword">if</span> (discriminant &gt; <span class="number">0.0f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        refracted = (uv - normal * dt) * niOvernt - normal * <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后创建一个$Dielectric$类，它有一个私有变量$refIdx$，它表面该物体的材质折射系数。在实现玻璃材质物体的散射函数$scatter$时，我们需要判断当前射线是从外部折射到内部还是从内部折射到外部，这可以通过计算入射向量与法向量的夹角余弦值来判断（通常法向量朝外），然后相应地将法向量的方向扭正。<strong>这里用$ni-over-nt$变量来记录$\frac{\eta_L}{\eta_T}$，我们知道空气的折射系数为$1.00$，所以从外面折射入物体内部时其取值等于$1.0/refIdx$，从内部折射到外部时取值为$refIdx$。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Dielectric</span> :</span> <span class="keyword">public</span> Material</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">float</span> refIdx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Dielectric(<span class="keyword">float</span> ri) : refIdx(ri) &#123;&#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~Dielectric() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(<span class="keyword">const</span> Ray &amp;in, <span class="keyword">const</span> HitRecord &amp;rec,</span></span></span><br><span class="line"><span class="function"><span class="params">            Vector3D &amp;attenuation, Ray &amp;scattered)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> Dielectric::scatter(<span class="keyword">const</span> Ray &amp;in, <span class="keyword">const</span> HitRecord &amp;rec,</span><br><span class="line">        Vector3D &amp;attenuation, Ray &amp;scattered) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3D outward_normal;</span><br><span class="line">        Vector3D reflected = Vector3D::reflect(in.getDirection(), rec.m_normal);</span><br><span class="line">        <span class="keyword">float</span> ni_over_nt;</span><br><span class="line">        attenuation = Vector3D(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        Vector3D refracted;</span><br><span class="line">        <span class="keyword">float</span> reflect_prob;</span><br><span class="line">        <span class="keyword">float</span> cosine;</span><br><span class="line">        <span class="comment">// from inside to outside.</span></span><br><span class="line">        <span class="keyword">if</span> (in.getDirection().dotProduct(rec.m_normal) &gt; <span class="number">0.0f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            outward_normal = -rec.m_normal;</span><br><span class="line">            ni_over_nt = refIdx;</span><br><span class="line">            cosine = refIdx * in.getDirection().dotProduct(rec.m_normal) / in.getDirection().getLength();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// from outside to inside.</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            outward_normal = rec.m_normal;</span><br><span class="line">            ni_over_nt = <span class="number">1.0</span> / refIdx;</span><br><span class="line">            cosine = -in.getDirection().dotProduct(rec.m_normal) / in.getDirection().getLength();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Vector3D::refract(in.getDirection(), outward_normal, ni_over_nt, refracted))</span><br><span class="line">        &#123;</span><br><span class="line">            reflect_prob = schlick(cosine, refIdx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            scattered = Ray(rec.m_position, reflected);</span><br><span class="line">            reflect_prob = <span class="number">1.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (drand48() &lt; reflect_prob)</span><br><span class="line">            scattered = Ray(rec.m_position, reflected);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            scattered = Ray(rec.m_position, refracted);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里还要引入一个菲涅尔反射现象（仅对电介质和非金属表面有定义）。生活中，当我们以垂直的视角观察时，任何物体或者材质表面都有一个基础反射率(Base Reflectivity)，但是如果以一定的角度往平面上看的时候<a href="http://filmicgames.com/archives/557" target="_blank" rel="noopener">所有</a>反光都会变得明显起来。你可以自己尝试一下，用垂直的视角观察你自己的木制桌面，此时一定只有最基本的反射性。但是如果你从近乎与法线成90度的角度观察的话反光就会变得明显的多。如果从理想的90度的视角观察，所有的平面理论上来说都能完全的反射光线。这种现象因菲涅尔而闻名，并体现在了菲涅尔方程之中。菲涅尔方程是一个相当复杂的方程式，不过幸运的是菲涅尔方程可以用Fresnel-Schlick近似法求得近似解：</p><script type="math/tex; mode=display">F_{schlick(h,v,F_0)}=F_0+(1-F_0)(1-(h\cdot v))^5 \tag {13}</script><p>&emsp;&emsp;这里的$F_0$y由物体的折射系数得到，$h$是入射向量的负向量（因为我们定义的入射向量方向朝向交点），$v$则是交点处的法向量$v$，我们实现一个$schlick$函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">schlick</span><span class="params">(<span class="keyword">float</span> cosine, <span class="keyword">float</span> ref_idx)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> r0 = (<span class="number">1.0f</span> - ref_idx) / (<span class="number">1.0f</span> + ref_idx);</span><br><span class="line">    r0 = r0 * r0;</span><br><span class="line">    <span class="keyword">return</span> r0 + (<span class="number">1.0f</span> - r0) * <span class="built_in">pow</span>((<span class="number">1.0f</span> - cosine), <span class="number">5.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们还定义了一个reflect_prob变量，它介于0~1之间。我们根据reflect_prob与介于$[0,1)$的随机数做比较确定选择反射还是折射，这个还是很合理的，为什么呢？因为我们做了100次采样！那么我们可以理直气壮的说，我们的透明电介质真正做到了反射和折射的混合（除了全反射现象），而且这样符合光线照射透明电介质时，它会分裂为反射光线和折射光线的物理现象。（在程序中，教程作者在从内部折射到外部的时候将$cosine$值还乘上了个$refIdx$，这个操作没明白作者的意图，不乘上$refIdx$好像也没有发现渲染结果有明显的错误）。</p><p>&emsp;&emsp;最后，我们实现的玻璃球球内图像是颠倒的，这属于正常现象，原因如下图所示。光线经过两次折射最终导致了图像的颠倒。</p><p><img src="https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190103133145435-1573495559.png" alt="img"></p><h2 id="4、抗锯齿"><a href="#4、抗锯齿" class="headerlink" title="4、抗锯齿"></a>4、抗锯齿</h2><p>&emsp;&emsp;为了减少光线追踪方法的噪声点和锯齿，我们需要做一些抗锯齿处理。方法就是在计算一个像素坐标的像素值时，发射很多条射线，射线的取值范围在一个像素之内，然后将所有光线获取的像素值累加起来，最后除以总的采样数。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> samples = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = m_config.m_height - <span class="number">1</span>; row &gt;= <span class="number">0</span>; --row)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; m_config.m_width; ++col)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector4D color;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sps = <span class="number">0</span>; sps &lt; samples; ++sps)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> u = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(col + drand48()) / <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_config.m_width);</span><br><span class="line">            <span class="keyword">float</span> v = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(row + drand48()) / <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_config.m_height);</span><br><span class="line">            Ray ray = camera.getRay(u, v);</span><br><span class="line">            color += tracing(ray, world, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        color /= <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(samples);</span><br><span class="line">        color.w = <span class="number">1.0f</span>;</span><br><span class="line">        <span class="comment">// gamma correction.</span></span><br><span class="line">        color = Vector4D(<span class="built_in">sqrt</span>(color.x), <span class="built_in">sqrt</span>(color.y), <span class="built_in">sqrt</span>(color.z), color.w);</span><br><span class="line">        drawPixel(col, row, color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里还提到了gamma矫正，关于gamma矫正请看<a href="[https://learnopengl-cn.github.io/05%20Advanced%20Lighting/02%20Gamma%20Correction/](https://learnopengl-cn.github.io/05 Advanced Lighting/02 Gamma Correction/">这里</a>)。我们对计算得到的像素做了一个简单的gamma矫正，gamma矫正系数取为$2.0$。不进行gamma矫正的话，渲染出来的图片明显偏暗。</p><h2 id="5、景深"><a href="#5、景深" class="headerlink" title="5、景深"></a>5、景深</h2><p>&emsp;&emsp;关于现实生活中摄像机的景深原理，我不再详细说明。在光线追踪中实现景深并不复杂。实现的方法：首先是射线的出发点视点，我们的眼睛（或者相机）不再是一个点而是眼睛所在的周围圆盘上的随机点，因为实际的相机是有摄像镜头的，摄像镜头是一个大光圈（很大一个镜片），并不是针孔类的东东，所以，我们要模拟镜头，就要随机采针孔周围的光圈点。</p><p><img src="https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190105005517891-2107468507.png" alt="img"></p><p>&emsp;&emsp;此外还有一个焦距的问题，我们一开始假设成像平面在摄像机坐标系的$z=-1$上，为了实现摄像机的景深效果，现在我们要引入现实摄像机的焦距概念。简单的说焦距是焦点到<a href="https://baike.baidu.com/item/面镜/1341446" target="_blank" rel="noopener">面镜</a>的中心点之间的距离。因此我们提供了一个焦距的参数给用户调整，以确定所需的景深效果。通常情况下焦距$focusDist$等于$length(target-cameraPos)$。这个时候我们将成像平面挪到了摄像机坐标系的$z=-focusDist$上，相应地需要调整计算成像平面的$halfHeight$（在前面的基础上再乘上个$focusDist$）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Camera::Camera(<span class="keyword">const</span> Vector3D &amp;cameraPos, <span class="keyword">const</span> Vector3D &amp;target,</span><br><span class="line">    <span class="keyword">float</span> vfov, <span class="keyword">float</span> aspect, <span class="keyword">float</span> aperture, <span class="keyword">float</span> focus_dist)</span><br><span class="line">&#123;</span><br><span class="line">    m_pos = cameraPos;</span><br><span class="line">    m_target = target;</span><br><span class="line">    m_fovy = vfov;</span><br><span class="line">    m_aspect = aspect;</span><br><span class="line">    m_lensRadius = aperture * <span class="number">0.5f</span>;</span><br><span class="line">    m_focusDist = focus_dist;</span><br><span class="line">    update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Camera::update()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Vector3D <span class="title">worldUp</span><span class="params">(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line">    <span class="comment">// frustum.</span></span><br><span class="line">    <span class="keyword">float</span> theta = radians(m_fovy);</span><br><span class="line">    <span class="keyword">float</span> half_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">tan</span>(theta * <span class="number">0.5f</span>)) * m_focusDist;</span><br><span class="line">    <span class="keyword">float</span> half_width = m_aspect * half_height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// camera coordinate system.</span></span><br><span class="line">    m_axisZ = m_pos - m_target;</span><br><span class="line">    m_axisZ.normalize();</span><br><span class="line">    m_axisX = worldUp.crossProduct(m_axisZ);</span><br><span class="line">    m_axisX.normalize();</span><br><span class="line">    m_axisY = m_axisZ.crossProduct(m_axisX);</span><br><span class="line">    m_axisY.normalize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// view port.</span></span><br><span class="line">    m_lowerLeftCorner = m_pos - m_axisX * half_width</span><br><span class="line">        - m_axisY * half_height - m_axisZ * m_focusDist;</span><br><span class="line">    m_horizontal = m_axisX * <span class="number">2.0f</span> * half_width;</span><br><span class="line">    m_vertical = m_axisY * <span class="number">2.0f</span> * half_height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、递归光线追踪"><a href="#6、递归光线追踪" class="headerlink" title="6、递归光线追踪"></a>6、递归光线追踪</h2><p>&emsp;&emsp;最后，我们实现的光线追踪器$Tracer$如下，追踪器的核心实现主要在$tracing$函数和$render$函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hitable</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector3D</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector4D</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tracer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Setting</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> m_maxDepth;</span><br><span class="line">        <span class="keyword">int</span> m_width, m_height, m_channel;</span><br><span class="line"></span><br><span class="line">        Setting():m_maxDepth(<span class="number">50</span>), m_channel(<span class="number">4</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Setting m_config;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *m_image;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Tracer();</span><br><span class="line">    ~Tracer();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> c = <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">render</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_config.m_width; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_config.m_height; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getChannel</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_config.m_channel; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRecursionDepth</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_config.m_maxDepth; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">getImage</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_image; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRecursionDepth</span><span class="params">(<span class="keyword">int</span> depth)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCamera</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;cameraPos, <span class="keyword">const</span> Vector3D &amp;target, <span class="keyword">const</span> Vector3D &amp;worldUp,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">float</span> fovy, <span class="keyword">float</span> aspect, <span class="keyword">float</span> aperture, <span class="keyword">float</span> focus_dist)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">Hitable *<span class="title">randomScene</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Vector4D <span class="title">tracing</span><span class="params">(<span class="keyword">const</span> Ray &amp;r, Hitable *world, <span class="keyword">int</span> depth)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">hitSphere</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;center, <span class="keyword">const</span> <span class="keyword">float</span> &amp;radius, <span class="keyword">const</span> Ray &amp;ray)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawPixel</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x, <span class="keyword">unsigned</span> <span class="keyword">int</span> y, <span class="keyword">const</span> Vector4D &amp;color)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Tracer::initialize(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">    m_config.m_width = w;</span><br><span class="line">    m_config.m_height = h;</span><br><span class="line">    <span class="keyword">if</span> (m_image != <span class="literal">nullptr</span>) <span class="keyword">delete</span> m_image;</span><br><span class="line">    m_image = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[m_config.m_width * m_config.m_height * m_config.m_channel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *Tracer::render()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// viewport</span></span><br><span class="line">    <span class="function">Vector3D <span class="title">lower_left_corner</span><span class="params">(<span class="number">-2.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector3D <span class="title">horizontal</span><span class="params">(<span class="number">4.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector3D <span class="title">vertical</span><span class="params">(<span class="number">0.0</span>, <span class="number">2.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector3D <span class="title">origin</span><span class="params">(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// scene</span></span><br><span class="line">    Hitable* world = randomScene();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// camera</span></span><br><span class="line">    <span class="function">Vector3D <span class="title">lookfrom</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector3D <span class="title">lookat</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">float</span> dist_to_focus = <span class="number">10.0f</span>;</span><br><span class="line">    <span class="keyword">float</span> aperture = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="function">Camera <span class="title">camera</span><span class="params">(lookfrom, lookat, <span class="number">45</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_config.m_width) / m_config.m_height, aperture, dist_to_focus)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> samples = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = m_config.m_height - <span class="number">1</span>; row &gt;= <span class="number">0</span>; --row)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; m_config.m_width; ++col)</span><br><span class="line">        &#123;</span><br><span class="line">            Vector4D color;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> sps = <span class="number">0</span>; sps &lt; samples; ++sps)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">float</span> u = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(col + drand48()) / <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_config.m_width);</span><br><span class="line">                <span class="keyword">float</span> v = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(row + drand48()) / <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_config.m_height);</span><br><span class="line">                Ray ray = camera.getRay(u, v);</span><br><span class="line">                color += tracing(ray, world, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            color /= <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(samples);</span><br><span class="line">            color.w = <span class="number">1.0f</span>;</span><br><span class="line">            <span class="comment">// gamma correction.</span></span><br><span class="line">            color = Vector4D(<span class="built_in">sqrt</span>(color.x), <span class="built_in">sqrt</span>(color.y), <span class="built_in">sqrt</span>(color.z), color.w);</span><br><span class="line">            drawPixel(col, row, color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">reinterpret_cast</span>&lt;HitableList*&gt;(world)-&gt;clearHitable();</span><br><span class="line">    <span class="keyword">delete</span> world;</span><br><span class="line">    <span class="keyword">return</span> m_image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Tracer::drawPixel(<span class="keyword">unsigned</span> <span class="keyword">int</span> x, <span class="keyword">unsigned</span> <span class="keyword">int</span> y, <span class="keyword">const</span> Vector4D &amp;color)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m_config.m_width || y &lt; <span class="number">0</span> || y &gt;= m_config.m_height)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> index = (y * m_config.m_width + x) * m_config.m_channel;</span><br><span class="line">    m_image[index + <span class="number">0</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span> * color.x);</span><br><span class="line">    m_image[index + <span class="number">1</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span> * color.y);</span><br><span class="line">    m_image[index + <span class="number">2</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span> * color.z);</span><br><span class="line">    m_image[index + <span class="number">3</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span> * color.w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Hitable *Tracer::randomScene()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">500</span>;</span><br><span class="line">    HitableList *<span class="built_in">list</span> = <span class="keyword">new</span> HitableList();</span><br><span class="line">    <span class="built_in">list</span>-&gt;addHitable(<span class="keyword">new</span> Sphere(Vector3D(<span class="number">0</span>, <span class="number">-1000.0</span>, <span class="number">0</span>), <span class="number">1000</span>, <span class="keyword">new</span> Lambertian(Vector3D(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">-11</span>; a &lt; <span class="number">11</span>; ++a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">-11</span>; b &lt; <span class="number">11</span>; ++b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> choose_mat = drand48();</span><br><span class="line">            <span class="function">Vector3D <span class="title">center</span><span class="params">(a + <span class="number">0.9</span>*drand48(), <span class="number">0.2</span>, b + <span class="number">0.9</span>*drand48())</span></span>;</span><br><span class="line">            <span class="keyword">if</span> ((center - Vector3D(<span class="number">4</span>, <span class="number">0.2</span>, <span class="number">0</span>)).getLength() &gt; <span class="number">0.9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// diffuse.</span></span><br><span class="line">                <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.4f</span>)</span><br><span class="line">                    <span class="built_in">list</span>-&gt;addHitable(<span class="keyword">new</span> Sphere(center, <span class="number">0.2</span>, <span class="keyword">new</span> Lambertian</span><br><span class="line">                    (Vector3D(drand48()*drand48(),</span><br><span class="line">                        drand48()*drand48(),</span><br><span class="line">                        drand48()*drand48()))));</span><br><span class="line">                <span class="comment">// metal</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.6f</span>)</span><br><span class="line">                    <span class="built_in">list</span>-&gt;addHitable(<span class="keyword">new</span> Sphere(center, <span class="number">0.2</span>, <span class="keyword">new</span> Metal</span><br><span class="line">                    (Vector3D(<span class="number">0.5f</span>*(<span class="number">1.0f</span> + drand48()),</span><br><span class="line">                        <span class="number">0.5f</span>*(<span class="number">1.0f</span> + drand48()),</span><br><span class="line">                        <span class="number">0.5f</span>*(<span class="number">1.0f</span> + drand48())),</span><br><span class="line">                        <span class="number">0.5f</span>*drand48())));</span><br><span class="line">                <span class="comment">// glass</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">list</span>-&gt;addHitable(<span class="keyword">new</span> Sphere(center, <span class="number">0.2</span>, <span class="keyword">new</span> Dielectric</span><br><span class="line">                    (<span class="number">1.5f</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;addHitable(<span class="keyword">new</span> Sphere(Vector3D(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, <span class="keyword">new</span> Dielectric(<span class="number">1.5f</span>)));</span><br><span class="line">    <span class="built_in">list</span>-&gt;addHitable(<span class="keyword">new</span> Sphere(Vector3D(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, <span class="keyword">new</span> Lambertian(Vector3D(<span class="number">0.4</span>, <span class="number">0.2</span>, <span class="number">0.1</span>))));</span><br><span class="line">    <span class="built_in">list</span>-&gt;addHitable(<span class="keyword">new</span> Sphere(Vector3D(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, <span class="keyword">new</span> Metal(Vector3D(<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.5</span>), <span class="number">0.0f</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector4D Tracer::tracing(<span class="keyword">const</span> Ray &amp;r, Hitable *world, <span class="keyword">int</span> depth)</span><br><span class="line">&#123;</span><br><span class="line">    HitRecord rec;</span><br><span class="line">    <span class="keyword">if</span> (world-&gt;hit(r, <span class="number">0.001f</span>, FLT_MAX, rec))</span><br><span class="line">    &#123;</span><br><span class="line">        Ray scattered;</span><br><span class="line">        Vector3D attenuation;</span><br><span class="line">        <span class="keyword">if</span> (depth &lt; m_config.m_maxDepth &amp;&amp; rec.m_material-&gt;scatter(r, rec, attenuation, scattered))</span><br><span class="line">            <span class="keyword">return</span> attenuation * tracing(scattered, world, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Vector4D(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="comment">//return backgroundColor(Ray(rec.m_position, target - rec.m_position), world) * 0.5f;</span></span><br><span class="line">        <span class="comment">//return rec.normal * 0.5f + Vector3D(0.5f, 0.5f, 0.5f);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> t = <span class="number">0.5f</span> * (r.getDirection().y + <span class="number">1.0f</span>);</span><br><span class="line">        Vector4D ret = Vector3D(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>) * (<span class="number">1.0f</span> - t) + Vector3D(<span class="number">0.5f</span>, <span class="number">0.7f</span>, <span class="number">1.0f</span>) * t;</span><br><span class="line">        ret.w = <span class="number">1.0f</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、程序结果"><a href="#三、程序结果" class="headerlink" title="三、程序结果"></a>三、程序结果</h1><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.9/blog/RayTracer-Basis/ret1.png" alt="ret1"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.9/blog/RayTracer-Basis/ret2.png" alt="ret2"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.9/blog/RayTracer-Basis/ret3.png" alt="ret3"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.9/blog/RayTracer-Basis/ret4.png" alt="ret4"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.9/blog/RayTracer-Basis/ret5.png" alt="ret5"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.9/blog/RayTracer-Basis/ret6.png" alt="ret6"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.9/blog/RayTracer-Basis/ret7.png" alt="ret7"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>$[1]$ <a href="https://www.cnblogs.com/jerrycg/p/4941359.html" target="_blank" rel="noopener">https://www.cnblogs.com/jerrycg/p/4941359.html</a></p><p>$[2]$ <a href="https://blog.csdn.net/baishuo8/article/details/81476422" target="_blank" rel="noopener">https://blog.csdn.net/baishuo8/article/details/81476422</a></p><p>$[3]$ <a href="https://blog.csdn.net/silangquan/article/details/8176855" target="_blank" rel="noopener">https://blog.csdn.net/silangquan/article/details/8176855</a></p><p>$[4]$ Peter Shirley. <a href="https://www.amazon.com/Ray-Tracing-Weekend-Minibooks-Book-ebook/dp/B01B5AODD8/ref=sr_1_1?ie=UTF8&amp;qid=1547695669&amp;sr=8-1&amp;keywords=Peter+Shirley" target="_blank" rel="noopener">Ray Tracing in One Weekend</a>. Amazon Digital Services LLC, January 26, 2016.</p><p>$[5]$ <a href="https://learnopengl-cn.github.io/07 PBR/01 Theory/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/07%20PBR/01%20Theory/</a></p><p>$[6]$ <a href="https://www.cnblogs.com/lv-anchoret/p/10223222.html" target="_blank" rel="noopener">https://www.cnblogs.com/lv-anchoret/p/10223222.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Ray Tracer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> Ray Tracer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软渲染器Soft Renderer：光照着色篇（完结）</title>
      <link href="/2019/05/05/SoftRenderer-Shading/"/>
      <url>/2019/05/05/SoftRenderer-Shading/</url>
      
        <content type="html"><![CDATA[<p>在前面的博客我们已经实现了基本的三维渲染管线流程，这一章主要是在此基础上进行润色，不借助任何库实现obj模型导入、Blin-Phong光照模型、摄像机漫游（第一人称摄像机、第三人称摄像机）。<strong>注意：初学者慎入</strong></p><p><div align="left"> <img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.8/blog/SoftRenderer-Shading/header.gif"></div></p><a id="more"></a><ul><li>obj模型导入</li><li>Blinn-Phong光照着色</li><li>虚拟场景漫游</li><li>程序结果</li><li>结语</li></ul><h1 id="一、obj模型导入"><a href="#一、obj模型导入" class="headerlink" title="一、obj模型导入"></a>一、obj模型导入</h1><p>&emsp;&emsp;obj模型文件（这里不是指c++编译得到的.o中间文件）是一种格式简单、清晰的模型文件，这种模型的格式非常容易解析。目前有一个非常流行的开源的模型导入库<a href="https://github.com/assimp/assimp" target="_blank" rel="noopener">Assimp</a>，封装了各种各样模型文件的加载，省去很多麻烦。而我因为一方面为了尽量避免引入第三方库，另一方面obj模型的导入不难，所以自己实现了一个obj加载类$ObjModel$。实现obj模型加载并不难，只需简单了解一下obj文件的格式即可。</p><p>&emsp;&emsp;obj文件格式有类数据，一类一行，分别以v、vt、vn和f开头。用记事本打开一个简单的obj文件，如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.8/blog/SoftRenderer-Shading/obj.png" alt="obj"></p><p>&emsp;&emsp;以v（即vertex的缩写）开头的一行分别为模型顶点的$x$、$y$、$z$坐标，以vt（即vertex texcoord的缩写）开头的一行分别为纹理坐标的$u$、$v$值，以vn（即vertex normal的缩写）开头的一行分别是法向量的$x$、$y$、$z$值。而f（即face的缩写）格式为v/vt/vn，其中对应的是各自的索引值，一个v/vt/vn描述了一个三角形顶点的顶点坐标、纹理坐标、法线向量，通常以f的一行有三列v/vt/vn，组成一个三角形面片。所以我们读取的时候按照这些开头标记读取即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjModel</span> :</span> <span class="keyword">public</span> Mesh</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Vector3D minPoint, maxPoint;        <span class="comment">// Bounding box.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ctor/dtor.</span></span><br><span class="line">    ObjModel(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;path);</span><br><span class="line">    <span class="keyword">virtual</span> ~ObjModel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Size setting.</span></span><br><span class="line">    <span class="function">Vector3D <span class="title">setSizeToVector</span><span class="params">(<span class="keyword">float</span> sx, <span class="keyword">float</span> sy, <span class="keyword">float</span> sz)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Matrix4x4 <span class="title">setSizeToMatrix</span><span class="params">(<span class="keyword">float</span> sx, <span class="keyword">float</span> sy, <span class="keyword">float</span> sz)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Obj file loader.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadObjFile</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;path)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ObjModel::loadObjFile(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;path)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// obj loader.</span></span><br><span class="line">    ifstream in;</span><br><span class="line">    in.open(path, ifstream::in);</span><br><span class="line">    <span class="keyword">if</span>(in.fail())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Fail to load obj-&gt;"</span> &lt;&lt; path &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> line;</span><br><span class="line">    minPoint = Vector3D(+<span class="number">10000000000</span>,+<span class="number">10000000000</span>,+<span class="number">10000000000</span>);</span><br><span class="line">    maxPoint = Vector3D(<span class="number">-10000000000</span>,<span class="number">-10000000000</span>,<span class="number">-10000000000</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;Vector3D&gt; vertices;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Vector3D&gt; normals;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Vector2D&gt; texcoords;</span><br><span class="line">    <span class="keyword">while</span>(!in.eof())</span><br><span class="line">    &#123;</span><br><span class="line">        getline(in, line);</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">iss</span><span class="params">(line.c_str())</span></span>;</span><br><span class="line">        <span class="keyword">char</span> trash;</span><br><span class="line">        <span class="comment">//vertex</span></span><br><span class="line">        <span class="keyword">if</span>(!line.compare(<span class="number">0</span>, <span class="number">2</span>, <span class="string">"v "</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            iss &gt;&gt; trash;</span><br><span class="line">            Vector3D vertex;</span><br><span class="line">            iss &gt;&gt; vertex.x;</span><br><span class="line">            iss &gt;&gt; vertex.y;</span><br><span class="line">            iss &gt;&gt; vertex.z;</span><br><span class="line">            vertices.push_back(vertex);</span><br><span class="line">            <span class="keyword">if</span>(minPoint.x &gt; vertex.x)minPoint.x = vertex.x;</span><br><span class="line">            <span class="keyword">if</span>(minPoint.y &gt; vertex.y)minPoint.y = vertex.y;</span><br><span class="line">            <span class="keyword">if</span>(minPoint.z &gt; vertex.z)minPoint.z = vertex.z;</span><br><span class="line">            <span class="keyword">if</span>(maxPoint.x &lt; vertex.x)maxPoint.x = vertex.x;</span><br><span class="line">            <span class="keyword">if</span>(maxPoint.y &lt; vertex.y)maxPoint.y = vertex.y;</span><br><span class="line">            <span class="keyword">if</span>(maxPoint.z &lt; vertex.z)maxPoint.z = vertex.z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// normal</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!line.compare(<span class="number">0</span>, <span class="number">3</span>, <span class="string">"vn "</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            iss &gt;&gt; trash &gt;&gt; trash;</span><br><span class="line">            Vector3D normal;</span><br><span class="line">            iss &gt;&gt; normal.x;</span><br><span class="line">            iss &gt;&gt; normal.y;</span><br><span class="line">            iss &gt;&gt; normal.z;</span><br><span class="line">            normal.normalize();</span><br><span class="line">            normals.push_back(normal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// texcoord</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!line.compare(<span class="number">0</span>, <span class="number">3</span>, <span class="string">"vt "</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            iss &gt;&gt; trash &gt;&gt; trash;</span><br><span class="line">            Vector2D texcoord;</span><br><span class="line">            iss &gt;&gt; texcoord.x;</span><br><span class="line">            iss &gt;&gt; texcoord.y;</span><br><span class="line">            texcoords.push_back(texcoord);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// face</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!line.compare(<span class="number">0</span>, <span class="number">2</span>, <span class="string">"f "</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            iss &gt;&gt; trash;</span><br><span class="line">            <span class="keyword">int</span> index[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">while</span>(iss &gt;&gt; index[<span class="number">0</span>] &gt;&gt; trash &gt;&gt; index[<span class="number">1</span>] &gt;&gt; trash &gt;&gt; index[<span class="number">2</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                Vertex data;</span><br><span class="line">                data.position = vertices[index[<span class="number">0</span>] - <span class="number">1</span>];</span><br><span class="line">                data.texcoord = texcoords[index[<span class="number">1</span>] - <span class="number">1</span>];</span><br><span class="line">                data.normal = normals[index[<span class="number">2</span>] - <span class="number">1</span>];</span><br><span class="line">                data.color = Vector4D(<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>);</span><br><span class="line">                m_indices.push_back(m_vertices.size());</span><br><span class="line">                m_vertices.push_back(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到这里继承了父类$Mesh$，这样读进来就作为一个网格类，能够传进渲染管线中渲染。测试读取了几个模型文件，效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.8/blog/SoftRenderer-Shading/loader0.gif" alt="loader0"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.8/blog/SoftRenderer-Shading/loader1.gif" alt="loader1"></p><h1 id="二、Blin-Phong光照着色"><a href="#二、Blin-Phong光照着色" class="headerlink" title="二、Blin-Phong光照着色"></a>二、Blin-Phong光照着色</h1><p>&emsp;&emsp;之前我们的着色器一直都是直接传输数据，没有做一些着色器计算，这里我们给渲染出来的模型加上光照着色。采用的光照模型是Blinn-Phong光照模型，并实现了两种着色器方法，分别是Gouraud着色、Phong着色。注意别混淆了光照模型和着色模型，光照模型是一种理论模型，着色模型则是具体的实现方式。Gouraud着色和Phong着色都是采用Blinn-Phong光照模型，差别在于两者在何处实现光照计算。</p><p>&emsp;&emsp;网上的LearnOpenGL教程很详细地介绍了Phong光照模型以及Blinn-Phong光照（Phong和Blinnn的差别只在于高光计算的一小部分），我就不再说太多这些方面的东西了，想具体了解的朋友请看<a href="[https://learnopengl-cn.github.io/02%20Lighting/02%20Basic%20Lighting/](https://learnopengl-cn.github.io/02 Lighting/02 Basic Lighting/">这里</a>)和<a href="[https://learnopengl-cn.github.io/05%20Advanced%20Lighting/01%20Advanced%20Lighting/](https://learnopengl-cn.github.io/05 Advanced Lighting/01 Advanced Lighting/">这里</a>)。概括起来，Phong光照模型包含环境光、漫反射光和镜面高光，其计算方式如下：</p><script type="math/tex; mode=display">I=K_aI_a+k_dI_ecos\alpha+k_sI_scos^n\lambda \tag {1}</script><p>&emsp;&emsp;其中的$k_a$、$k_d$和$k_s$分别为物体的环境光颜色、漫反射颜色和镜面高光颜色数，$n$是物体的高光读，而$I_a$、$I_e$和$I_s$是光源的环境光颜色、漫反射照亮的颜色和镜面反射的颜色。针对物体材质和光照的种类，我们创建一个$Material$和虚类$Light$，并把光照的计算过程抽象为一个函数$lighting$：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Material</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Material() = <span class="keyword">default</span>;</span><br><span class="line">    ~Material() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">double</span> m_shininess;</span><br><span class="line">    Vector3D m_ambient;</span><br><span class="line">    Vector3D m_diffuse;</span><br><span class="line">    Vector3D m_specular;</span><br><span class="line">    Vector3D m_reflect;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMaterial</span><span class="params">(Vector3D _amb, Vector3D _diff, Vector3D _spec, <span class="keyword">double</span> _shin)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_shininess = _shin;</span><br><span class="line">        m_ambient = _amb;</span><br><span class="line">        m_diffuse = _diff;</span><br><span class="line">        m_specular = _spec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Light</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Light() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Light() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">lighting</span><span class="params">(<span class="keyword">const</span> Material &amp;material,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> Vector3D &amp;position,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> Vector3D &amp;normal,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> Vector3D &amp;eyeDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Vector3D&amp; ambient,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Vector3D&amp; diffuse,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Vector3D&amp; specular)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据光源的种类不同，通常有平行光、点光源和聚束光三类（关于这类光，请看LearnOpenGL的<a href="[https://learnopengl-cn.github.io/02%20Lighting/05%20Light%20casters/](https://learnopengl-cn.github.io/02 Lighting/05 Light casters/">这篇</a>)）。平行光的特点就是光线束都是平行的，因而只需记录平行光的方向即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectionalLight</span> :</span> <span class="keyword">public</span> Light</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector3D m_ambient;</span><br><span class="line">    Vector3D m_diffuse;</span><br><span class="line">    Vector3D m_specular;</span><br><span class="line">    Vector3D m_direction;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">lighting</span><span class="params">(<span class="keyword">const</span> Material &amp;material,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> Vector3D &amp;position,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> Vector3D &amp;normal,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> Vector3D &amp;eyeDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Vector3D&amp; ambient,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Vector3D&amp; diffuse,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Vector3D&amp; specular)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDirectionalLight</span><span class="params">(Vector3D _amb, Vector3D _diff, Vector3D _spec,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Vector3D _dir)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_ambient = _amb;</span><br><span class="line">        m_diffuse = _diff;</span><br><span class="line">        m_specular = _spec;</span><br><span class="line">        m_direction = _dir;</span><br><span class="line">        m_direction.normalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DirectionalLight::lighting(<span class="keyword">const</span> Material &amp;material,</span><br><span class="line">                                <span class="keyword">const</span> Vector3D &amp;position,</span><br><span class="line">                                <span class="keyword">const</span> Vector3D &amp;normal,</span><br><span class="line">                                <span class="keyword">const</span> Vector3D &amp;eyeDir,</span><br><span class="line">                                Vector3D &amp;ambient,</span><br><span class="line">                                Vector3D &amp;diffuse,</span><br><span class="line">                                Vector3D &amp;specular) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">float</span> diff = max(normal.dotProduct(-<span class="keyword">this</span>-&gt;m_direction), <span class="number">0.0f</span>);</span><br><span class="line">    Vector3D halfwayDir = eyeDir + <span class="keyword">this</span>-&gt;m_direction;</span><br><span class="line">    halfwayDir.normalize();</span><br><span class="line">    <span class="keyword">float</span> spec = <span class="built_in">pow</span>(max(eyeDir.dotProduct(halfwayDir), <span class="number">0.0f</span>), material.m_shininess);</span><br><span class="line">    ambient = m_ambient;</span><br><span class="line">    diffuse = m_diffuse * diff;</span><br><span class="line">    specular = m_specular * spec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;点光源则需要记录光源的位置，用以计算光照的方向。与平行光还有一点不同的是，点光源通常有个照明区域范围，光照的强度随着距离的增加而削弱，且这类减弱不是线性的。因此我们还要衰减因子，把计算得到的光照颜色再乘上这个衰减因子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PointLight</span> :</span> <span class="keyword">public</span> Light</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector3D m_ambient;</span><br><span class="line">    Vector3D m_diffuse;</span><br><span class="line">    Vector3D m_specular;</span><br><span class="line">    Vector3D m_position;</span><br><span class="line">    Vector3D m_attenuation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">lighting</span><span class="params">(<span class="keyword">const</span> Material &amp;material,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> Vector3D &amp;position,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> Vector3D &amp;normal,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> Vector3D &amp;eyeDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Vector3D&amp; ambient,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Vector3D&amp; diffuse,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Vector3D&amp; specular)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPointLight</span><span class="params">(Vector3D _amb, Vector3D _diff, Vector3D _spec,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Vector3D _pos, Vector3D _atte)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_ambient = _amb;</span><br><span class="line">        m_diffuse = _diff;</span><br><span class="line">        m_specular = _spec;</span><br><span class="line">        m_position = _pos;</span><br><span class="line">        m_attenuation = _atte;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PointLight::lighting(<span class="keyword">const</span> Material &amp;material,</span><br><span class="line">                          <span class="keyword">const</span> Vector3D &amp;position,</span><br><span class="line">                          <span class="keyword">const</span> Vector3D &amp;normal,</span><br><span class="line">                          <span class="keyword">const</span> Vector3D &amp;eyeDir,</span><br><span class="line">                          Vector3D &amp;ambient,</span><br><span class="line">                          Vector3D &amp;diffuse,</span><br><span class="line">                          Vector3D &amp;specular) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ambient</span></span><br><span class="line">    ambient = <span class="keyword">this</span>-&gt;m_ambient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// diffuse</span></span><br><span class="line">    Vector3D lightDir = (<span class="keyword">this</span>-&gt;m_position - position);</span><br><span class="line">    lightDir.normalize();</span><br><span class="line">    <span class="keyword">float</span> diff = max(normal.dotProduct(lightDir), <span class="number">0.0f</span>);</span><br><span class="line">    diffuse = <span class="keyword">this</span>-&gt;m_diffuse * diff;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// specular</span></span><br><span class="line">    Vector3D halfwayDir = eyeDir + lightDir;</span><br><span class="line">    halfwayDir.normalize();</span><br><span class="line">    <span class="keyword">float</span> spec = <span class="built_in">pow</span>(max(eyeDir.dotProduct(halfwayDir), <span class="number">0.0f</span>), material.m_shininess);</span><br><span class="line">    specular = <span class="keyword">this</span>-&gt;m_specular * spec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// attenuation</span></span><br><span class="line">    <span class="keyword">float</span> distance    = (<span class="keyword">this</span>-&gt;m_position - position).getLength();</span><br><span class="line">    <span class="keyword">float</span> attenuation = <span class="number">1.0</span> / (m_attenuation.x +</span><br><span class="line">                               m_attenuation.y * distance +</span><br><span class="line">                               m_attenuation.z * (distance * distance));</span><br><span class="line">    ambient  *= attenuation;</span><br><span class="line">    diffuse   *= attenuation;</span><br><span class="line">    specular *= attenuation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;聚束光是一种比较特殊的光源（例如手电筒光、舞台灯光），它的特点就是只有在聚光方向的特定半径内的物体才会被照亮，其它的物体都会保持黑暗。我们采用一个光源位置、照明方向和切光角来描述一个聚光灯：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpotLight</span> :</span> <span class="keyword">public</span> Light</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> m_cutoff, m_outcutoff;</span><br><span class="line">    Vector3D m_ambient;</span><br><span class="line">    Vector3D m_diffuse;</span><br><span class="line">    Vector3D m_specular;</span><br><span class="line">    Vector3D m_position;</span><br><span class="line">    Vector3D m_direction;</span><br><span class="line">    Vector3D m_attenuation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">lighting</span><span class="params">(<span class="keyword">const</span> Material &amp;material,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> Vector3D &amp;position,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> Vector3D &amp;normal,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> Vector3D &amp;eyeDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Vector3D&amp; ambient,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Vector3D&amp; diffuse,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Vector3D&amp; specular)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSpotLight</span><span class="params">(Vector3D _amb, Vector3D _diff, Vector3D _spec,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">double</span> _cut, Vector3D _pos, Vector3D _dir, Vector3D _atte)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_cutoff = <span class="built_in">cos</span>(_cut * M_PI/<span class="number">180.0</span>);</span><br><span class="line">        m_outcutoff = <span class="built_in">cos</span>((_cut + <span class="number">10.0</span>) * M_PI/<span class="number">180.0</span>);</span><br><span class="line">        m_ambient = _amb;</span><br><span class="line">        m_diffuse = _diff;</span><br><span class="line">        m_specular = _spec;</span><br><span class="line">        m_position = _pos;</span><br><span class="line">        m_direction = _dir;</span><br><span class="line">        m_attenuation = _atte;</span><br><span class="line">        m_direction.normalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SpotLight::lighting(<span class="keyword">const</span> Material &amp;material,</span><br><span class="line">                         <span class="keyword">const</span> Vector3D &amp;position,</span><br><span class="line">                         <span class="keyword">const</span> Vector3D &amp;normal,</span><br><span class="line">                         <span class="keyword">const</span> Vector3D &amp;eyeDir,</span><br><span class="line">                         Vector3D &amp;ambient,</span><br><span class="line">                         Vector3D &amp;diffuse,</span><br><span class="line">                         Vector3D &amp;specular) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ambient</span></span><br><span class="line">    ambient = <span class="keyword">this</span>-&gt;m_ambient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// diffuse</span></span><br><span class="line">    Vector3D lightDir = <span class="keyword">this</span>-&gt;m_position - position;</span><br><span class="line">    lightDir.normalize();</span><br><span class="line">    <span class="keyword">float</span> diff = max(normal.dotProduct(lightDir), <span class="number">0.0f</span>);</span><br><span class="line">    diffuse = <span class="keyword">this</span>-&gt;m_diffuse * diff ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// specular</span></span><br><span class="line">    Vector3D halfwayDir = eyeDir + lightDir;</span><br><span class="line">    halfwayDir.normalize();</span><br><span class="line">    <span class="keyword">float</span> spec = <span class="built_in">pow</span>(max(eyeDir.dotProduct(halfwayDir), <span class="number">0.0f</span>), material.m_shininess);</span><br><span class="line">    specular = <span class="keyword">this</span>-&gt;m_specular * spec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spotlight (soft edges)</span></span><br><span class="line">    <span class="keyword">float</span> theta = lightDir.dotProduct(-<span class="keyword">this</span>-&gt;m_direction);</span><br><span class="line">    <span class="keyword">float</span> epsilon = (<span class="keyword">this</span>-&gt;m_cutoff - <span class="keyword">this</span>-&gt;m_outcutoff);</span><br><span class="line">    <span class="keyword">float</span> intensity = (theta - <span class="keyword">this</span>-&gt;m_outcutoff) / epsilon;</span><br><span class="line">    <span class="keyword">if</span>(intensity &lt; <span class="number">0.0f</span>)intensity = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">if</span>(intensity &gt; <span class="number">1.0f</span>)intensity = <span class="number">1.0f</span>;</span><br><span class="line">    diffuse  *= intensity;</span><br><span class="line">    specular *= intensity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// attenuation</span></span><br><span class="line">    <span class="keyword">float</span> distance    = (<span class="keyword">this</span>-&gt;m_position - position).getLength();</span><br><span class="line">    <span class="keyword">float</span> attenuation = <span class="number">1.0</span> / (m_attenuation.x +</span><br><span class="line">                               m_attenuation.y * distance +</span><br><span class="line">                               m_attenuation.z * (distance * distance));</span><br><span class="line">    ambient  *= attenuation;</span><br><span class="line">    diffuse  *= attenuation;</span><br><span class="line">    specular *= attenuation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后我们就需要把光照计算集成到着色器中，这里提供了两种方式：光照计算集成到顶点着色器，即Gouraud着色方法，逐顶点光照，然后靠线性插值得到每个像素的光照颜色；光照计算集成到片元着色器，即Phong着色法，逐像素光照，根据插值得到的法向量做相应的计算。显然前者计算量少了很多，但是后者更为真实。我们建立一个$Gouraud$着色类如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GouraudShader</span> :</span> <span class="keyword">public</span> BaseShader</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Those are not created by shader.</span></span><br><span class="line">    <span class="keyword">const</span> Light     *m_light;       <span class="comment">// Light.(just only one)</span></span><br><span class="line">    <span class="keyword">const</span> Material  *m_material;    <span class="comment">// Mesh material.</span></span><br><span class="line">    <span class="keyword">const</span> Texture2D *m_unit;        <span class="comment">// Texture unit.</span></span><br><span class="line"></span><br><span class="line">    Vector3D  m_eyePos;             <span class="comment">// Observer's position.</span></span><br><span class="line">    Matrix4x4 m_modelMatrix;        <span class="comment">// Model matrix.</span></span><br><span class="line">    Matrix4x4 m_viewMatrix;         <span class="comment">// View matrix.</span></span><br><span class="line">    Matrix4x4 m_projectMatrix;      <span class="comment">// Projection matrix.</span></span><br><span class="line">    Matrix4x4 m_invModelMatrix;     <span class="comment">// Inverse of model matrix for normal.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ctor/dtor.</span></span><br><span class="line">    GouraudShader();</span><br><span class="line">    <span class="keyword">virtual</span> ~GouraudShader() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shader stage.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> VertexOut <span class="title">vertexShader</span><span class="params">(<span class="keyword">const</span> Vertex &amp;in)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector4D <span class="title">fragmentShader</span><span class="params">(<span class="keyword">const</span> VertexOut &amp;in)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shader setting.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bindShaderUnit</span><span class="params">(Texture2D *unit)</span></span>&#123;m_unit = unit;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setModelMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;world)</span></span></span><br><span class="line"><span class="function">    </span>&#123;m_modelMatrix = world;m_invModelMatrix = m_modelMatrix.getInverseTranspose();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setViewMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;view)</span></span>&#123;m_viewMatrix = view;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setProjectMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;project)</span></span>&#123;m_projectMatrix = project;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setMaterial</span><span class="params">(<span class="keyword">const</span> Material *material)</span></span>&#123;m_material = material;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setLight</span><span class="params">(<span class="keyword">const</span> Light *light)</span></span>&#123;m_light = light;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setEyePos</span><span class="params">(<span class="keyword">const</span> Vector3D eye)</span></span>&#123;m_eyePos = eye;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里提一下关于顶点法向量的变换矩阵。我们目前已经有顶点的model矩阵，但是顶点做变换之后的法向量却不能直接乘上model矩阵获得。我们知道顶点的切线与法线相互垂直，因而它们的点乘为$0$，即有：</p><script type="math/tex; mode=display">N\cdot T = N^T*T = 0 \tag {2}</script><p>&emsp;&emsp;顶点切线必然随着模型矩阵的变换而变换，即模型矩阵为$M$，因而变换后的切线$T’=M\cdot T$。我们记变换后的法向量为$N’$，其正确的法线变换为$Q$，则$N’=Q\cdot N$，那么变换后$N’$和$T’$应该依旧保持垂直关系，依旧有$N’\cdot T’=(Q\cdot N)\cdot (M\cdot T)=(Q\cdot N)^T\cdot (M\cdot T)=N^T\cdot (Q^T\cdot M)\cdot T$，与公式$(2)$对比，我们只要令$Q^T\cdot M = I$结果为单位矩阵，则有$N’\cdot T’=N\cdot T = 0$。从而可得法线的变换矩阵为：</p><script type="math/tex; mode=display">Q= (N^{-1})^T \tag {3}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">VertexOut GouraudShader::vertexShader(<span class="keyword">const</span> Vertex &amp;in)</span><br><span class="line">&#123;</span><br><span class="line">    VertexOut result;</span><br><span class="line">    result.posTrans = m_modelMatrix * in.position;</span><br><span class="line">    result.posH = m_projectMatrix * m_viewMatrix * result.posTrans;</span><br><span class="line">    result.color = in.color;</span><br><span class="line">    result.texcoord = in.texcoord;</span><br><span class="line">    result.normal = m_invModelMatrix * Vector4D(in.normal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Gouraud shading.</span></span><br><span class="line">    <span class="keyword">if</span>(m_unit)</span><br><span class="line">        result.color = m_unit-&gt;sample(result.texcoord);</span><br><span class="line">    Vector3D _amb, _diff, _spec;</span><br><span class="line">    <span class="keyword">if</span>(m_light)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3D eyeDir = m_eyePos - result.posTrans;</span><br><span class="line">        eyeDir.normalize();</span><br><span class="line">        m_light-&gt;lighting(*m_material,</span><br><span class="line">                          result.posTrans,</span><br><span class="line">                          result.normal,</span><br><span class="line">                          eyeDir,</span><br><span class="line">                          _amb,</span><br><span class="line">                          _diff,</span><br><span class="line">                          _spec);</span><br><span class="line"></span><br><span class="line">        result.color.x *= (_amb.x + _diff.x + _spec.x);</span><br><span class="line">        result.color.y *= (_amb.y + _diff.y + _spec.y);</span><br><span class="line">        result.color.z *= (_amb.z + _diff.z + _spec.z);</span><br><span class="line">        result.color.w = <span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// oneDivZ to correct lerp.</span></span><br><span class="line">    result.oneDivZ = <span class="number">1.0</span> / result.posH.w;</span><br><span class="line">    result.posTrans *= result.oneDivZ;</span><br><span class="line">    result.texcoord *= result.oneDivZ;</span><br><span class="line">    result.color *= result.oneDivZ;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector4D GouraudShader::fragmentShader(<span class="keyword">const</span> VertexOut &amp;in)</span><br><span class="line">&#123;</span><br><span class="line">    Vector4D litColor = in.color;</span><br><span class="line">    <span class="keyword">return</span> litColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Phong着色方式则在$fragmentShader$中实现光照计算，原理简单，不再赘述。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhongShader</span> :</span> <span class="keyword">public</span> BaseShader</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Those are not created by shader.</span></span><br><span class="line">    <span class="keyword">const</span> Light     *m_light;       <span class="comment">// Light.(just only one)</span></span><br><span class="line">    <span class="keyword">const</span> Material  *m_material;    <span class="comment">// Mesh material.</span></span><br><span class="line">    <span class="keyword">const</span> Texture2D *m_unit;        <span class="comment">// Texture unit.</span></span><br><span class="line"></span><br><span class="line">    Vector3D  m_eyePos;             <span class="comment">// Observer's position.</span></span><br><span class="line">    Matrix4x4 m_modelMatrix;        <span class="comment">// Model matrix.</span></span><br><span class="line">    Matrix4x4 m_viewMatrix;         <span class="comment">// View matrix.</span></span><br><span class="line">    Matrix4x4 m_projectMatrix;      <span class="comment">// Projection matrix.</span></span><br><span class="line">    Matrix4x4 m_invModelMatrix;     <span class="comment">// Inverse of model matrix for normal.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ctor/dtor</span></span><br><span class="line">    PhongShader();</span><br><span class="line">    <span class="keyword">virtual</span> ~PhongShader() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shader stage.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> VertexOut <span class="title">vertexShader</span><span class="params">(<span class="keyword">const</span> Vertex &amp;in)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector4D <span class="title">fragmentShader</span><span class="params">(<span class="keyword">const</span> VertexOut &amp;in)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shader setting.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bindShaderUnit</span><span class="params">(Texture2D *unit)</span></span>&#123;m_unit = unit;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setModelMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;world)</span></span></span><br><span class="line"><span class="function">    </span>&#123;m_modelMatrix = world;m_invModelMatrix = m_modelMatrix.getInverseTranspose();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setViewMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;view)</span></span>&#123;m_viewMatrix = view;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setProjectMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;project)</span></span>&#123;m_projectMatrix = project;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setMaterial</span><span class="params">(<span class="keyword">const</span> Material *material)</span></span>&#123;m_material = material;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setLight</span><span class="params">(<span class="keyword">const</span> Light *light)</span></span>&#123;m_light = light;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setEyePos</span><span class="params">(<span class="keyword">const</span> Vector3D eye)</span></span>&#123;m_eyePos = eye;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">VertexOut PhongShader::vertexShader(<span class="keyword">const</span> Vertex &amp;in)</span><br><span class="line">&#123;</span><br><span class="line">    VertexOut result;</span><br><span class="line">    result.posTrans = m_modelMatrix * in.position;</span><br><span class="line">    result.posH = m_projectMatrix * m_viewMatrix * result.posTrans;</span><br><span class="line">    result.color = in.color;</span><br><span class="line">    result.texcoord = in.texcoord;</span><br><span class="line">    result.normal = m_invModelMatrix * Vector4D(in.normal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// oneDivZ to correct lerp.</span></span><br><span class="line">    result.oneDivZ = <span class="number">1.0</span> / result.posH.w;</span><br><span class="line">    result.posTrans *= result.oneDivZ;</span><br><span class="line">    result.texcoord *= result.oneDivZ;</span><br><span class="line">    result.color *= result.oneDivZ;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector4D PhongShader::fragmentShader(<span class="keyword">const</span> VertexOut &amp;in)</span><br><span class="line">&#123;</span><br><span class="line">    Vector4D litColor = in.color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Gouraud shading.</span></span><br><span class="line">    <span class="keyword">if</span>(m_unit)</span><br><span class="line">        litColor = m_unit-&gt;sample(in.texcoord);</span><br><span class="line">    Vector3D _amb, _diff, _spec;</span><br><span class="line">    <span class="keyword">if</span>(m_light)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3D eyeDir = m_eyePos - in.posTrans;</span><br><span class="line">        eyeDir.normalize();</span><br><span class="line">        m_light-&gt;lighting(*m_material,</span><br><span class="line">                          in.posTrans,</span><br><span class="line">                          in.normal,</span><br><span class="line">                          eyeDir,</span><br><span class="line">                          _amb,</span><br><span class="line">                          _diff,</span><br><span class="line">                          _spec);</span><br><span class="line"></span><br><span class="line">        litColor.x *= (_amb.x + _diff.x + _spec.x);</span><br><span class="line">        litColor.y *= (_amb.y + _diff.y + _spec.y);</span><br><span class="line">        litColor.z *= (_amb.z + _diff.z + _spec.z);</span><br><span class="line">        litColor.w = <span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> litColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;下图分别为Phong着色方式的平行光、点光源、聚束光效果：</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.8/blog/SoftRenderer-Shading/directionalLight.gif" alt="directionalLight"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.8/blog/SoftRenderer-Shading/pointLight.gif" alt="pointLight"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.8/blog/SoftRenderer-Shading/spotlight.gif" alt="spotlight"></p><h1 id="三、虚拟场景漫游"><a href="#三、虚拟场景漫游" class="headerlink" title="三、虚拟场景漫游"></a>三、虚拟场景漫游</h1><p>&emsp;&emsp;虚拟场景漫游是一个三维程序必不可少的，我们比较常用的虚拟摄像机有两类：第一人称摄像机、第三人生摄像机。第三人称摄像机又称为半上帝视角，一般的rpg游戏都是采用的第三人称视角。摄像机一般都是相应键盘按键、鼠标移动、鼠标滚轮事件，为了方便描述，我们创建一个$Camera3D$虚类如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Camera3D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Local axis.</span></span><br><span class="line">    <span class="comment">// Here LocalForward should (0,0,-1).</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> Vector3D LocalForward;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> Vector3D LocalUp;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> Vector3D LocalRight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ctor/dtor.</span></span><br><span class="line">    Camera3D() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Camera3D()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Matrix4x4 <span class="title">getViewMatrix</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector3D <span class="title">getPosition</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Key/Mouse reaction.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onKeyPress</span><span class="params">(<span class="keyword">char</span> key)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onWheelMove</span><span class="params">(<span class="keyword">double</span> delta)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onMouseMove</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY, <span class="built_in">std</span>::<span class="built_in">string</span> button)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1、第一人称相机"><a href="#1、第一人称相机" class="headerlink" title="1、第一人称相机"></a>1、第一人称相机</h2><p>&emsp;&emsp;LearnOpenGl的<a href="[https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera/](https://learnopengl-cn.github.io/01 Getting started/09 Camera/">这篇</a>)对第一人称相机的构建做了的很详细的描述。<strong>不同的是，我不再采用欧拉角来描述渲染，而是采用了四元数（关于四元数，请看知乎的<a href="https://www.zhihu.com/question/23005815/answer/33971127" target="_blank" rel="noopener">这篇</a>）。</strong>理解了四元数，采用欧拉角反而比较繁琐。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FPSCamera</span> :</span> <span class="keyword">public</span> Camera3D</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> m_dirty;       <span class="comment">// Should update or not.</span></span><br><span class="line">    Vector3D m_translation;     <span class="comment">// Camera's translation.</span></span><br><span class="line">    Quaternion m_rotation;      <span class="comment">// Camera's rotation.</span></span><br><span class="line">    Matrix4x4 m_viewMatrix;     <span class="comment">// View Matrix.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ctor/dtor</span></span><br><span class="line">    FPSCamera(Vector3D _pos);</span><br><span class="line">    <span class="keyword">virtual</span> ~FPSCamera() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector3D <span class="title">getPosition</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_translation;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Matrix4x4 <span class="title">getViewMatrix</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Key/Mouse reaction.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onKeyPress</span><span class="params">(<span class="keyword">char</span> key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onWheelMove</span><span class="params">(<span class="keyword">double</span> delta)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onMouseMove</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY, <span class="built_in">std</span>::<span class="built_in">string</span> button)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Transform camera's axis.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">translate</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;dt)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;axis, <span class="keyword">float</span> angle)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTranslation</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRotation</span><span class="params">(<span class="keyword">const</span> Quaternion &amp;r)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Query for camera's axis.</span></span><br><span class="line">    <span class="function">Vector3D <span class="title">forward</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Vector3D <span class="title">up</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Vector3D <span class="title">right</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FPSCamera::onKeyPress(<span class="keyword">char</span> key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span>(key)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'W'</span>:</span><br><span class="line">        <span class="keyword">this</span>-&gt;translate(forward() * <span class="number">0.2f</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">        <span class="keyword">this</span>-&gt;translate(-forward() * <span class="number">0.2f</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">        <span class="keyword">this</span>-&gt;translate(-right() * <span class="number">0.2f</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">        <span class="keyword">this</span>-&gt;translate(+right() * <span class="number">0.2f</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Q'</span>:</span><br><span class="line">        <span class="keyword">this</span>-&gt;translate(up() * <span class="number">0.2f</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'E'</span>:</span><br><span class="line">        <span class="keyword">this</span>-&gt;translate(-up() * <span class="number">0.2f</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FPSCamera::onWheelMove(<span class="keyword">double</span> delta)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// nothing now.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FPSCamera::onMouseMove(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY, <span class="built_in">std</span>::<span class="built_in">string</span> button)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> speed = <span class="number">0.1f</span>;</span><br><span class="line">    deltaX *= speed;</span><br><span class="line">    deltaY *= speed;</span><br><span class="line">    <span class="keyword">this</span>-&gt;rotate(LocalUp, -deltaX);</span><br><span class="line">    <span class="keyword">this</span>-&gt;rotate(right(), -deltaY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、第三人称摄像机"><a href="#2、第三人称摄像机" class="headerlink" title="2、第三人称摄像机"></a>2、第三人称摄像机</h2><p>&emsp;&emsp;第三人称有一个固定的目标，这个目标通常就是玩家操控的物体。摄像机可以拉远拉近、围绕目标在$xz$平面旋转、绕$x$轴上下旋转，而且摄像机永远在玩家的上方（即俯视）。为此，我们用$distance$（摄像机到玩家的距离）、$pitch$（绕$x$轴的旋转角）、$yaw$（绕$y$轴的旋转角）来获取摄像机的位置，最后获取了摄像机的位置后我们就可以直接用$LookAt$矩阵获得视图矩阵。更多关于第三人称摄像机方面的细节请看youtube上的这个<a href="https://www.youtube.com/watch?v=PoxDDZmctnU&amp;list=PLRIWtICgwaX0u7Rf9zkZhLoLuZVfUksDP&amp;index=19" target="_blank" rel="noopener">视频</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TPSCamera</span> :</span> <span class="keyword">public</span> Camera3D</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> m_dirty;               <span class="comment">// Should update or not.</span></span><br><span class="line">    Vector3D m_cameraPos;               <span class="comment">// Camera's position.</span></span><br><span class="line">    Transform3D m_player;               <span class="comment">// Player's transformation.</span></span><br><span class="line">    Matrix4x4 m_viewMatrix;             <span class="comment">// View matrix.</span></span><br><span class="line">    <span class="keyword">double</span> m_yaw, m_pitch, m_distance;  <span class="comment">// yaw, pitch and distance to player's space.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ctor/dtor.</span></span><br><span class="line">    TPSCamera(Vector3D target);</span><br><span class="line">    <span class="keyword">virtual</span> ~TPSCamera() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter.</span></span><br><span class="line">    <span class="function">Matrix4x4 <span class="title">getPlayerMatrix</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Matrix4x4 <span class="title">getViewMatrix</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector3D <span class="title">getPosition</span><span class="params">()</span> </span>&#123;update();<span class="keyword">return</span> m_cameraPos;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Key/Mouse reaction.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onKeyPress</span><span class="params">(<span class="keyword">char</span> key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onWheelMove</span><span class="params">(<span class="keyword">double</span> delta)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onMouseMove</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY, <span class="built_in">std</span>::<span class="built_in">string</span> button)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Update view matrix.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> TPSCamera::onKeyPress(<span class="keyword">char</span> key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> speed = <span class="number">2.0f</span>;</span><br><span class="line">    <span class="keyword">switch</span>(key)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'W'</span>:</span><br><span class="line">        m_dirty = <span class="literal">true</span>;</span><br><span class="line">        m_player.translate(-m_player.forward() * <span class="number">0.1f</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">        m_dirty = <span class="literal">true</span>;</span><br><span class="line">        m_player.translate(+m_player.forward() * <span class="number">0.1f</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">        m_dirty = <span class="literal">true</span>;</span><br><span class="line">        m_player.rotate(m_player.up(), +speed);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">        m_dirty = <span class="literal">true</span>;</span><br><span class="line">        m_player.rotate(m_player.up(), -speed);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> TPSCamera::onWheelMove(<span class="keyword">double</span> delta)</span><br><span class="line">&#123;</span><br><span class="line">    m_dirty = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">double</span> speed = <span class="number">0.01</span>;</span><br><span class="line">    m_distance += -speed * delta;</span><br><span class="line">    <span class="keyword">if</span>(m_distance &gt; <span class="number">35.0</span>)m_distance = <span class="number">35.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(m_distance &lt; <span class="number">5.00</span>)m_distance = <span class="number">5.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> TPSCamera::onMouseMove(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY, <span class="built_in">std</span>::<span class="built_in">string</span> button)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> speed = <span class="number">0.2</span>;</span><br><span class="line">    <span class="keyword">if</span>(button == <span class="string">"RIGHT"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_dirty = <span class="literal">true</span>;</span><br><span class="line">        m_pitch += speed * deltaY;</span><br><span class="line">        <span class="keyword">if</span>(m_pitch &lt; <span class="number">0.0</span>)m_pitch = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(m_pitch &gt; <span class="number">89.9</span>)m_pitch = <span class="number">89.9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(button == <span class="string">"LEFT"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_dirty = <span class="literal">true</span>;</span><br><span class="line">        m_yaw   += -speed * deltaX;</span><br><span class="line">        <span class="built_in">fmod</span>(m_yaw, <span class="number">360.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> TPSCamera::update()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_dirty)</span><br><span class="line">    &#123;</span><br><span class="line">        m_dirty = <span class="literal">false</span>;</span><br><span class="line">        Vector3D target = m_player.translation();</span><br><span class="line">        <span class="keyword">float</span> height = m_distance * <span class="built_in">sin</span>(radians(m_pitch));</span><br><span class="line">        <span class="keyword">float</span> horizon = m_distance * <span class="built_in">cos</span>(radians(m_pitch));</span><br><span class="line">        Vector3D _playerRot = m_player.rotation().eulerAngle();</span><br><span class="line">        _playerRot.y = <span class="built_in">fmod</span>(_playerRot.y, <span class="number">360</span>);</span><br><span class="line">        m_cameraPos.y = target.y + height;</span><br><span class="line">        m_cameraPos.x = target.x + horizon * <span class="built_in">sin</span>(radians(m_yaw));</span><br><span class="line">        m_cameraPos.z = target.z + horizon * <span class="built_in">cos</span>(radians(m_yaw));</span><br><span class="line">        m_viewMatrix.setLookAt(m_cameraPos, m_player.translation(), LocalUp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、程序结果"><a href="#四、程序结果" class="headerlink" title="四、程序结果"></a>四、程序结果</h1><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.8/blog/SoftRenderer-Shading/ret1.gif" alt="ret1"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.8/blog/SoftRenderer-Shading/ret2.gif" alt="ret2"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.8/blog/SoftRenderer-Shading/ret3.gif" alt="ret3"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.8/blog/SoftRenderer-Shading/ret4.gif" alt="ret4"></p><h1 id="五、结语"><a href="#五、结语" class="headerlink" title="五、结语"></a>五、结语</h1><p>&emsp;&emsp;软渲染器的搭建就此告一段落，不借助任何图形库从零开始搭建这么一个渲染管线的初衷是为了更加深入地了解当前三维渲染的整个流程，很多理论东西需要实践才能彻底地理解。这么几天关于搭建软渲染器的折腾让我收获不少，这为以后的图形学道路打下了深厚的基础。目前我实现的软渲染管线已经包含了一个传统固定管线的基本功能，我借助一些工具统计得软渲染管线的核心代码（不包括空行、注释）共2838行。不再打算加入更多的功能特性如透明融合、阴影等等，因为没必要了。相关的全部源代码已经提交到github上，请点<a href="https://github.com/ZeusYang/Soft-Renderer" target="_blank" rel="noopener">这里</a>。</p><p>&emsp;&emsp;由于本人的知识水平有限，若网友发现任何bug或者博文叙述错误，欢迎指正，感谢！</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>$[1]$ <a href="https://learnopengl-cn.github.io/02 Lighting/02 Basic Lighting/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/02%20Lighting/02%20Basic%20Lighting/</a></p><p>$[2]$ <a href="https://learnopengl-cn.github.io/01 Getting started/09 Camera/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera/</a></p><p>$[3]$ <a href="https://www.youtube.com/watch?v=PoxDDZmctnU&amp;list=PLRIWtICgwaX0u7Rf9zkZhLoLuZVfUksDP&amp;index=19" target="_blank" rel="noopener">https://www.youtube.com/watch?v=PoxDDZmctnU&amp;list=PLRIWtICgwaX0u7Rf9zkZhLoLuZVfUksDP&amp;index=19</a></p><p>$[4]$ <a href="https://github.com/ssloy/tinyrenderer/wiki" target="_blank" rel="noopener">https://github.com/ssloy/tinyrenderer/wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Soft Renderer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> Soft Renderer </tag>
            
            <tag> 3D pipeline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软渲染器Soft Renderer：进击三维篇</title>
      <link href="/2019/05/02/SoftRenderer-3DPipeline/"/>
      <url>/2019/05/02/SoftRenderer-3DPipeline/</url>
      
        <content type="html"><![CDATA[<p>有了自己实现好的的3D数学库和一个基本的光栅化渲染框架，就可以开始向这个渲染框架填充内容了。本章内容主要关于3维渲染管线的实现、深度测试、背面剔除、几何裁剪、透视纹理映射，这些内容早已被渲染API集成。学习和实现这些算法，是为了彻底了解三维物体的整个渲染流程。<strong>注意：初学者慎入</strong></p><p><div align="left"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.7/blog/SoftRenderer-3DPipeline/header.gif"></div></p><a id="more"></a><ul><li>进入三维世界</li><li>裁剪、剔除优化</li><li>透视纹理映射、采样</li><li>程序结果</li></ul><h1 id="一、进入三维世界"><a href="#一、进入三维世界" class="headerlink" title="一、进入三维世界"></a>一、进入三维世界</h1><p>&emsp;&emsp;尽管二维的屏幕只能显示二维的像素，但是我们可以通过将三维的物体变换到二维的屏幕上，从而渲染出三维空间的一个投影面。这与我们人类的视觉系统类似，视网膜上最终获取的也只是三维空间某个角度下的投影。为了让三维物体正确地显示到屏幕上，我们需要借助一系列的坐标空间变换。</p><h2 id="1、坐标系统"><a href="#1、坐标系统" class="headerlink" title="1、坐标系统"></a>1、坐标系统</h2><p>&emsp;&emsp;在渲染管线中，三维物体的顶点在最终转换为屏幕坐标之前会被变换到多个坐标系统，这其中有几个过渡性的坐标系，使得整个变换流程逻辑清晰、便于理解。此外在某些特定情况下在这些特定的坐标系中，一些操作更加容易、方便和<strong>灵活</strong>。通常，渲染管线有$5$个不同的坐标系统，分别是局部空间、世界空间、视觉空间、裁剪空间和屏幕空间，以下是<a href="[https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/#_1](https://learnopengl-cn.github.io/01 Getting started/08 Coordinate Systems/#_1">LearnOpenGL CN</a>)的原话：</p><p><img src="https://learnopengl-cn.github.io/img/01/08/coordinate_systems.png" alt="coordinate_systems"></p><blockquote><ol><li><p>局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。</p></li><li><p>下一步是将局部坐标变换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放。</p></li><li><p>接下来我们将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。</p></li><li><p>坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上。</p></li><li><p>最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换(Viewport Transform)的过程。视口变换将位于-1.0到1.0范围的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段</p></li></ol></blockquote><p>&emsp;&emsp;通过以上的几个步骤，三维的物体坐标最终变换到了屏幕的坐标上，其中视图矩阵和投影矩阵的构建较为复杂一点，前面我的博文<a href="https://yangwc.com/2019/05/01/SoftRenderer-Math/" target="_blank" rel="noopener">软渲染器Soft Renderer：3D数学篇</a>已经推导过这两个矩阵，这里就不再赘述了。若想查看更多关于坐标系统的内容，请查看<a href="https://learnopengl-cn.github.io/" target="_blank" rel="noopener">LearnOpenGL CN</a>的这篇文章：<a href="[https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/#_1](https://learnopengl-cn.github.io/01 Getting started/08 Coordinate Systems/#_1">坐标系统</a>)。坐标变换是一般发生在顶点着色器以及顶点着色器输出到光栅化这一阶段，视口变换在顶点着色器输出之后，不在着色器中进行（视口变换已经在前面的光栅化篇提到过了）。所以为了实现坐标变换，我们的着色器要存储$model$、$view$、$project$这三个矩阵，在$SimpleShader$中添加相关的成员变量及方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleShader</span> :</span> <span class="keyword">public</span> BaseShader</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Matrix4x4 m_modelMatrix;</span><br><span class="line">    Matrix4x4 m_viewMatrix;</span><br><span class="line">    Matrix4x4 m_projectMatrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ......</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setModelMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;world)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setViewMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;view)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setProjectMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;project)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SimpleShader::setModelMatrix(<span class="keyword">const</span> Matrix4x4 &amp;world)</span><br><span class="line">&#123;</span><br><span class="line">    m_modelMatrix = world;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SimpleShader::setViewMatrix(<span class="keyword">const</span> Matrix4x4 &amp;view)</span><br><span class="line">&#123;</span><br><span class="line">    m_viewMatrix = view;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SimpleShader::setProjectMatrix(<span class="keyword">const</span> Matrix4x4 &amp;project)</span><br><span class="line">&#123;</span><br><span class="line">    m_projectMatrix = project;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样外部要渲染时，应该向着色器输入这三个矩阵。然后在我们的顶点着色器中填入相关的逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">VertexOut SimpleShader::vertexShader(<span class="keyword">const</span> Vertex &amp;in)</span><br><span class="line">&#123;</span><br><span class="line">    VertexOut result;</span><br><span class="line">    result.posTrans = m_modelMatrix * in.position;</span><br><span class="line">    result.posH = m_projectMatrix * m_viewMatrix * result.posTrans;</span><br><span class="line">    result.color = in.color;</span><br><span class="line">    result.normal = in.normal;</span><br><span class="line">    result.texcoord = in.texcoord;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;$VertexOut$是前面文章定义的顶点着色器输出的类，它存储投影后的顶点$posH$、世界空间中的顶点$posTrans$、物体的颜色、顶点法线以及纹理坐标。<strong>接着在视口变换并送入光栅化部件之前执行透视除法，即直接将裁剪空间的顶点坐标除以它的第四个分量$w$即可</strong>。然后我们在外部的渲染循环中设置模型矩阵、视图矩阵已经投影矩阵，就能显示出三维的立体感了，以我们前一章画的三角形为例（gif录制的好像有bug，出现绿色它就给我录制成这个模糊的鬼样，实际上是非常清晰，不是渲染的锅）。</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.7/blog/SoftRenderer-3DPipeline/triangle.gif" alt="triangle"></p><p>&emsp;&emsp;进入3D世界，怎么能少了3D渲染的”hello world!”——立方体呢？在$Mesh.h$手动创建一个立方体的网格数据，然后用立方体替换掉上面丑陋的三角形：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Mesh::asBox(<span class="keyword">double</span> width, <span class="keyword">double</span> height, <span class="keyword">double</span> depth)</span><br><span class="line">&#123;</span><br><span class="line">    vertices.resize(<span class="number">24</span>);</span><br><span class="line">    indices.resize(<span class="number">36</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> halfW = width * <span class="number">0.5f</span>;</span><br><span class="line">    <span class="keyword">float</span> halfH = height * <span class="number">0.5f</span>;</span><br><span class="line">    <span class="keyword">float</span> halfD = depth * <span class="number">0.5f</span>;</span><br><span class="line">    <span class="comment">//front</span></span><br><span class="line">    vertices[<span class="number">0</span>].position = Vector3D(halfW, halfH, halfD);</span><br><span class="line">    vertices[<span class="number">0</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">0</span>].color = Vector4D(<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">0</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">1</span>].position = Vector3D(-halfW, halfH, halfD);</span><br><span class="line">    vertices[<span class="number">1</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">1</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">1</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">2</span>].position = Vector3D(-halfW,-halfH, halfD);</span><br><span class="line">    vertices[<span class="number">2</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">2</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">2</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">3</span>].position = Vector3D(halfW, -halfH, halfD);</span><br><span class="line">    vertices[<span class="number">3</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">3</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">3</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    <span class="comment">//left</span></span><br><span class="line">    vertices[<span class="number">4</span>].position = Vector3D(-halfW, +halfH, halfD);</span><br><span class="line">    vertices[<span class="number">4</span>].normal = Vector3D(<span class="number">-1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">4</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">4</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">5</span>].position = Vector3D(-halfW, +halfH, -halfD);</span><br><span class="line">    vertices[<span class="number">5</span>].normal = Vector3D(<span class="number">-1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">5</span>].color = Vector4D(<span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">5</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">6</span>].position = Vector3D(-halfW, -halfH, -halfD);</span><br><span class="line">    vertices[<span class="number">6</span>].normal = Vector3D(<span class="number">-1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">6</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">6</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">7</span>].position = Vector3D(-halfW, -halfH, halfD);</span><br><span class="line">    vertices[<span class="number">7</span>].normal = Vector3D(<span class="number">-1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">7</span>].color = Vector4D(<span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">7</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    <span class="comment">//back</span></span><br><span class="line">    vertices[<span class="number">8</span>].position = Vector3D(-halfW, +halfH, -halfD);</span><br><span class="line">    vertices[<span class="number">8</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">-1.f</span>);</span><br><span class="line">    vertices[<span class="number">8</span>].color = Vector4D(<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">8</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">9</span>].position = Vector3D(+halfW, +halfH, -halfD);</span><br><span class="line">    vertices[<span class="number">9</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">-1.f</span>);</span><br><span class="line">    vertices[<span class="number">9</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">9</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">10</span>].position = Vector3D(+halfW, -halfH, -halfD);</span><br><span class="line">    vertices[<span class="number">10</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">-1.f</span>);</span><br><span class="line">    vertices[<span class="number">10</span>].color = Vector4D(<span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">10</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">11</span>].position = Vector3D(-halfW, -halfH, -halfD);</span><br><span class="line">    vertices[<span class="number">11</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">-1.f</span>);</span><br><span class="line">    vertices[<span class="number">11</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">11</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    <span class="comment">//right</span></span><br><span class="line">    vertices[<span class="number">12</span>].position = Vector3D(halfW, +halfH, -halfD);</span><br><span class="line">    vertices[<span class="number">12</span>].normal = Vector3D(<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">12</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">12</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">13</span>].position = Vector3D(halfW, +halfH, +halfD);</span><br><span class="line">    vertices[<span class="number">13</span>].normal = Vector3D(<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">13</span>].color = Vector4D(<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">13</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">14</span>].position = Vector3D(halfW, -halfH, +halfD);</span><br><span class="line">    vertices[<span class="number">14</span>].normal = Vector3D(<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">14</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">14</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">15</span>].position = Vector3D(halfW, -halfH, -halfD);</span><br><span class="line">    vertices[<span class="number">15</span>].normal = Vector3D(<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">15</span>].color = Vector4D(<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">15</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    <span class="comment">//top</span></span><br><span class="line">    vertices[<span class="number">16</span>].position = Vector3D(+halfW, halfH, -halfD);</span><br><span class="line">    vertices[<span class="number">16</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">16</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">16</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">17</span>].position = Vector3D(-halfW, halfH, -halfD);</span><br><span class="line">    vertices[<span class="number">17</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">17</span>].color = Vector4D(<span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">17</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">18</span>].position = Vector3D(-halfW, halfH, halfD);</span><br><span class="line">    vertices[<span class="number">18</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">18</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">18</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">19</span>].position = Vector3D(+halfW, halfH, halfD);</span><br><span class="line">    vertices[<span class="number">19</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">19</span>].color = Vector4D(<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">19</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    <span class="comment">//down</span></span><br><span class="line">    vertices[<span class="number">20</span>].position = Vector3D(+halfW, -halfH, -halfD);</span><br><span class="line">    vertices[<span class="number">20</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">-1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">20</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">20</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">21</span>].position = Vector3D(+halfW, -halfH, +halfD);</span><br><span class="line">    vertices[<span class="number">21</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">-1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">21</span>].color = Vector4D(<span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">21</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">22</span>].position = Vector3D(-halfW, -halfH, +halfD);</span><br><span class="line">    vertices[<span class="number">22</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">-1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">22</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">22</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">23</span>].position = Vector3D(-halfW, -halfH, -halfD);</span><br><span class="line">    vertices[<span class="number">23</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">-1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">23</span>].color = Vector4D(<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">23</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//front</span></span><br><span class="line">    indices[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    indices[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    indices[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    indices[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    indices[<span class="number">4</span>] = <span class="number">2</span>;</span><br><span class="line">    indices[<span class="number">5</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//left</span></span><br><span class="line">    indices[<span class="number">6</span>] = <span class="number">4</span>;</span><br><span class="line">    indices[<span class="number">7</span>] = <span class="number">5</span>;</span><br><span class="line">    indices[<span class="number">8</span>] = <span class="number">6</span>;</span><br><span class="line">    indices[<span class="number">9</span>] = <span class="number">4</span>;</span><br><span class="line">    indices[<span class="number">10</span>] = <span class="number">6</span>;</span><br><span class="line">    indices[<span class="number">11</span>] = <span class="number">7</span>;</span><br><span class="line">    <span class="comment">//back</span></span><br><span class="line">    indices[<span class="number">12</span>] = <span class="number">8</span>;</span><br><span class="line">    indices[<span class="number">13</span>] = <span class="number">9</span>;</span><br><span class="line">    indices[<span class="number">14</span>] = <span class="number">10</span>;</span><br><span class="line">    indices[<span class="number">15</span>] = <span class="number">8</span>;</span><br><span class="line">    indices[<span class="number">16</span>] = <span class="number">10</span>;</span><br><span class="line">    indices[<span class="number">17</span>] = <span class="number">11</span>;</span><br><span class="line">    <span class="comment">//right</span></span><br><span class="line">    indices[<span class="number">18</span>] = <span class="number">12</span>;</span><br><span class="line">    indices[<span class="number">19</span>] = <span class="number">13</span>;</span><br><span class="line">    indices[<span class="number">20</span>] = <span class="number">14</span>;</span><br><span class="line">    indices[<span class="number">21</span>] = <span class="number">12</span>;</span><br><span class="line">    indices[<span class="number">22</span>] = <span class="number">14</span>;</span><br><span class="line">    indices[<span class="number">23</span>] = <span class="number">15</span>;</span><br><span class="line">    <span class="comment">//top</span></span><br><span class="line">    indices[<span class="number">24</span>] = <span class="number">16</span>;</span><br><span class="line">    indices[<span class="number">25</span>] = <span class="number">17</span>;</span><br><span class="line">    indices[<span class="number">26</span>] = <span class="number">18</span>;</span><br><span class="line">    indices[<span class="number">27</span>] = <span class="number">16</span>;</span><br><span class="line">    indices[<span class="number">28</span>] = <span class="number">18</span>;</span><br><span class="line">    indices[<span class="number">29</span>] = <span class="number">19</span>;</span><br><span class="line">    <span class="comment">//down</span></span><br><span class="line">    indices[<span class="number">30</span>] = <span class="number">20</span>;</span><br><span class="line">    indices[<span class="number">31</span>] = <span class="number">21</span>;</span><br><span class="line">    indices[<span class="number">32</span>] = <span class="number">22</span>;</span><br><span class="line">    indices[<span class="number">33</span>] = <span class="number">20</span>;</span><br><span class="line">    indices[<span class="number">34</span>] = <span class="number">22</span>;</span><br><span class="line">    indices[<span class="number">35</span>] = <span class="number">23</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;结果我们就得到一个如下面所示的奇怪的立方体：</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.7/blog/SoftRenderer-3DPipeline/cube0_s.png" alt="cube0_s"></p><p>&emsp;&emsp;下面是动图gif（<strong>再重复一遍，模糊不是渲染的锅</strong>）：</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.7/blog/SoftRenderer-3DPipeline/cube0.gif" alt="cube0"></p><p>&emsp;&emsp;这的确有点像是一个立方体，但又有种说不出的奇怪。立方体的某些本应被遮挡住的面被绘制在了这个立方体其他面之上。出现这样结果的原因是因为我们的软渲染器是对一个一个三角形进行绘制的，而且计算像素时时直接覆盖而不管这个像素是否已经有其他值了，所以一个像素的值完全取决于最后赋予它的$RGBA$。除非渲染管线自动按照从远到近的顺序（这类算法有画家算法、空间分割BSP树算法）绘制三角形，否则直接覆盖的方法获取不了正确的像素值。正确渲染结果应该是像素的$RGBA$值为最靠近视点的片元值，一种常用的技术是借助第三维信息——深度来对每个相同位置的不同片元做深度的比较，并且取深度较低的那一个。</p><h2 id="2、深度测试"><a href="#2、深度测试" class="headerlink" title="2、深度测试"></a>2、深度测试</h2><p>&emsp;&emsp;为了获取正确的三维渲染结果，我们采用一种<strong>深度缓冲</strong>的技术。深度缓冲存储深度信息，它的分辨率应该与颜色缓冲一致，深度值存储在每个片段里面（作为片段的<strong>z</strong>值），当片段想要输出它的颜色时，我们将它的深度值和z缓冲进行比较，如果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖。这个过程称为<strong>深度测试</strong>。在OpenGL和DirectX这些渲染API中，深度缓冲会自动执行而无需用户操作。在我们的软渲染器中，我们自己实现一个这样的深度测试，算法原理很简单，但是效果非常不错！</p><p>&emsp;&emsp;深度缓冲通常和颜色缓冲一起，作为帧缓冲的附件，我们在帧缓冲类中增加深度缓冲相关的变量、方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrameBuffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ......</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; m_depthBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearColorAndDepthBuffer</span><span class="params">(<span class="keyword">const</span> Vector4D &amp;color)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getDepth</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;y)</span><span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawDepth</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;y, <span class="keyword">const</span> <span class="keyword">double</span> &amp;value)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FrameBuffer::clearColorAndDepthBuffer(<span class="keyword">const</span> Vector4D &amp;color)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// fill the color buffer and depth buffer.</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> red = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.x);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> green = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.y);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> blue = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.z);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> alpha = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.w);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> row = <span class="number">0</span>;row &lt; m_height;++ row)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> col = <span class="number">0</span>;col &lt; m_width;++ col)</span><br><span class="line">        &#123;</span><br><span class="line">            m_depthBuffer[row*m_width+col] = <span class="number">1.0f</span>;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> FrameBuffer::getDepth(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;y) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= m_width || y &lt; <span class="number">0</span> || y &gt;= m_height)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">return</span> m_depthBuffer[y*m_width+x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FrameBuffer::drawDepth(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;y, <span class="keyword">const</span> <span class="keyword">double</span> &amp;value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= m_width || y &lt; <span class="number">0</span> || y &gt;= m_height)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> index = y*m_width + x;</span><br><span class="line">    m_depthBuffer[index] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后我们对于每一个片元，我们获取深度缓冲中相应的数值并进行比较。在这之前，我们还要简单回顾一下在透视投影矩阵中深度值的非线性映射，在前面的<a href="https://yangwc.com/2019/05/01/SoftRenderer-Math/" target="_blank" rel="noopener">数学篇</a>中我们知道透视投影矩阵有如下形式：</p><script type="math/tex; mode=display">M_{projection}=\left(\begin{matrix}\frac{1}{aspect*tan(fovy/2)}&0&0&0\\0&\frac{1}{tan(fovy/2)}&0&0\\0&0&-\frac{f+n}{f-n}&-\frac{2fn}{f-n}\\0&0&-1&0\end{matrix}\right)</script><p>&emsp;&emsp;因而视图空间中的深度信息$z_e$和标准化设备空间中的深度信息$z_n$关系为：</p><script type="math/tex; mode=display">z_n=(-\frac{f+n}{f-n}z_e-\frac{2fn}{f-n})/{-z_e}=\frac{2fn}{z_e(f-n)}+\frac{f+n}{f-n} \tag {1}</script><p>&emsp;&emsp;可以看到$z_e$d到$z_n$是一种从$[-f, -n]$到$[-1,1]$的非线性映射。当$z_e$比较小的时候，公式$(1)$有很高的精度；当$z_e$比较大的时候，公式$(1)$应为取值精度降低。这个关系可以直观地从下图的函数曲线看出来：</p><p><img src="http://www.songho.ca/opengl/files/gl_projectionmatrix07.png" alt="Comparison of depth precision"></p><p>&emsp;&emsp;可以看到，深度值很大一部分是由很小的z值所决定的，这给了近处的物体很大的深度精度。$z_n$取值为$[-1,1]$，我们最后将其简单地映射到$[0,1]$，这一步我放在透视除法后。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Pipeline::perspectiveDivision(VertexOut &amp;target)</span><br><span class="line">&#123;</span><br><span class="line">    target.posH.x /= target.posH.w;</span><br><span class="line">    target.posH.y /= target.posH.w;</span><br><span class="line">    target.posH.z /= target.posH.w;</span><br><span class="line">    target.posH.w = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="comment">// map from [-1,1] to [0,1]</span></span><br><span class="line">    target.posH.z = (target.posH.z+<span class="number">1.0f</span>) * <span class="number">0.5f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在写入深度缓冲之前应该要清除上一帧的深度缓冲，全部置$1.0f$即可，我把这一步和清除颜色缓冲放一起了，即前面的帧缓冲类的$clearColorAndDepthBuffer$方法。在光栅化步骤，获取每个片元的屏幕位置，查找深度缓并比较，若小于当前深度缓冲中获取的值，则通过深度测试并写入深度缓冲。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Pipeline::scanLinePerRow(<span class="keyword">const</span> VertexOut &amp;left, <span class="keyword">const</span> VertexOut &amp;right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// scan the line from left to right.</span></span><br><span class="line">    VertexOut current;</span><br><span class="line">    <span class="keyword">int</span> length = right.posH.x - left.posH.x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= length;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// linear interpolation</span></span><br><span class="line">        <span class="keyword">double</span> weight = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i)/length;</span><br><span class="line">        current = lerp(left, right, weight);</span><br><span class="line">        current.posH.x = left.posH.x + i;</span><br><span class="line">        current.posH.y = left.posH.y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// depth testing.</span></span><br><span class="line">        <span class="keyword">double</span> depth = m_backBuffer-&gt;getDepth(current.posH.x, current.posH.y);</span><br><span class="line">        <span class="keyword">if</span>(current.posH.z &gt; depth)</span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">// fail to pass the depth testing.</span></span><br><span class="line">        m_backBuffer-&gt;drawDepth(current.posH.x,current.posH.y,current.posH.z);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> w = <span class="number">1.0</span>/current.oneDivZ;</span><br><span class="line">        current.posTrans *= w;</span><br><span class="line">        current.color *= w;</span><br><span class="line">        current.texcoord *= w;</span><br><span class="line">        <span class="comment">// fragment shader</span></span><br><span class="line">        m_backBuffer-&gt;drawPixel(current.posH.x, current.posH.y,</span><br><span class="line">                                m_shader-&gt;fragmentShader(current));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后就可以根据深度信息正确地渲染出三维的立体感了。</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.7/blog/SoftRenderer-3DPipeline/cube1_s.png" alt="cube1_s"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.7/blog/SoftRenderer-3DPipeline/cube1.gif" alt="cube1"></p><h2 id="3、裁剪、剔除优化"><a href="#3、裁剪、剔除优化" class="headerlink" title="3、裁剪、剔除优化"></a>3、裁剪、剔除优化</h2><p>&emsp;&emsp;目前目前我们已经构建出三维的渲染管线，但是这还不够，因为图形渲染计算量很大，通常我们需要做一些优化。常见的嵌入在渲染管线中的优化算法有几何裁剪、背面剔除。</p><h3 id="几何裁剪"><a href="#几何裁剪" class="headerlink" title="几何裁剪"></a>几何裁剪</h3><p>&emsp;&emsp;注意在坐标系统的变换过程中，位于视锥体内的顶点坐标各分量都会被映射到$[-1,1]$的范围内，超出视锥体的顶点则被映射到超出$[-1,1]$的范围。我们在这个基础上的做相关的裁剪，注意在透视除法之前各分量实际上是处于$[-w,w]$的范围内的，这里的$w$就是该顶点坐标的第四个分量$w$。针对线框模式渲染和填充模式渲染，我们有两种不同的裁剪算法。</p><h4 id="Cohen-Sutherland线条裁剪算法"><a href="#Cohen-Sutherland线条裁剪算法" class="headerlink" title="Cohen-Sutherland线条裁剪算法"></a>Cohen-Sutherland线条裁剪算法</h4><p>&emsp;&emsp;一条线段在视口内的情况有如下所示的四种。其中端点完全在视口内和一端在视口内而另一端是在视口外的情况很好判断，但是线段完全在视口外就没那么简单了。可以看到线段$GH$的端点都在视口外部，但是线段的一部分却在视口的内部，这是如果直接根据两个端点是否在视口外做剔除的话会导致在边缘部分的线段直接消失，得到错误的结果。一种暴力的解法就是计算线段与视口窗口的交点，但是这并不高效。</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.7/blog/SoftRenderer-3DPipeline/line0.png" alt="line0"></p><p>&emsp;&emsp;Cohen-Sutherland提出了一种基于编码的判断算法，通过简单的移位、与或逻辑运算就可以判断一条线段处于哪种情况。对于每一个端点$(x,y)$，我们定义一个outcode——$b_0b_1b_2b_3$，视口所处的范围用$x_{min}$、$x_{max}$、$y_{min}$、$y_{max}$表示。每个端点$(x,y)$的outcode的计算方法如下：</p><p>&emsp;&emsp;$b_0 = 1\ if \ y &gt; y_{max},\  0\  otherwiose$</p><p>&emsp;&emsp;$b_1 = 1\ if \ y &lt; y_{min},\  0\  otherwiose$</p><p>&emsp;&emsp;$b_2 = 1\ if \ x &gt; x_{min},\  0\  otherwiose$</p><p>&emsp;&emsp;$b_3 = 1\ if \ x &lt; x_{max},\  0\  otherwiose$</p><p>&emsp;&emsp;可以看出outcode将屏幕空间分成了$9$个部分：</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.7/blog/SoftRenderer-3DPipeline/outcode.png" alt="outcode"></p><p>&emsp;&emsp;观察上面的$9$个区域，对于两个端点outcode1和outcode2，做如下的判断策略，其中的$OR$和$AND$是逻辑按位运算：</p><p>&emsp;&emsp;若$(outcode1\ OR\ outcode2)==0$，那么线段就完全在视口内部；</p><p>&emsp;&emsp;若$(outcode1\ AND\ outcode2)!=0$，那么线段就完全在视口外部；</p><p>&emsp;&emsp;若$(outcode1\ AND\ outcode2)==0$，那么线段就<strong>可能</strong>部分在视口外部，部分在内部，还需要做进一步的判断（这里我进一步判断用了包围盒，因为比较常见和简单，就不过多描述了）。</p><p>&emsp;&emsp;这里我的实现就是只裁剪掉肯定完全在视口外部的线段，若还想裁剪掉部分外视口外部的线段则需要进一步的求交运算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Pipeline::lineCliping(<span class="keyword">const</span> VertexOut &amp;from, <span class="keyword">const</span> VertexOut &amp;to)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// return whether the line is totally outside or not.</span></span><br><span class="line">    <span class="keyword">float</span> vMin = -from.posH.w, vMax = from.posH.w;</span><br><span class="line">    <span class="keyword">float</span> x1 = from.posH.x, y1 = from.posH.y;</span><br><span class="line">    <span class="keyword">float</span> x2 = to.posH.x, y2 = to.posH.y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> outcode1 = <span class="number">0</span>, outcode2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// outcode1 calculation.</span></span><br><span class="line">    tmp = (y1&gt;vMax)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    tmp &lt;&lt;= <span class="number">3</span>;</span><br><span class="line">    outcode1 |= tmp;</span><br><span class="line">    tmp = (y1&lt;vMin)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    tmp &lt;&lt;= <span class="number">2</span>;</span><br><span class="line">    outcode1 |= tmp;</span><br><span class="line">    tmp = (x1&gt;vMax)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    tmp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    outcode1 |= tmp;</span><br><span class="line">    tmp = (x1&lt;vMin)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    outcode1 |= tmp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// outcode2 calculation.</span></span><br><span class="line">    tmp = (y2&gt;vMax)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    tmp &lt;&lt;= <span class="number">3</span>;</span><br><span class="line">    outcode2 |= tmp;</span><br><span class="line">    tmp = (y2&lt;vMin)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    tmp &lt;&lt;= <span class="number">2</span>;</span><br><span class="line">    outcode2 |= tmp;</span><br><span class="line">    tmp = (x2&gt;vMax)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    tmp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    outcode2 |= tmp;</span><br><span class="line">    tmp = (x2&lt;vMin)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    outcode2 |= tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((outcode1 &amp; outcode2) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bounding box judge.</span></span><br><span class="line">    Vector2D minPoint,maxPoint;</span><br><span class="line">    minPoint.x = min(from.posH.x, to.posH.x);</span><br><span class="line">    minPoint.y = min(from.posH.y, to.posH.y);</span><br><span class="line">    maxPoint.x = max(from.posH.x, to.posH.x);</span><br><span class="line">    maxPoint.y = max(from.posH.y, to.posH.y);</span><br><span class="line">    <span class="keyword">if</span>(minPoint.x &gt; vMax || maxPoint.x &lt; vMin || minPoint.y &gt; vMax || maxPoint.y &lt; vMin)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三角形裁剪"><a href="#三角形裁剪" class="headerlink" title="三角形裁剪"></a>三角形裁剪</h4><p>&emsp;&emsp;判断三角形是否完全在外面也不能直接根据三个端点是否完全在视口外部来判断（我看有些软渲染的博主就用了这个错误的策略），因为还要考略以下的特殊情况。</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.7/blog/SoftRenderer-3DPipeline/clip0.png" alt="clip0"></p><p>&emsp;&emsp;为此，我直接计算三角形的轴向包围盒，然后这个包围盒判断三角形是否完全是视口外部。更进一步的裁剪是将部分在视口内部的三角形做求交，然后重新分割成完全在视口内部的三角形，这里我没有做进一步的裁剪。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Pipeline::triangleCliping(<span class="keyword">const</span> VertexOut &amp;v1, <span class="keyword">const</span> VertexOut &amp;v2, <span class="keyword">const</span> VertexOut &amp;v3)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// true:not clip;</span></span><br><span class="line">    <span class="comment">// false: clip.</span></span><br><span class="line">    <span class="keyword">float</span> vMin = <span class="number">-1.0</span>;</span><br><span class="line">    <span class="keyword">float</span> vMax = +<span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if the triangle is too far to see it, just return false.</span></span><br><span class="line">    <span class="keyword">if</span>(v1.posH.z &gt; vMax &amp;&amp; v2.posH.z &gt; vMax &amp;&amp; v3.posH.z &gt; vMax)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if the triangle is behind the camera, just return false.</span></span><br><span class="line">    <span class="keyword">if</span>(v1.posH.z &lt; vMin &amp;&amp; v2.posH.z &lt; vMin &amp;&amp; v3.posH.z &lt; vMin)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate the bounding box and check if clip or not.</span></span><br><span class="line">    Vector2D minPoint,maxPoint;</span><br><span class="line">    minPoint.x = min(v1.posH.x, min(v2.posH.x, v3.posH.x));</span><br><span class="line">    minPoint.y = min(v1.posH.y, min(v2.posH.y, v3.posH.y));</span><br><span class="line">    maxPoint.x = max(v1.posH.x, max(v2.posH.x, v3.posH.x));</span><br><span class="line">    maxPoint.y = max(v1.posH.y, max(v2.posH.y, v3.posH.y));</span><br><span class="line">    <span class="keyword">if</span>(minPoint.x &gt; vMax || maxPoint.x &lt; vMin || minPoint.y &gt; vMax || maxPoint.y &lt; vMin)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后我们把几何裁剪放到渲染管线中，几何裁剪一般是在顶点着色器之后、光栅化之前。这里我把它放到了透视除法和视口变换之前。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Pipeline::drawIndex(RenderMode mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// renderer pipeline.</span></span><br><span class="line">    <span class="keyword">bool</span> line1 = <span class="literal">false</span>, line2 = <span class="literal">false</span>, line3 = <span class="literal">false</span>;</span><br><span class="line">    m_mode = mode;</span><br><span class="line">    <span class="keyword">if</span>(m_indices.empty())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m_indices.size();i += <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//! assembly to triangle primitive.</span></span><br><span class="line">        Vertex p1,p2,p3;</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! vertex shader stage.</span></span><br><span class="line">        VertexOut v1,v2,v3;</span><br><span class="line">        &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! perspective division.</span></span><br><span class="line">        &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//! geometry cliping.</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m_config.m_geometryCliping)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(m_config.m_polygonMode == PolygonMode::Wire)</span><br><span class="line">                &#123;</span><br><span class="line">                    line1 = lineCliping(v1,v2);</span><br><span class="line">                    line2 = lineCliping(v2,v3);</span><br><span class="line">                    line3 = lineCliping(v3,v1);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(m_config.m_polygonMode == PolygonMode::Fill &amp;&amp; !triangleCliping(v1,v2,v3))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! view port transformation.</span></span><br><span class="line">        &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! rasterization and fragment shader stage.</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mode == RenderMode::wire)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!line1)</span><br><span class="line">                    bresenhamLineRasterization(v1,v2);</span><br><span class="line">                <span class="keyword">if</span>(!line2)</span><br><span class="line">                    bresenhamLineRasterization(v2,v3);</span><br><span class="line">                <span class="keyword">if</span>(!line3)</span><br><span class="line">                    bresenhamLineRasterization(v3,v1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mode == RenderMode::fill)</span><br><span class="line">            &#123;</span><br><span class="line">                edgeWalkingFillRasterization(v1,v2,v3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="背面剔除"><a href="#背面剔除" class="headerlink" title="背面剔除"></a>背面剔除</h3><p>&emsp;&emsp;背面剔除网上的这篇<a href="https://blog.csdn.net/wangdingqiaoit/article/details/52267314" target="_blank" rel="noopener">博客</a>已经讲得非常详细了，原理也很简单，我就不过多描述。我们定义顶点逆时针的环绕顺序正面，然后通过三角形的三个顶点计算出法线，将顶点与视线做点乘并判断其符号即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Pipeline::backFaceCulling(<span class="keyword">const</span> Vector4D &amp;v1, <span class="keyword">const</span> Vector4D &amp;v2, <span class="keyword">const</span> Vector4D &amp;v3)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// back face culling.</span></span><br><span class="line">    <span class="keyword">if</span>(m_mode == RenderMode::wire)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    Vector4D tmp1 = v2 - v1;</span><br><span class="line">    Vector4D tmp2 = v3 - v1;</span><br><span class="line">    <span class="function">Vector3D <span class="title">edge1</span><span class="params">(tmp1.x, tmp1.y, tmp1.z)</span></span>;</span><br><span class="line">    <span class="function">Vector3D <span class="title">edge2</span><span class="params">(tmp2.x, tmp2.y, tmp2.z)</span></span>;</span><br><span class="line">    <span class="function">Vector3D <span class="title">viewRay</span><span class="params">(m_eyePos.x - v1.x,</span></span></span><br><span class="line"><span class="function"><span class="params">                     m_eyePos.y - v1.y,</span></span></span><br><span class="line"><span class="function"><span class="params">                     m_eyePos.z - v1.z)</span></span>;</span><br><span class="line">    Vector3D normal = edge1.crossProduct(edge2);</span><br><span class="line">    <span class="keyword">return</span> normal.dotProduct(viewRay) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后背面剔除应该放在渲染管线的顶点着色器输出之后，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Pipeline::drawIndex(RenderMode mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// renderer pipeline.</span></span><br><span class="line">    <span class="keyword">bool</span> line1 = <span class="literal">false</span>, line2 = <span class="literal">false</span>, line3 = <span class="literal">false</span>;</span><br><span class="line">    m_mode = mode;</span><br><span class="line">    <span class="keyword">if</span>(m_indices.empty())<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m_indices.size();i += <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//! assembly to triangle primitive.</span></span><br><span class="line">        Vertex p1,p2,p3;</span><br><span class="line">        &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! vertex shader stage.</span></span><br><span class="line">        VertexOut v1,v2,v3;</span><br><span class="line">        &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! back face culling.</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!backFaceCulling(v1.posTrans, v2.posTrans, v3.posTrans))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! geometry cliping.</span></span><br><span class="line">        &#123;</span><br><span class="line">......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! perspective division.</span></span><br><span class="line">        &#123;</span><br><span class="line">......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! view port transformation.</span></span><br><span class="line">        &#123;</span><br><span class="line">......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//! rasterization and fragment shader stage.</span></span><br><span class="line">        &#123;</span><br><span class="line">......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、透视纹理映射、采样"><a href="#二、透视纹理映射、采样" class="headerlink" title="二、透视纹理映射、采样"></a>二、透视纹理映射、采样</h1><p>&emsp;&emsp;纹理映射是丰富三维物体细节的一个非常重要的方法，简单、廉价、快速，只需计算好的纹理坐标、纹理图片即可实现物体的多姿多彩。通常纹理图片的制作（除了过程式纹理的生成）由设计师完成，无需我们关心。而纹理坐标的计算则需要非常注意，送入渲染管线的纹理坐标只是逐顶点的纹理坐标，在光栅化阶段我们还要将纹理坐标做插值操作，最后根据插值后得到的纹理坐标对纹理图片采样获取片元的像素值。</p><h2 id="1、透视纹理映射"><a href="#1、透视纹理映射" class="headerlink" title="1、透视纹理映射"></a>1、透视纹理映射</h2><p>&emsp;&emsp;在光栅化阶段，我们是根据屏幕空间的$x$值和$y$值做线性插值操作获取片元的位置，而片元的纹理坐标如果也这么获得的话（这种方法叫做仿射纹理映射），将会导致严重的纹理扭曲。这是因为仿射纹理映射是基于这样的一个假设：物体空间的纹理坐标与屏幕空间的顶点坐标呈线性管线。</p><p>&emsp;&emsp;我们知道纹理坐标是定义在物体的顶点上面的，当我们根据屏幕空间的顶点坐标插值时，就默认了纹理坐标的变化与屏幕空间顶点坐标的变化是呈线性、均匀的关系的。但是问题在于：默认的屏幕空间上的线性关系，还原到世界空间中，就不是那么回事了，如下图所示。这张图是相机空间的一张俯视图。我们把一个多边形通过透视投影的方式变换到了投影平面上，图中红色的是世界空间中的多边形，蓝色的是变换到投影平面之后的多边形。可以看到，在投影平面上的蓝色线段被表示成若干个相等的单位步长线段。与此同时，投影面上单位步长的线段所对应的投影之前的红色线段的长度却不是相等的，从左到右所对应的长度依次递增。我们的纹理坐标是定义在红色的多边形上的，因此纹理坐标的增量应该是和红色线段的步长对应的。我们的线性插值却把纹理坐标增量根据蓝色线段的步长平均分配了。</p><p><img src="http://hi.csdn.net/attachment/201005/8/0_127332838023gG.gif" alt="img"></p><p>&emsp;&emsp;这就导致了仿射纹理映射的错误的结果，如下图所示，仿射纹理映射产生了严重的扭曲。</p><p><img src="http://hi.csdn.net/attachment/201005/8/0_127332853505pQ.gif" alt="img"></p><p>&emsp;&emsp;而如果你不信，大可以试一试，然后你就会得到和我下面这张图一样奇怪的结果。</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.7/blog/SoftRenderer-3DPipeline/affine.png" alt="affine"></p><p>&emsp;&emsp;那么如何进行矫正了？网上的这篇<a href="https://blog.csdn.net/popy007/article/details/5570803" target="_blank" rel="noopener">博客</a>已经非常详细地说明了相关的矫正方法，<strong>核心思想就是想办法让纹理坐标变得与屏幕空间的坐标线性相关，这一点可以看成纹理坐标的透视投影（与世界空间的顶点坐标投影到屏幕空间，从而通过插值获得其他的屏幕空间坐标进行光栅化有异曲同工之妙）</strong>。</p><p>&emsp;&emsp;纹理透视投影的详细过程请看这篇<a href="https://blog.csdn.net/popy007/article/details/5570803" target="_blank" rel="noopener">博客</a>，其中借助的关系就是纹理坐标与世界空间顶点坐标是相关的（我们定义纹理坐标就是逐个顶点定义的），然后世界空间顶点坐标（为了便于讨论，这里世界空间就是视图空间）通过投影矩阵变成屏幕空间顶点坐标。在世界空间中，顶点的$x$和$y$值与$z$值呈线性关系（因为我们定义基本图元是三角形，在三角形平面上，必然是线性的，否则就是非线性的曲面了），即存在$A$和$B$有：</p><script type="math/tex; mode=display">x_e = Az_e+B\\y_e = Az_e+B \tag {2}</script><p>&emsp;&emsp;$(x_e,y_e,z_e)$是视图空间的顶点坐标，即$(x’,y’)$是投影到近平面的顶点坐标。根据透视投影矩阵可知（其实就是相似三角形），$(x’,y’)$与视图空间的顶点坐标关系如下：</p><script type="math/tex; mode=display">\begin{cases}x'=-N\frac {x_e}{z_e}\ \to x_e= -\frac{x'z_e}{N} \\y'=-N\frac {y_e}{z_e}\ \to y_e= -\frac{y'z_e}{N} \end{cases} \tag {3}</script><p>&emsp;&emsp;将公式$(3)$带入公式$(2)$，则有：</p><script type="math/tex; mode=display">\begin{cases}x'=-N\frac{B}{z_e}-AN\\y'=-N\frac{B}{z_e}-AN\end{cases} \tag {4}</script><p>&emsp;&emsp;其中的$A$、$B$、$N$都是常量，把$\frac 1{z_e}$看成一个整体，则通过透视投影矩阵的变换之后$x’$、$y’$均与$\frac{1}{z_e}$成线性关系，这也就是透视投影的效果是近大远小的根本原因。然后注意到在三维空间中，纹理坐标$(s,t)$和$(x_e,y_e)$成线性关系。即有（这里只是定性分析，$A$和$B$具体多少我们不用关心）：</p><script type="math/tex; mode=display">\begin{cases}x_e=As+B\\x_e=At+B\\y_e=As+B\\y_e=At+B\end{cases} \tag {5}</script><p>&emsp;&emsp;把公式$(5)$带入$(3)$则有（以公式$(5)$的第一个为例，其他类似）：</p><script type="math/tex; mode=display">As+B=-\frac{x'z_e}{N}\ \to\ A\frac{s}{z_e}+B\frac{1}{z_e}=-\frac{x'}{N} \tag {6}</script><p>&emsp;&emsp;<strong>公式$(6)$彻底说明了纹理坐标与屏幕空间的顶点坐标的关系！$s$和$x’$并不是简单的线性关系，因为还出现了$\frac{1}{z_e}$这个项，如果$\frac{1}{z_e}$具体值已知，那么$\frac{s}{z_e}$就与 $x’$成线性关系！那么我们在线性插值之前给纹理坐标$s$乘上一个$\frac{1}{z_e}$，就可以根据屏幕空间的顶点坐标做线性插值了，然后对插值得到的纹理坐标$s’$乘上$z_e$就能还原出正确的纹理坐标！！！！</strong></p><p>&emsp;&emsp;说了这么多都是在捋清函数关系，实现其实很简单的，上面已经说的很清楚了。我们在$VertexOut$中定义的变量$oneDivZ$就用于的透射投影映射的。除开纹理坐标，其他的世界空间坐标、顶点颜色、法线都是定义在世界空间的坐标顶点上的，为了得到正确的插值，都需要做与纹理坐标一样的处理。乘上$\frac{1}{z_e}$这一步我放在了顶点着色器的最后一步，只要放在插值之前都行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VertexOut SimpleShader::vertexShader(<span class="keyword">const</span> Vertex &amp;in)</span><br><span class="line">&#123;</span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">    <span class="comment">// oneDivZ to correct mapping.</span></span><br><span class="line">    result.oneDivZ = <span class="number">1.0</span> / result.posH.w;</span><br><span class="line">    result.posTrans *= result.oneDivZ;</span><br><span class="line">    result.texcoord *= result.oneDivZ;</span><br><span class="line">    result.color *= result.oneDivZ;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后再光栅化插值之后各自乘上相应的倒数即可恢复出正确的插值结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Pipeline::scanLinePerRow(<span class="keyword">const</span> VertexOut &amp;left, <span class="keyword">const</span> VertexOut &amp;right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// scan the line from left to right.</span></span><br><span class="line">    VertexOut current;</span><br><span class="line">    <span class="keyword">int</span> length = right.posH.x - left.posH.x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= length;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// linear interpolation</span></span><br><span class="line">        <span class="keyword">double</span> weight = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i)/length;</span><br><span class="line">        current = lerp(left, right, weight);</span><br><span class="line">        current.posH.x = left.posH.x + i;</span><br><span class="line">        current.posH.y = left.posH.y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// depth testing.</span></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// restore.</span></span><br><span class="line">        <span class="keyword">double</span> w = <span class="number">1.0</span>/current.oneDivZ;</span><br><span class="line">        current.posTrans *= w;</span><br><span class="line">        current.color *= w;</span><br><span class="line">        current.texcoord *= w;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// fragment shader</span></span><br><span class="line">        m_backBuffer-&gt;drawPixel(current.posH.x, current.posH.y,</span><br><span class="line">                                m_shader-&gt;fragmentShader(current));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、双线性纹理采样"><a href="#2、双线性纹理采样" class="headerlink" title="2、双线性纹理采样"></a>2、双线性纹理采样</h2><p>&emsp;&emsp;定义的纹理坐标都是$[0.0f,1.0f]$的浮点数，为了采样纹理我们需要把它乘上纹理的宽高转成整数的下标取访问纹理的像素矩阵。乘上纹理的宽高之后我们得到的依然应该是一个浮点数，为了获取像素下标，一个简单的方法就是向下取整（这种采样方法对应于OpenGL的GL_NEAREST纹理过滤方法）。如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> trueU = texcoord.x * (m_width - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">double</span> trueV = texcoord.y * (m_height - <span class="number">1</span>);</span><br><span class="line">x = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(trueU);</span><br><span class="line">y = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(trueV);</span><br><span class="line"><span class="keyword">int</span> index[<span class="number">0</span>] = (x * m_width + y) * m_channel;</span><br><span class="line">Vector3D texels;</span><br><span class="line"><span class="comment">// INV_SCALE is 1.0/255</span></span><br><span class="line">texels.x = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index + <span class="number">0</span>]) * INV_SCALE;</span><br><span class="line">texels.y = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index + <span class="number">1</span>]) * INV_SCALE;</span><br><span class="line">texels.z = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index + <span class="number">2</span>]) * INV_SCALE;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;问题就出在这里，这样直接抛弃小数点以后的值导致采样出的相邻纹理并不连续，那么用float采样行吗？答案是：不行！这边实现的采样函数是从数组取值，纹理坐标转为数组下标，数组下标不能用float只能用int，那么就没办法了吗？并不是，可以对周围纹理进行采样然后按照各自比例进行混合，这样能够提高显示效果。混合的方法就是双线性插值。所谓双线性插值，就是先后线性插值一次，共两次。即横向线性插值一次，然后根据前面一次的插值结果竖向插值一次，二维纹理是有两个维度，所以做双线性插值。</p><p>&emsp;&emsp;除了采样之外，还有一个纹理坐标溢出的问题。纹理坐标超过的$[0,1]$通常由两种处理方式，一种是$clamp$，超过$[0,1]$的地方的像素都获取边上的像素，这样效果就是拉伸。一种是$repeat$，故名思议，即重复平铺。这里我实现的是重复平铺，在计算真正的纹理下标之前做相应的判断和处理即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Texture2D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_width;</span><br><span class="line">    <span class="keyword">int</span> m_height;</span><br><span class="line">    <span class="keyword">int</span> m_channel;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *m_pixelBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Texture2D():m_width(<span class="number">0</span>), m_height(<span class="number">0</span>), m_channel(<span class="number">0</span>), m_pixelBuffer(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    ~Texture2D();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">loadImage</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;path)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Vector4D <span class="title">sample</span><span class="params">(<span class="keyword">const</span> Vector2D &amp;texcoord)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Texture2D::loadImage(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;path)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_pixelBuffer)<span class="keyword">delete</span> m_pixelBuffer;</span><br><span class="line">    m_pixelBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">    m_pixelBuffer = stbi_load(path.c_str(), &amp;m_width, &amp;m_height, &amp;m_channel, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(m_pixelBuffer == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"Failed to load image-&gt;"</span> &lt;&lt; QString::fromStdString(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  m_pixelBuffer != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector4D Texture2D::sample(<span class="keyword">const</span> Vector2D &amp;texcoord) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// just for rgb and rgba format.</span></span><br><span class="line">    <span class="function">Vector4D <span class="title">result</span><span class="params">(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(m_pixelBuffer == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// for bilinear interpolation.</span></span><br><span class="line">    <span class="keyword">double</span> factorU = <span class="number">0</span>, factorV = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate the corresponding coordinate.</span></span><br><span class="line">    <span class="keyword">if</span>(texcoord.x &gt;= <span class="number">0.0f</span> &amp;&amp; texcoord.x &lt;= <span class="number">1.0f</span> &amp;&amp; texcoord.y &gt;= <span class="number">0.0f</span> &amp;&amp; texcoord.y &lt;= <span class="number">1.0f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> trueU = texcoord.x * (m_width - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">double</span> trueV = texcoord.y * (m_height - <span class="number">1</span>);</span><br><span class="line">        x = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(trueU);</span><br><span class="line">        y = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(trueV);</span><br><span class="line">        factorU = trueU - x;</span><br><span class="line">        factorV = trueV - y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// repeating way.</span></span><br><span class="line">        <span class="keyword">float</span> u = texcoord.x,v = texcoord.y;</span><br><span class="line">        <span class="keyword">if</span>(texcoord.x &gt; <span class="number">1.0f</span>)</span><br><span class="line">            u = texcoord.x - <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(texcoord.x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(texcoord.x &lt; <span class="number">0.0f</span>)</span><br><span class="line">            u = <span class="number">1.0f</span> - (<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(texcoord.x) - texcoord.x);</span><br><span class="line">        <span class="keyword">if</span>(texcoord.y &gt; <span class="number">1.0f</span>)</span><br><span class="line">            v = texcoord.y - <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(texcoord.y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(texcoord.y &lt; <span class="number">0.0f</span>)</span><br><span class="line">            v = <span class="number">1.0f</span> - (<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(texcoord.y) - texcoord.y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> trueU = u * (m_width - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">double</span> trueV = v * (m_height - <span class="number">1</span>);</span><br><span class="line">        x = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(trueU);</span><br><span class="line">        y = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(trueV);</span><br><span class="line">        factorU = trueU - x;</span><br><span class="line">        factorV = trueV - y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// texel fetching.</span></span><br><span class="line">    Vector3D texels[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> index[<span class="number">4</span>];</span><br><span class="line">    index[<span class="number">0</span>] = (x * m_width + y) * m_channel;</span><br><span class="line">    index[<span class="number">1</span>] = (x * m_width + y + <span class="number">1</span>) * m_channel;</span><br><span class="line">    index[<span class="number">2</span>] = ((x + <span class="number">1</span>) * m_width + y + <span class="number">1</span>) * m_channel;</span><br><span class="line">    index[<span class="number">3</span>] = ((x + <span class="number">1</span>) * m_width + y) * m_channel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// left bottom</span></span><br><span class="line">    texels[<span class="number">0</span>].x = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index[<span class="number">0</span>] + <span class="number">0</span>]) * INV_SCALE;</span><br><span class="line">    texels[<span class="number">0</span>].y = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index[<span class="number">0</span>] + <span class="number">1</span>]) * INV_SCALE;</span><br><span class="line">    texels[<span class="number">0</span>].z = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index[<span class="number">0</span>] + <span class="number">2</span>]) * INV_SCALE;</span><br><span class="line">    <span class="comment">//return texels[0];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// left top</span></span><br><span class="line">    texels[<span class="number">1</span>].x = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index[<span class="number">1</span>] + <span class="number">0</span>]) * INV_SCALE;</span><br><span class="line">    texels[<span class="number">1</span>].y = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index[<span class="number">1</span>] + <span class="number">1</span>]) * INV_SCALE;</span><br><span class="line">    texels[<span class="number">1</span>].z = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index[<span class="number">1</span>] + <span class="number">2</span>]) * INV_SCALE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// right top</span></span><br><span class="line">    texels[<span class="number">2</span>].x = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index[<span class="number">2</span>] + <span class="number">0</span>]) * INV_SCALE;</span><br><span class="line">    texels[<span class="number">2</span>].y = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index[<span class="number">2</span>] + <span class="number">1</span>]) * INV_SCALE;</span><br><span class="line">    texels[<span class="number">2</span>].z = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index[<span class="number">2</span>] + <span class="number">2</span>]) * INV_SCALE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// right bottom</span></span><br><span class="line">    texels[<span class="number">3</span>].x = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index[<span class="number">3</span>] + <span class="number">0</span>]) * INV_SCALE;</span><br><span class="line">    texels[<span class="number">3</span>].y = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index[<span class="number">3</span>] + <span class="number">1</span>]) * INV_SCALE;</span><br><span class="line">    texels[<span class="number">3</span>].z = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index[<span class="number">3</span>] + <span class="number">2</span>]) * INV_SCALE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bilinear interpolation.</span></span><br><span class="line">    <span class="comment">// horizational</span></span><br><span class="line">    texels[<span class="number">0</span>] = texels[<span class="number">0</span>] * (<span class="number">1.0</span> - factorU) + texels[<span class="number">3</span>] * factorU;</span><br><span class="line">    texels[<span class="number">1</span>] = texels[<span class="number">1</span>] * (<span class="number">1.0</span> - factorU) + texels[<span class="number">2</span>] * factorU;</span><br><span class="line">    <span class="comment">//vertical</span></span><br><span class="line">    result = texels[<span class="number">0</span>] * (<span class="number">1.0</span> - factorV) + texels[<span class="number">1</span>] *factorV;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;加载图片我的用的stb_image，一个简单使用的头文件，因为加载图片不是我们的重点，所以就不造这方面的轮子了。</p><h1 id="三、程序结果"><a href="#三、程序结果" class="headerlink" title="三、程序结果"></a>三、程序结果</h1><p>&emsp;&emsp;目前的帧率还不错hhh。</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.7/blog/SoftRenderer-3DPipeline/ret1.png" alt="ret1"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.7/blog/SoftRenderer-3DPipeline/ret2.png" alt="ret2"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.7/blog/SoftRenderer-3DPipeline/ret3.gif" alt="ret3"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>$[1]$ <a href="https://learnopengl.com/Advanced-OpenGL/Depth-testing" target="_blank" rel="noopener">https://learnopengl.com/Advanced-OpenGL/Depth-testing</a></p><p>$[2]$ <a href="https://www.cnblogs.com/pbblog/p/3484193.html" target="_blank" rel="noopener">https://www.cnblogs.com/pbblog/p/3484193.html</a></p><p>$[3]$ <a href="https://learnopengl.com/Getting-started/Coordinate-Systems" target="_blank" rel="noopener">https://learnopengl.com/Getting-started/Coordinate-Systems</a></p><p>$[4]$ <a href="http://www.songho.ca/opengl/gl_projectionmatrix.html" target="_blank" rel="noopener">http://www.songho.ca/opengl/gl_projectionmatrix.html</a></p><p>$[5]$ <a href="https://blog.csdn.net/popy007/article/details/5570803" target="_blank" rel="noopener">https://blog.csdn.net/popy007/article/details/5570803</a></p><p>$[6]$ <a href="https://learnopengl-cn.github.io/01 Getting started/06 Textures/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Soft Renderer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> Soft Renderer </tag>
            
            <tag> 3D pipeline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软渲染器Soft Renderer：光栅化篇</title>
      <link href="/2019/05/01/SoftRenderer-Rasterization/"/>
      <url>/2019/05/01/SoftRenderer-Rasterization/</url>
      
        <content type="html"><![CDATA[<p>本章开始构建基于Qt平台软渲染器的初步框架，当然Qt相关的内容并不是软渲染器的重点，我只是借助Qt平台将渲染出来的像素矩阵用Qt的控件显示出来。光栅化是当今图形学渲染的一种方式，与之对应的是光线追踪渲染方式，本章我根据自己的理解着重讲述线框光栅化的Bresenham画线算法以及三角形填充光栅化的Edge-Walking算法。<strong>注意：初学者慎入</strong>。本篇相关的完整代码请看<a href="https://github.com/ZeusYang/Soft-Renderer/releases/tag/1.0.0" target="_blank" rel="noopener">这里</a>。</p><p><div align="left"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.6/blog/SoftRenderer-Rasterization/3.png"></div></p><a id="more"></a><ul><li><p>渲染管线框架</p></li><li><p>光栅化算法</p></li></ul><h1 id="一、渲染管线框架"><a href="#一、渲染管线框架" class="headerlink" title="一、渲染管线框架"></a>一、渲染管线框架</h1><p>&emsp;&emsp;渲染管线的搭建主要包含像素显示、网格数据封装、渲染循环、帧率fps计算、帧缓冲、着色器、渲染逻辑、光栅化等等，其中光栅化作为重点对象抽出来放在后面。当然我们不会一下子就完成渲染管线的基本功能，我们现在是要搭建一个框架，大部分的内容不用写入或者仅仅是做简单的处理，这样后面完善软渲染器的时候只需在相应的位置填写相应的代码逻辑即可。本章目标就是搭建一个渲染管线，用光栅化算法画三角形。当然，如果仅仅是画一个三角形，当然不用这么麻烦，但是我的目标是实现三维的软渲染器，深入理解三维渲染的整个流程，得从基础一步一步慢慢来。</p><h2 id="1、像素显示的画布"><a href="#1、像素显示的画布" class="headerlink" title="1、像素显示的画布"></a>1、像素显示的画布</h2><p>&emsp;&emsp;渲染器最终渲染出来的是一个像素矩阵，我们要把这个像素矩阵显示出来。显示的方法有很多，因人而异，这里我采用自己最熟悉的$Qt$来实现。显示的窗口继承一个普通的$QWidget$父类，然后我们通过重写它的$paintEvent$函数，将渲染出来的像素画到$QWidget$上。但是采用$QPainter$直接画上去的方式效率非常低，我通过查询资料得知，若想要快速地绘制给定的像素矩阵，可以利用$QImage$来实现。话不多说，上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Window</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~Window();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *)</span> override</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Window *ui;</span><br><span class="line">    QImage *canvas;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接收到一帧的像素之后，在重绘事件里面利用$QImage$绘制给定的像素数组（记得调用$update$触发重绘事件）。<strong>由于篇幅原因，我不会讲太多细节方面的东西，代码也不会全部放出来，那样没意义。想看完整源代码的朋友直接去本人的github上看。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Window::receiveFrame(<span class="keyword">unsigned</span> <span class="keyword">char</span> *image)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(canvas) <span class="keyword">delete</span> canvas;</span><br><span class="line">    canvas = <span class="keyword">new</span> QImage(image, width(), height(), QImage::Format_RGBA8888);</span><br><span class="line">    update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Window::paintEvent(QPaintEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(canvas)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        painter.drawImage(<span class="number">0</span>, <span class="number">0</span>, *canvas);</span><br><span class="line">    &#125;</span><br><span class="line">    QWidget::paintEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、帧缓冲类"><a href="#2、帧缓冲类" class="headerlink" title="2、帧缓冲类"></a>2、帧缓冲类</h2><p>&emsp;&emsp;帧缓冲通常包含基本的颜色缓冲附件、深度缓冲附件等，这里我们暂且只实现颜色缓冲附件（四通道，格式为$RGBA$，各占一个字节），深度缓冲附件后面再加上。渲染管线最终的渲染结果是写入帧缓冲的，我们采用一个一维的单字节数组作为帧缓冲的颜色缓冲。帧缓冲的最基本的功能就是清楚缓冲区、写入像素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrameBuffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_width, m_height, m_channel;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; m_colorBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FrameBuffer(<span class="keyword">int</span> width, <span class="keyword">int</span> height);</span><br><span class="line">    ~FrameBuffer() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_width;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_height;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">getColorBuffer</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_colorBuffer.data();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearColorBuffer</span><span class="params">(<span class="keyword">const</span> Vector4D &amp;color)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawPixel</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x, <span class="keyword">unsigned</span> <span class="keyword">int</span> y, <span class="keyword">const</span> Vector4D &amp;color)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FrameBuffer::FrameBuffer(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span><br><span class="line">    :m_channel(<span class="number">4</span>), m_width(width), m_height(height)</span><br><span class="line">&#123;</span><br><span class="line">    m_colorBuffer.resize(m_width*m_height*m_channel, <span class="number">255</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FrameBuffer::clearColorBuffer(<span class="keyword">const</span> Vector4D &amp;color)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// fill the color buffer.</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> red = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.x);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> green = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.y);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> blue = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.z);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> alpha = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.w);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>;row &lt; m_height;++ row)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>;col &lt; m_width;++ col)</span><br><span class="line">        &#123;</span><br><span class="line">            m_colorBuffer[row*m_width*m_channel+col*m_channel + <span class="number">0</span>] = red;</span><br><span class="line">            m_colorBuffer[row*m_width*m_channel+col*m_channel + <span class="number">1</span>] = green;</span><br><span class="line">            m_colorBuffer[row*m_width*m_channel+col*m_channel + <span class="number">2</span>] = blue;</span><br><span class="line">            m_colorBuffer[row*m_width*m_channel+col*m_channel + <span class="number">3</span>] = alpha;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FrameBuffer::drawPixel(<span class="keyword">unsigned</span> <span class="keyword">int</span> x, <span class="keyword">unsigned</span> <span class="keyword">int</span> y, <span class="keyword">const</span> Vector4D &amp;color)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= m_width || y &lt; <span class="number">0</span> || y &gt;= m_height)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> red = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.x);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> green = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.y);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> blue = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.z);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> alpha = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.w);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> index = y*m_width*m_channel + x*m_channel;</span><br><span class="line">    m_colorBuffer[index + <span class="number">0</span>] = red;</span><br><span class="line">    m_colorBuffer[index + <span class="number">1</span>] = green;</span><br><span class="line">    m_colorBuffer[index + <span class="number">2</span>] = blue;</span><br><span class="line">    m_colorBuffer[index + <span class="number">3</span>] = alpha;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、网格顶点数据"><a href="#3、网格顶点数据" class="headerlink" title="3、网格顶点数据"></a>3、网格顶点数据</h2><p>&emsp;&emsp;三维的渲染程序中的顶点数据通常包含顶点位置、顶点颜色、纹理坐标、顶点法线，然后在此基础上利用一组给定顺序的顶点数据表示一个网格，渲染时网格的数据将被送入管线进行处理。为此，有必要对顶点数据做一定的封装。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector4D position;</span><br><span class="line">    Vector4D color;</span><br><span class="line">    Vector2D texcoord;</span><br><span class="line">    Vector3D normal;</span><br><span class="line"></span><br><span class="line">    Vertex() = <span class="keyword">default</span>;</span><br><span class="line">    Vertex(Vector4D _pos, Vector4D _color, Vector2D _tex, Vector3D _normal)</span><br><span class="line">        :position(_pos),color(_color),texcoord(_tex),normal(_normal) &#123;&#125;</span><br><span class="line">    Vertex(<span class="keyword">const</span> Vertex &amp;rhs)</span><br><span class="line">  :position(rhs.position),color(rhs.color),texcoord(rhs.texcoord),normal(rhs.normal)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;顶点数据经过顶点着色器的处理之后，会被送到下一个渲染管线的阶段处理。顶点着色器的顶点数据输出与输入有些差异，为此我们也定义一个类表示为顶点着色器的输出，这对于构建渲染管线尤为重要。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VertexOut</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector4D posTrans;  <span class="comment">//世界变换后的坐标</span></span><br><span class="line">    Vector4D posH;      <span class="comment">//投影变换后的坐标</span></span><br><span class="line">    Vector2D texcoord;  <span class="comment">//纹理坐标</span></span><br><span class="line">    Vector3D normal;<span class="comment">//法线</span></span><br><span class="line">    Vector4D color;    <span class="comment">//颜色</span></span><br><span class="line">    <span class="keyword">double</span> oneDivZ;     <span class="comment">//1/z用于深度测试</span></span><br><span class="line"></span><br><span class="line">    VertexOut() = <span class="keyword">default</span>;</span><br><span class="line">    VertexOut(Vector4D _posT, Vector4D _posH, Vector2D _tex, </span><br><span class="line">              Vector3D _normal, Vector4D _color, <span class="keyword">double</span> _oneDivZ)</span><br><span class="line">        :posTrans(_posT),posH(_posH),texcoord(_tex),</span><br><span class="line">          normal(_normal),color(_color),oneDivZ(_oneDivZ) &#123;&#125;</span><br><span class="line">    VertexOut(<span class="keyword">const</span> VertexOut&amp; rhs) :posTrans(rhs.posTrans), </span><br><span class="line">        posH(rhs.posH), texcoord(rhs.texcoord), normal(rhs.normal),</span><br><span class="line">        color(rhs.color), oneDivZ(rhs.oneDivZ) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后就是关于网格的表示，为了节省空间（特别是对于很大的模型），我们直接采用索引来组织网格。若想详细了解OpenGL的顶点索引概念请看<a href="https://www.jianshu.com/p/c1a494288d73" target="_blank" rel="noopener">这里</a>。一个网格有两个数组，分别是$Vertex$数组和$Index$数组。下面的代码中，有一个$asTriangle$方法，这是一个三角形网格，调用这个方法之后网格存储的就是一个三角形，用于后面的光栅化调试，光栅化的基本单元就是三角形。<strong>通常情况，所有的网格模型都可以用一定数量的三角形构成，因而我们实现的软渲染器的基本图元就是三角形。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mesh</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Vertex&gt; vertices;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; indices;</span><br><span class="line"></span><br><span class="line">    Mesh() = <span class="keyword">default</span>;</span><br><span class="line">    ~Mesh() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    Mesh(<span class="keyword">const</span> Mesh&amp; mesh)</span><br><span class="line">        :vertices(mesh.vertices), indices(mesh.indices)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    Mesh&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Mesh&amp; mesh)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (&amp;mesh == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        vertices = mesh.vertices;</span><br><span class="line">        indices = mesh.indices;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setVertices</span><span class="params">(Vertex* _vs, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vertices.resize(count);</span><br><span class="line">        <span class="keyword">new</span>(&amp;vertices[<span class="number">0</span>])<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Vertex&gt;(_vs, _vs + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setIndices</span><span class="params">(<span class="keyword">int</span>* _es, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        indices.resize(count);</span><br><span class="line">        <span class="keyword">new</span>(&amp;indices)<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(_es, _es + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">asBox</span><span class="params">(<span class="keyword">double</span> width, <span class="keyword">double</span> height, <span class="keyword">double</span> depth)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">asTriangle</span><span class="params">(<span class="keyword">const</span> Vector3D p1, <span class="keyword">const</span> Vector3D p2, <span class="keyword">const</span> Vector3D p3)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Mesh::asTriangle(Vector3D p1, Vector3D p2, Vector3D p3)</span><br><span class="line">&#123;</span><br><span class="line">    vertices.resize(<span class="number">3</span>);</span><br><span class="line">    indices.resize(<span class="number">3</span>);</span><br><span class="line">    vertices[<span class="number">0</span>].position = p1;</span><br><span class="line">    vertices[<span class="number">0</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">0</span>].color = Vector4D(<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">0</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">1</span>].position = p2;</span><br><span class="line">    vertices[<span class="number">1</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">1</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">1</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">2</span>].position = p3;</span><br><span class="line">    vertices[<span class="number">2</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">2</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">2</span>].texcoord = Vector2D(<span class="number">0.5f</span>, <span class="number">1.f</span>);</span><br><span class="line">    indices[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    indices[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    indices[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、简单的着色器"><a href="#4、简单的着色器" class="headerlink" title="4、简单的着色器"></a>4、简单的着色器</h2><p>&emsp;&emsp;着色器方面时软渲染中较为高级的内容，目前我们只是搭建一个框架，因而着色器不需要什么复杂的操作，只需简单地传递数据就行了。博主实现的软渲染器只包含必不可少的顶点着色器和片元着色器，目前的顶点着色器将顶点原封不动地输出，片元着色器也是如此，这样我们后面要实现光照效果的时候直接在着色器里写上就行了。为了更加有条理，我们设计一个着色器的虚类，这样实现不同效果的着色器时我们直接继承这个虚类即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseShader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BaseShader() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~BaseShader() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> VertexOut <span class="title">vertexShader</span><span class="params">(<span class="keyword">const</span> Vertex &amp;in)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector4D <span class="title">fragmentShader</span><span class="params">(<span class="keyword">const</span> VertexOut &amp;in)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setModelMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;world)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setViewMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;view)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setProjectMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;project)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleShader</span> :</span> <span class="keyword">public</span> BaseShader</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SimpleShader() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~SimpleShader() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> VertexOut <span class="title">vertexShader</span><span class="params">(<span class="keyword">const</span> Vertex &amp;in)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector4D <span class="title">fragmentShader</span><span class="params">(<span class="keyword">const</span> VertexOut &amp;in)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setModelMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;world)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setViewMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;view)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setProjectMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;project)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">VertexOut SimpleShader::vertexShader(<span class="keyword">const</span> Vertex &amp;in)</span><br><span class="line">&#123;</span><br><span class="line">    VertexOut result;</span><br><span class="line">    result.posTrans = in.position;</span><br><span class="line">    result.posH = in.position;</span><br><span class="line">    result.color = in.color;</span><br><span class="line">    result.normal = in.normal;</span><br><span class="line">    result.oneDivZ = <span class="number">1.0</span>;</span><br><span class="line">    result.texcoord = in.texcoord;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector4D SimpleShader::fragmentShader(<span class="keyword">const</span> VertexOut &amp;in)</span><br><span class="line">&#123;</span><br><span class="line">    Vector4D litColor;</span><br><span class="line">    litColor = in.color;</span><br><span class="line">    <span class="keyword">return</span> litColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SimpleShader::setModelMatrix(<span class="keyword">const</span> Matrix4x4 &amp;world)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SimpleShader::setViewMatrix(<span class="keyword">const</span> Matrix4x4 &amp;view)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SimpleShader::setProjectMatrix(<span class="keyword">const</span> Matrix4x4 &amp;project)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到$SimpleShader$仅仅是将顶点数据直接输出，不进行任何处理。</p><h2 id="5、搭建基本的渲染管线"><a href="#5、搭建基本的渲染管线" class="headerlink" title="5、搭建基本的渲染管线"></a>5、搭建基本的渲染管线</h2><p>&emsp;&emsp;目前我们已经有了一些渲染管线的基本组件，现在就需要把这些组件串起来。首先是渲染循环的问题，$Qt$有它自己的事件循环，而且主线程的事件循环要尽量避免大量的运算（否则UI控件会陷入未响应），因此将渲染循环放到子线程里是一个不错的渲染，这样也可以避免我们的软渲染逻辑与$Qt$的接口耦合得太高。</p><h3 id="渲染线程"><a href="#渲染线程" class="headerlink" title="渲染线程"></a>渲染线程</h3><p>&emsp;&emsp;$Qt$提供了$QThread$类构建线程，我采用的方式为：渲染循环类继承$QObject$，然后调用$moveToThread$番方法挂到子线程上运行，最后将线程的启动信号与$loop$渲染循环关联即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderLoop</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">RenderLoop</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~RenderLoop();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stopIt</span><span class="params">()</span> </span>&#123;stoped = <span class="literal">true</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFpsZero</span><span class="params">()</span></span>&#123;fps = <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getFps</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> fps;&#125;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">frameOut</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *image)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> stoped;</span><br><span class="line">    <span class="keyword">int</span> fps;</span><br><span class="line">    <span class="keyword">int</span> width, height, channel;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RenderLoop::RenderLoop(<span class="keyword">int</span> w, <span class="keyword">int</span> h, QObject *parent)</span><br><span class="line">    : QObject(parent), width(w), height(h), channel(<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">    fps = <span class="number">0</span>;</span><br><span class="line">    stoped = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RenderLoop::~RenderLoop()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RenderLoop::loop()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pipeline initialization</span></span><br><span class="line">......</span><br><span class="line">    <span class="comment">// fps counting.</span></span><br><span class="line">    fps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stoped)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// render logic</span></span><br><span class="line">        ......</span><br><span class="line">        ++ fps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后在主窗口中创建$RenderLoop$对象，挂到$QThread$上启动。此外还有一点要注意的是在子线程中最好不用使用$QTimer$类，因此我在主窗口中创建$QTimer$类，设定为每秒触发，触发时主线程读取子线程的$fps$，这样就达到了显示帧率的目的了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">在Window类声明处：</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QTimer *timer;</span><br><span class="line">    QThread *loopThread;</span><br><span class="line">    RenderLoop *loop;</span><br><span class="line"></span><br><span class="line">在Window类构造函数处：</span><br><span class="line">    loop = <span class="keyword">new</span> RenderLoop(width(), height(), <span class="literal">nullptr</span>);</span><br><span class="line">    loopThread = <span class="keyword">new</span> QThread(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fps counting.</span></span><br><span class="line">    timer = <span class="keyword">new</span> QTimer();</span><br><span class="line">    connect(timer,&amp;QTimer::timeout,<span class="keyword">this</span>,&amp;Window::fpsTimeOut);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// render thread.</span></span><br><span class="line">    loop-&gt;moveToThread(loopThread);</span><br><span class="line">    connect(loopThread,&amp;QThread::finished,loop, &amp;RenderLoop::deleteLater);</span><br><span class="line">    connect(loopThread,&amp;QThread::started,loop,&amp;RenderLoop::loop);</span><br><span class="line">    connect(loop,&amp;RenderLoop::frameOut,<span class="keyword">this</span>,&amp;Window::receiveFrame);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// begin the thread.</span></span><br><span class="line">    loopThread-&gt;start();</span><br><span class="line">    timer-&gt;start(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">Window的其他函数：</span><br><span class="line"><span class="keyword">void</span> Window::fpsTimeOut()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fps = loop-&gt;getFps();</span><br><span class="line">    loop-&gt;setFpsZero();</span><br><span class="line">    <span class="keyword">this</span>-&gt;setWindowTitle(QString(<span class="string">" fps: %1"</span>).arg(fps));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h3><p>&emsp;&emsp;回顾一下$OpenGL$的渲染流程（这里只考虑一般的情况，即不包含几何着色器、细分着色器等），首先外部处理网格，将网格顶点数据和网格顶点索引送入渲染管线，设置基本图元（如三角形）、渲染方式（如线框模式）。渲染管线的第一阶段为顶点着色器阶段（在这之前还有个缓冲清理阶段），顶点着色器对网格数据逐顶点处理（包含坐标空间变换、投影变换等等），随之输出。然后渲染管线对输出的顶点数据进行裁剪，送入光栅化部件，计算几何图元覆盖的像素点，其中进行了大量的线性插值操作。接着片元着色器获取光栅化后的像素，对每个像素做颜色计算等，然后输出颜色数据、深度数据，最后根据这些缓冲数据做深度测试。</p><p>&emsp;&emsp;所以一个最基本的渲染管线应该有如下几个步骤：</p><p>&emsp;&emsp;初始化（如缓冲区创建）$\to$输入顶点缓冲、索引缓冲$\to$清除缓冲区$\to$设置着色器、渲染方式$\to$绘制$\to$交换双缓冲$\to$输出。根据这些步骤，创建$Pipeline$类如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pipeline</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_width, m_height;              <span class="comment">// width and height of viewport.</span></span><br><span class="line">    BaseShader *m_shader;               <span class="comment">// shaders including vertex shader and fragment shader.</span></span><br><span class="line">    FrameBuffer *m_frontBuffer;</span><br><span class="line">    FrameBuffer *m_backBuffer;</span><br><span class="line">    Matrix4x4 viewPortMatrix;           <span class="comment">// viewport transformation matrix.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Vertex&gt; m_vertices;     <span class="comment">// vertex buffer.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; m_indices;<span class="comment">// index buffer.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Pipeline(<span class="keyword">int</span> width, <span class="keyword">int</span> height);</span><br><span class="line">    ~Pipeline();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearBuffer</span><span class="params">(<span class="keyword">const</span> Vector4D &amp;color, <span class="keyword">bool</span> depth = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setVertexBuffer</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Vertex&gt; &amp;vertices)</span></span>&#123;m_vertices = vertices;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setIndexBuffer</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; &amp;indices)</span></span>&#123;m_indices = indices;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setShaderMode</span><span class="params">(ShadingMode mode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawIndex</span><span class="params">(RenderMode mode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swapBuffer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">output</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_frontBuffer-&gt;getColorBuffer();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Pipeline::Pipeline(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span><br><span class="line">    :m_width(width),m_height(height)</span><br><span class="line">    ,m_shader(<span class="literal">nullptr</span>),m_frontBuffer(<span class="literal">nullptr</span>)</span><br><span class="line">    ,m_backBuffer(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pipeline::~Pipeline()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_shader)<span class="keyword">delete</span> m_shader;</span><br><span class="line">    <span class="keyword">if</span>(m_frontBuffer)<span class="keyword">delete</span> m_frontBuffer;</span><br><span class="line">    <span class="keyword">if</span>(m_backBuffer)<span class="keyword">delete</span> m_backBuffer;</span><br><span class="line">    m_shader = <span class="literal">nullptr</span>;</span><br><span class="line">    m_frontBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">    m_backBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Pipeline::initialize()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_frontBuffer)</span><br><span class="line">        <span class="keyword">delete</span> m_frontBuffer;</span><br><span class="line">    <span class="keyword">if</span>(m_backBuffer)</span><br><span class="line">        <span class="keyword">delete</span> m_backBuffer;</span><br><span class="line">    <span class="keyword">if</span>(m_shader)</span><br><span class="line">        <span class="keyword">delete</span> m_shader;</span><br><span class="line">    viewPortMatrix.setViewPort(<span class="number">0</span>,<span class="number">0</span>,m_width,m_height);</span><br><span class="line">    m_frontBuffer = <span class="keyword">new</span> FrameBuffer(m_width, m_height);</span><br><span class="line">    m_backBuffer = <span class="keyword">new</span> FrameBuffer(m_width, m_height);</span><br><span class="line">    m_shader = <span class="keyword">new</span> SimpleShader();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Pipeline::drawIndex(RenderMode mode)</span><br><span class="line">&#123;</span><br><span class="line"> 输入顶点着色器;</span><br><span class="line">    光栅化;</span><br><span class="line">    输入片元着色器;</span><br><span class="line">    写入缓冲区;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Pipeline::clearBuffer(<span class="keyword">const</span> Vector4D &amp;color, <span class="keyword">bool</span> depth)</span><br><span class="line">&#123;</span><br><span class="line">    (<span class="keyword">void</span>)depth;</span><br><span class="line">    m_backBuffer-&gt;clearColorBuffer(color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Pipeline::setShaderMode(ShadingMode mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_shader)<span class="keyword">delete</span> m_shader;</span><br><span class="line">    <span class="keyword">if</span>(mode == ShadingMode::simple)</span><br><span class="line">        m_shader = <span class="keyword">new</span> SimpleShader();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mode == ShadingMode::phong)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Pipeline::swapBuffer()</span><br><span class="line">&#123;</span><br><span class="line">    FrameBuffer *tmp = m_frontBuffer;</span><br><span class="line">    m_frontBuffer = m_backBuffer;</span><br><span class="line">    m_backBuffer = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意到我创建了帧缓冲，分别是$m_frontBuffer$和$m_backBuffer$，前者存储着当前显示的像素，后者缓冲区用于写入像素。这就是著名的双缓冲原理，可以避免画面的闪烁、撕裂等现象。除此之外，还有一个值得特别说明的就是视口变换矩阵$viewPortMatrix$，这个一般很少见到，因为被内嵌在了渲染管线里面了。经过投影变换、透视除法操作之后，顶点数据都在标准化设备空间中，即$x$轴、$y$轴、$z$轴取值范围为$[-1,1]$。但是屏幕的像素坐标范围并非如此，通常屏幕的$x$轴坐标范围为$[0,width]$，$y$轴坐标范围为$[0,height]$，屏幕像素坐标原点在左上角，$x$轴正向朝右，$y$轴正向朝下，所以我们还要把标准化设备坐标顶点数据变换到屏幕的坐标范围中，这就是<strong>视口变换</strong>（$z$轴一般保持不变）。视口变换矩阵的构造并没有难度，因为这仅仅是简单的线性映射，因此不再赘述。视口变换矩阵如下所示：</p><script type="math/tex; mode=display">viewPortMatrix=\left[\begin{matrix}\frac{w}{2}&0&0&s_x+\frac{w}{2}\\0&-\frac{h}{2}&0&s_y+\frac{h}{2}\\0&0&1&0\\0&0&0&1\end{matrix}\right] \tag {1}</script><p>&emsp;&emsp;其中$(s_x,s_y)$是视口左上角的坐标，$(w,h)$为屏幕的宽度和高度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4x4::setViewPort(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span><br><span class="line">&#123;</span><br><span class="line">    loadIdentity();</span><br><span class="line">    entries[<span class="number">0</span>]  =  <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(width)/<span class="number">2.0f</span>;</span><br><span class="line">    entries[<span class="number">5</span>]  = -<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(height)/<span class="number">2.0f</span>;</span><br><span class="line">    entries[<span class="number">12</span>] =  <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(left)+<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(width)/<span class="number">2.0f</span>;</span><br><span class="line">    entries[<span class="number">13</span>] =  <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(top)+<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(height)/<span class="number">2.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;$Pipeline$还有个非常重要的函数$drawIndex$，它是渲染管线的核心部分，涉及到了图元装配、顶点着色器调度、光栅化、片元着色器调度、写入帧缓冲这几个重要的步骤。我们实现的软渲染器几何图元默认为三角形，所以图元装配就是每三个顶点装成一个图元。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Pipeline::drawIndex(RenderMode mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_indices.empty())<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m_indices.size()/<span class="number">3</span>;++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//! vertices assembly to triangle primitive</span></span><br><span class="line">        Vertex p1,p2,p3;</span><br><span class="line">        &#123;</span><br><span class="line">            p1 = m_vertices[<span class="number">3</span>*i+<span class="number">0</span>];</span><br><span class="line">            p2 = m_vertices[<span class="number">3</span>*i+<span class="number">1</span>];</span><br><span class="line">            p3 = m_vertices[<span class="number">3</span>*i+<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! vertex shader stage.</span></span><br><span class="line">        VertexOut v1,v2,v3;</span><br><span class="line">        &#123;</span><br><span class="line">            v1 = m_shader-&gt;vertexShader(p1);</span><br><span class="line">            v2 = m_shader-&gt;vertexShader(p2);</span><br><span class="line">            v3 = m_shader-&gt;vertexShader(p3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! rasterization and fragment shader stage.</span></span><br><span class="line">        &#123;</span><br><span class="line">            v1.posH = viewPortMatrix * v1.posH;</span><br><span class="line">            v2.posH = viewPortMatrix * v2.posH;</span><br><span class="line">            v3.posH = viewPortMatrix * v3.posH;</span><br><span class="line">            <span class="keyword">if</span>(mode == RenderMode::wire)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// bresenham rasterization</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mode == RenderMode::fill)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// edge walking rasterization</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;有了以上的$Pipeline$函数，我们的渲染循环逻辑的一般形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!stoped)</span><br><span class="line">&#123;</span><br><span class="line">    pipeline-&gt;clearBuffer(Vector4D(<span class="number">0.502f</span>,<span class="number">0.698f</span>,<span class="number">0.800f</span>,<span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line">    pipeline-&gt;drawIndex(RenderMode::fill);</span><br><span class="line"></span><br><span class="line">    pipeline-&gt;swapBuffer();</span><br><span class="line"></span><br><span class="line">    <span class="function">emit <span class="title">frameOut</span><span class="params">(pipeline-&gt;output())</span></span>;</span><br><span class="line">    ++ fps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、光栅化算法"><a href="#二、光栅化算法" class="headerlink" title="二、光栅化算法"></a>二、光栅化算法</h1><p>&emsp;&emsp;顶点着色器处理的还是一个个离散的几何顶点，在顶点着色器之后我们还需要进行光栅化操作，将几何覆盖的屏幕像素计算出来，送入片元着色器计算每个点的像素数据。光栅化一般有两种模式：一种是线框模式，即只描绘几何的边；二是填充模式，即将几何的面片全部填充完。Bresenham算法是经典的描线算法，它采用迭代的形式将所需的算术操作降低到最少。除此之外还有DDA描线算法，效率上不如Bresenham算法，所以我没有实现。</p><h2 id="1、Bresenham描线算法"><a href="#1、Bresenham描线算法" class="headerlink" title="1、Bresenham描线算法"></a>1、Bresenham描线算法</h2><p>&emsp;&emsp;我们要描绘的是从$(x_0,y_0)$到$(x_1,y_1)$的一条直线线段。一些数学符号标记如下：</p><script type="math/tex; mode=display">\Delta x= x_1-x_0>0,\ \Delta y=y_1-y_0>0,\ m=\frac{\Delta y}{\Delta x}</script><p>&emsp;&emsp;其中$m$即直线线段的斜率，为了便于讨论，我们假设$|m|\leq 1$，其他情况很容易推广。</p><p>&emsp;&emsp;在如上的情况下，Bresenham算法从$x=x_0$开始，每次将$x$坐标值加一，然后推算相应的$y$坐标值。记第$i$次迭代获得的点为$(x_i,y_i)$。那么第$i+1$次迭代时获取的点就在$(\overline x_i+1,\overline y_i)$和$(\overline x_i+1,\overline y_i+1)$这两个中选取。那如何判断应该选哪个呢？即选择这两个点之一的判断标准是什么？<strong>直观上，我们应该选取距离的直线线段在该$y$轴上的交点最近的点</strong>，如下图1所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.6/blog/SoftRenderer-Rasterization/4.png" alt="1556629627471"></p><center>图1 判别标准</center><p>&emsp;&emsp;直线的一般表达式为$y=mx+B$，$m$为直线的斜率，那么$(x_{i+1},y_{i+1})$表示为如下（注意$y_{i+1}$表示的是直线在$x_{i+1}$上真正的$y$值）：</p><script type="math/tex; mode=display">x_{i+1}=x_i+1\\y_{i+1}=mx_{i+1}+B=m(x_i+1)+B \tag {2}</script><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.6/blog/SoftRenderer-Rasterization/5.png" alt="1556630006821"></p><center>图2 交点到右边的点、右上的点的距离 </center><p>&emsp;&emsp;故$d_{upper}$和$d_{lower}$的取值如下：</p><script type="math/tex; mode=display">d_{upper}=\overline y_i+1-\overline y_{i+1}=\overline y_i+1-m\overline x_{i+1}-B\\d_{lower}=y_{i+1}-\overline y_i=mx_{i+1}+B-\overline y_i \tag {3}</script><p>&emsp;&emsp;显然，如果$d_{lower}-d_{upper}&gt;0$，则应该取右上方的点；如果$d_{lower}-d_{upper}<0$，则应该取右边的点。而$d_{lower}-d_{upper}=0$可任取这两个点。因此，我们的判断标准就是$d_{lower}-d_{upper}>0$的符号。</0$，则应该取右边的点。而$d_{lower}-d_{upper}=0$可任取这两个点。因此，我们的判断标准就是$d_{lower}-d_{upper}></p><script type="math/tex; mode=display">d_{lower}-d_{upper}=m(x_i+1)+B-\overline y_i-(\overline y_i+1-m(x_i+1)-B)\\=2m(x_i+1)-2\overline y_i+2B-1 \tag {4}</script><p>&emsp;&emsp;式$(4)$中的$m$是直线的斜率，因此将式$(4)$作为判断标准需要做非常昂贵的浮点数除法运算。为了消去除法，注意到$m=\frac{\Delta y}{\Delta x}$，两边同时乘上$\Delta x&gt;0$，正负符号不变。</p><script type="math/tex; mode=display">p_i=\Delta x\cdot (d_{lower}-d_{upper})=2\Delta y\cdot(x_i+1)-2\Delta x\cdot \overline y_i+(2B-1)\Delta x\\=2\Delta y\cdot x_i-2\Delta x\cdot\overline y_i+c\\where \ \ c=(2B-1)\Delta x+2\Delta y \tag {5}</script><p>&emsp;&emsp;所以可以用$p_i$的符号作为选取的标准。但是，式$(5)$的计算能够进一步简化，考虑$p_i$和$p_{i+1}$（注意我们根据$p_i$的符号来选取$\overline y_{i+1}$）：</p><script type="math/tex; mode=display">p_{i+1}-p_{i}=(2\Delta y\cdot x_{i+1}-2\Delta x\cdot\overline y_{i+1}+c)-(2\Delta y\cdot x_i-2\Delta x\cdot\overline y_i+c)\\=2\Delta y-2\Delta x(\overline y_{i+1}-\overline y_i) \tag {6}</script><p>&emsp;&emsp;若$p_i\leq 0$，那么选择右边的点，此时$\overline y_{i+1}=\overline y_i$，那么有：</p><script type="math/tex; mode=display">p_{i+1}=p_i+2\Delta y \tag {7}</script><p>&emsp;&emsp;若$p_i&gt;0$，那么选择右上角的点，此时$\overline y_{i+1}=\overline y_i+1$，那么有：</p><script type="math/tex; mode=display">p_{i+1}=p_i+2\Delta y-2\Delta x \tag {8}</script><p>&emsp;&emsp;所以我们可以根据$p_i$的符号快速计算出$p_{i+1}$的符号，如此迭代下去：</p><hr><p><strong>Bresenham Algorithm:</strong></p><hr><p>$draw (x_0, y_0);$</p><p>Calculate $\Delta x$,$\Delta y$,$2\Delta y$,$2\Delta y-2\Delta x$,$p_0=2\Delta y-\Delta x$;</p><p>for $x$ from $x_0$ to $x_1$:</p><p>&emsp;&emsp;if $p_i\leq 0$ </p><p>&emsp;&emsp;&emsp;&emsp;draw $(x_{i+1},\overline y_{i+1})=(x_i+1,\overline y_i)$ ;</p><p>&emsp;&emsp;&emsp;&emsp;compute $p_{i+1}=p_i+2\Delta y$;</p><p>&emsp;&emsp;if $p_i &gt; 0$ </p><p>&emsp;&emsp;&emsp;&emsp;draw $(x_{i+1},\overline y_{i+1})=(x_i+1,\overline y_i+1)$ ;</p><p>&emsp;&emsp;&emsp;&emsp;compute $p_{i+1}=p_i+2\Delta y-2\Delta x$;</p><p>&emsp;&emsp;$x += 1;$</p><hr><p>&emsp;&emsp;上面我们讨论的都是$|m|<1$的情况，那$|m|>1$的情况呢？其实这是对称的，这时把$x$看成$y$，把$y$看成$x$即可。另外，当$\Delta x &lt;0$时，我们的$x$不是递增$1$，而是递减$1$，具体实现如下：</1$的情况，那$|m|></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Pipeline::bresenhamLineRasterization(<span class="keyword">const</span> VertexOut &amp;from, <span class="keyword">const</span> VertexOut &amp;to)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> dx = to.posH.x - from.posH.x;</span><br><span class="line">    <span class="keyword">int</span> dy = to.posH.y - from.posH.y;</span><br><span class="line">    <span class="keyword">int</span> stepX = <span class="number">1</span>, stepY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// judge the sign</span></span><br><span class="line">    <span class="keyword">if</span>(dx &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        stepX = <span class="number">-1</span>;</span><br><span class="line">        dx = -dx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dy &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        stepY = <span class="number">-1</span>;</span><br><span class="line">        dy = -dy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> d2x = <span class="number">2</span>*dx, d2y = <span class="number">2</span>*dy;</span><br><span class="line">    <span class="keyword">int</span> d2y_minus_d2x = d2y - d2x;</span><br><span class="line">    <span class="keyword">int</span> sx = from.posH.x;</span><br><span class="line">    <span class="keyword">int</span> sy = from.posH.y;</span><br><span class="line"></span><br><span class="line">    VertexOut tmp;</span><br><span class="line">    <span class="comment">// slope &lt; 1.</span></span><br><span class="line">    <span class="keyword">if</span>(dy &lt;= dx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = d2y - dx;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= dx;++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// linear interpolation</span></span><br><span class="line">            tmp = lerp(from, to, <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i)/dx);</span><br><span class="line">            <span class="comment">// fragment shader</span></span><br><span class="line">            m_backBuffer-&gt;drawPixel(sx,sy,m_shader-&gt;fragmentShader(tmp));</span><br><span class="line">            sx += stepX;</span><br><span class="line">            <span class="keyword">if</span>(flag &lt;= <span class="number">0</span>)</span><br><span class="line">                flag += d2y;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                sy += stepY;</span><br><span class="line">                flag += d2y_minus_d2x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// slope &gt; 1.</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = d2x - dy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= dy;++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// linear interpolation</span></span><br><span class="line">            tmp = lerp(from, to, <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i)/dy);</span><br><span class="line">            <span class="comment">// fragment shader</span></span><br><span class="line">            m_backBuffer-&gt;drawPixel(sx,sy,m_shader-&gt;fragmentShader(tmp));</span><br><span class="line">            sy += stepY;</span><br><span class="line">            <span class="keyword">if</span>(flag &lt;= <span class="number">0</span>)</span><br><span class="line">                flag += d2x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                sx += stepX;</span><br><span class="line">                flag -= d2y_minus_d2x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、Edge-Walking三角形填充算法"><a href="#2、Edge-Walking三角形填充算法" class="headerlink" title="2、Edge-Walking三角形填充算法"></a>2、Edge-Walking三角形填充算法</h2><p>&emsp;&emsp;三角形光栅化填充对输入给定的三个三角形顶点，计算这个三角区域覆盖的所有像素。三角形填充的光栅化算法有很多种，这里仅实现了Edge-Walking算法，此外还有Edge-Equation算法。关于Edge-Walking算法的前世今生我不再赘述了，这个算法的思路比较简单，但是实现起来比较麻烦一点。</p><p>&emsp;&emsp;话不多少，直接上伪代码（懒得自己写了伪代码了）：</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.6/blog/SoftRenderer-Rasterization/6.png" alt="1556632613625"></p><p>&emsp;&emsp;大致的思想就是从上往下（或从下往上）扫描，获取每对$X_L$、$X_R$，然后在$[X_L,X_R]$范围内从左到右扫描。显然就是双重循环。一般，我们的三角形光栅化对象有如下四种情况：</p><p><img src="http://hi.csdn.net/attachment/201103/8/8458191_1299584107w6lP.png" alt="4ç§ä¸è§å½¢"></p><center>图3 四类三角形 </center><p>&emsp;&emsp;先来看平底三角形的情况，如下图4所示。显然，平底三角形很容易地实现从下往上扫面，竖直方向上仅需考虑左右两条边。<strong>当然这里有个问题，就是如何确定$X_L$和$X_R$？如果直接采用算法伪代码中的利用$dx/dy$迭代获取$X$值，因为$X$值是整数，而$dx/dy$是浮点数，当$dx/dy&lt;1$时，把$dx/dy$加到$X$上面计算机对整数类型坐标自动向下取整，结果相当于没加。（即便是浮点数类型，最终也要取整，因为屏幕空间的像素坐标必须是整数）</strong></p><p><img src="http://hi.csdn.net/attachment/201103/8/8458191_12995845892C4L.png" alt="åæ åå¹³åºä¸è§å½¢"></p><center>图4 平底三角形</center><p>&emsp;&emsp;一种解决方案就是线性插值，算法从下往上扫描时，$y-=1$，我们根据当前的$y$值来获取$x$值：</p><script type="math/tex; mode=display">X_L = (1.0f-\frac{y1-y}{y1-y0})*x1+\frac{y1-y}{y1-y0}*x0 \\X_y = (1.0f-\frac{y2-y}{y2-y0})*x2+\frac{y2-y}{y2-y0}*x0</script><p>&emsp;&emsp;平顶的三角形光栅化亦类似，不再赘述。那么除了平底和平顶的情况之外，我们该如何处理其余的情况？一个技巧就是将其他情况的三角形分割乘一个平底三角形、一个平顶三角形，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.6/blog/SoftRenderer-Rasterization/7.png" alt="1556634037498"></p><center>图5 三角形分割</center><p>&emsp;&emsp;这样我们通过调用平底三角形光栅化方法、平顶三角形光栅化方法即可实现一般情况的三角形光栅化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Pipeline::scanLinePerRow(<span class="keyword">const</span> VertexOut &amp;left, <span class="keyword">const</span> VertexOut &amp;right)</span><br><span class="line">&#123;</span><br><span class="line">    VertexOut current;</span><br><span class="line">    <span class="keyword">int</span> length = right.posH.x - left.posH.x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= length;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// linear interpolation</span></span><br><span class="line">        <span class="keyword">double</span> weight = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i)/length;</span><br><span class="line">        current = lerp(left, right, weight);</span><br><span class="line">        current.posH.x = left.posH.x + i;</span><br><span class="line">        current.posH.y = left.posH.y;</span><br><span class="line">        <span class="comment">// fragment shader</span></span><br><span class="line">        m_backBuffer-&gt;drawPixel(current.posH.x, current.posH.y,</span><br><span class="line">                                m_shader-&gt;fragmentShader(current));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Pipeline::rasterTopTriangle(VertexOut &amp;v1, VertexOut &amp;v2, VertexOut &amp;v3)</span><br><span class="line">&#123;</span><br><span class="line">    VertexOut left = v2;</span><br><span class="line">    VertexOut right = v3;</span><br><span class="line">    VertexOut dest = v1;</span><br><span class="line">    VertexOut tmp, newleft, newright;</span><br><span class="line">    <span class="keyword">if</span>(left.posH.x &gt; right.posH.x)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = left;</span><br><span class="line">        left = right;</span><br><span class="line">        right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dy = left.posH.y - dest.posH.y + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; dy;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> weight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dy != <span class="number">0</span>)</span><br><span class="line">            weight = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i)/dy;</span><br><span class="line">        newleft = lerp(left, dest, weight);</span><br><span class="line">        newright = lerp(right, dest, weight);</span><br><span class="line">        newleft.posH.y = newright.posH.y = left.posH.y - i;</span><br><span class="line">        scanLinePerRow(newleft, newright);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Pipeline::rasterBottomTriangle(VertexOut &amp;v1, VertexOut &amp;v2, VertexOut &amp;v3)</span><br><span class="line">&#123;</span><br><span class="line">    VertexOut left = v1;</span><br><span class="line">    VertexOut right = v2;</span><br><span class="line">    VertexOut dest = v3;</span><br><span class="line">    VertexOut tmp, newleft, newright;</span><br><span class="line">    <span class="keyword">if</span>(left.posH.x &gt; right.posH.x)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = left;</span><br><span class="line">        left = right;</span><br><span class="line">        right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dy = dest.posH.y - left.posH.y + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; dy;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> weight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dy != <span class="number">0</span>)</span><br><span class="line">            weight = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i)/dy;</span><br><span class="line">        newleft = lerp(left, dest, weight);</span><br><span class="line">        newright = lerp(right, dest, weight);</span><br><span class="line">        newleft.posH.y = newright.posH.y = left.posH.y + i;</span><br><span class="line">        scanLinePerRow(newleft, newright);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Pipeline::edgeWalkingFillRasterization(<span class="keyword">const</span> VertexOut &amp;v1, <span class="keyword">const</span> VertexOut &amp;v2, <span class="keyword">const</span> VertexOut &amp;v3)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// split the triangle into two part</span></span><br><span class="line">    VertexOut tmp;</span><br><span class="line">    VertexOut target[<span class="number">3</span>] = &#123;v1, v2,v3&#125;;</span><br><span class="line">    <span class="keyword">if</span>(target[<span class="number">0</span>].posH.y &gt; target[<span class="number">1</span>].posH.y)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = target[<span class="number">0</span>];</span><br><span class="line">        target[<span class="number">0</span>] = target[<span class="number">1</span>];</span><br><span class="line">        target[<span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(target[<span class="number">0</span>].posH.y &gt; target[<span class="number">2</span>].posH.y)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = target[<span class="number">0</span>];</span><br><span class="line">        target[<span class="number">0</span>] = target[<span class="number">2</span>];</span><br><span class="line">        target[<span class="number">2</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(target[<span class="number">1</span>].posH.y &gt; target[<span class="number">2</span>].posH.y)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = target[<span class="number">1</span>];</span><br><span class="line">        target[<span class="number">1</span>] = target[<span class="number">2</span>];</span><br><span class="line">        target[<span class="number">2</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bottom triangle</span></span><br><span class="line">    <span class="keyword">if</span>(equal(target[<span class="number">0</span>].posH.y,target[<span class="number">1</span>].posH.y))</span><br><span class="line">    &#123;</span><br><span class="line">        rasterBottomTriangle(target[<span class="number">0</span>],target[<span class="number">1</span>],target[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// top triangle</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(equal(target[<span class="number">1</span>].posH.y,target[<span class="number">2</span>].posH.y))</span><br><span class="line">    &#123;</span><br><span class="line">        rasterTopTriangle(target[<span class="number">0</span>], target[<span class="number">1</span>], target[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// split it.</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> weight = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(target[<span class="number">1</span>].posH.y-target[<span class="number">0</span>].posH.y)/(target[<span class="number">2</span>].posH.y-target[<span class="number">0</span>].posH.y);</span><br><span class="line">        VertexOut newPoint = lerp(target[<span class="number">0</span>],target[<span class="number">2</span>],weight);</span><br><span class="line">        newPoint.posH.y = target[<span class="number">1</span>].posH.y;</span><br><span class="line">        rasterTopTriangle(target[<span class="number">0</span>], newPoint, target[<span class="number">1</span>]);</span><br><span class="line">        rasterBottomTriangle(newPoint,target[<span class="number">1</span>],target[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、程序结果"><a href="#三、程序结果" class="headerlink" title="三、程序结果"></a>三、程序结果</h1><p>&emsp;&emsp;最终，不借用任何图形接口通过自己实现的光栅化算法画出了三角形：</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.6/blog/SoftRenderer-Rasterization/0.png" alt="0"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.6/blog/SoftRenderer-Rasterization/1.png" alt="1"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.6/blog/SoftRenderer-Rasterization/2.png" alt="2"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.6/blog/SoftRenderer-Rasterization/3.png" alt="3"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>$[1]$ <a href="https://blog.csdn.net/cppyin/article/details/6232453" target="_blank" rel="noopener">https://blog.csdn.net/cppyin/article/details/6232453</a></p><p>$[2]$ <a href="https://blog.csdn.net/y1196645376/article/details/78937614" target="_blank" rel="noopener">https://blog.csdn.net/y1196645376/article/details/78937614</a></p><p>$[3]$ <a href="https://blog.csdn.net/y1196645376/article/details/78907914" target="_blank" rel="noopener">https://blog.csdn.net/y1196645376/article/details/78907914</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Soft Renderer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> Soft Renderer </tag>
            
            <tag> Rasterization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软渲染器Soft Renderer：3D数学篇</title>
      <link href="/2019/05/01/SoftRenderer-Math/"/>
      <url>/2019/05/01/SoftRenderer-Math/</url>
      
        <content type="html"><![CDATA[<p>本章开始博主将手动搭建一个渲染管线，深入理解3D渲染的整个流程。线性代数中的向量和矩阵是计算机图形学的常客，深入理解和掌握对于图形渲染有着非常重要的意义，本节主要是关于3D数学库的内容。</p><a id="more"></a><ul><li>向量</li><li>矩阵</li></ul><h1 id="一、向量"><a href="#一、向量" class="headerlink" title="一、向量"></a>一、向量</h1><p>&emsp;&emsp;$n$维向量本质就是一个$n$元组，从几何意义上来说，向量是有大小和方向的有向线段。向量的大小就是向量的长度（模）向量有非负的长度，而向量的方向描述了空间中向量的指向。向量的相关内容高中就已涉及，因此不再赘述。若想要重新深入了解相关内容，可以查看这个<a href="http://www.cnblogs.com/msxh/p/6156004.html" target="_blank" rel="noopener">地址</a>。</p><p>&emsp;&emsp;图形渲染中通常使用的向量为$2$到$4$维，如下分别是$2$维、$3$维、$4$维向量类的常用方法，主要是运算操作符重载以及点乘、叉乘、模、标准化、线性插值等基本操作。向量的内容简单，没什么要特别说明的。</p><h2 id="1、2D向量类"><a href="#1、2D向量类" class="headerlink" title="1、2D向量类"></a>1、2D向量类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">float</span> x,y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructors</span></span><br><span class="line">    Vector2D():x(<span class="number">0.0f</span>), y(<span class="number">0.0f</span>) &#123;&#125;</span><br><span class="line">    Vector2D(<span class="keyword">float</span> newX, <span class="keyword">float</span> newY):x(newX), y(newY)&#123;&#125;</span><br><span class="line">    Vector2D(<span class="keyword">const</span> <span class="keyword">float</span> * rhs):x(*rhs), y((*rhs)+<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    Vector2D(<span class="keyword">const</span> Vector2D &amp; rhs):x(rhs.x), y(rhs.y)&#123;&#125;</span><br><span class="line">    ~Vector2D() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter,getter</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">float</span> newX, <span class="keyword">float</span> newY)</span></span>&#123;x=newX;y=newY;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">float</span> newX)</span> </span>&#123;x = newX;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">float</span> newY)</span> </span>&#123;y = newY;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getY</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> y;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// normalization</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">normalize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Vector2D <span class="title">getNormalize</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// length</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getLength</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">sqrt</span>(x*x + y*y));&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getSquaredLength</span><span class="params">()</span><span class="keyword">const</span></span>&#123;<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(x*x + y*y);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overloaded operators</span></span><br><span class="line">    Vector2D <span class="keyword">operator</span>+(<span class="keyword">const</span> Vector2D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector2D(x + rhs.x, y + rhs.y);&#125;</span><br><span class="line">    Vector2D <span class="keyword">operator</span>-(<span class="keyword">const</span> Vector2D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector2D(x - rhs.x, y - rhs.y);&#125;</span><br><span class="line">    Vector2D <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">float</span> rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector2D(x*rhs, y*rhs);&#125;</span><br><span class="line">    Vector2D <span class="keyword">operator</span>/(<span class="keyword">const</span> <span class="keyword">float</span> rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> (rhs==<span class="number">0</span>) ? Vector2D(<span class="number">0.0f</span>, <span class="number">0.0f</span>) : Vector2D(x / rhs, y / rhs);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Vector2D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> (equal(x,rhs.x) &amp;&amp; equal(y,rhs.y));&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Vector2D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> !((*<span class="keyword">this</span>)==rhs);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> Vector2D &amp;rhs)&#123;x+=rhs.x;y+=rhs.y;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>-=(<span class="keyword">const</span> Vector2D &amp;rhs)&#123;x-=rhs.x;y-=rhs.y;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>*=(<span class="keyword">const</span> <span class="keyword">float</span> rhs)&#123;x*=rhs;y*=rhs;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>/=(<span class="keyword">const</span> <span class="keyword">float</span> rhs)&#123;<span class="keyword">if</span>(!equal(rhs, <span class="number">0.0</span>))&#123;x/=rhs;y/=rhs;&#125;&#125;</span><br><span class="line"></span><br><span class="line">    Vector2D <span class="keyword">operator</span>-() <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector2D(-x, -y);&#125;</span><br><span class="line">    Vector2D <span class="keyword">operator</span>+() <span class="keyword">const</span> &#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// interpolation</span></span><br><span class="line">    <span class="function">Vector2D <span class="title">lerp</span><span class="params">(<span class="keyword">const</span> Vector2D &amp;v2,<span class="keyword">const</span> <span class="keyword">float</span> factor)</span><span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> (*<span class="keyword">this</span>)*(<span class="number">1.0f</span> - factor) + v2*factor;&#125;</span><br><span class="line">    <span class="function">Vector2D <span class="title">quadraticInterpolate</span><span class="params">(<span class="keyword">const</span> Vector2D &amp; v2, <span class="keyword">const</span> Vector2D &amp; v3, <span class="keyword">const</span> <span class="keyword">float</span> factor)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> (*<span class="keyword">this</span>)*(<span class="number">1.0f</span>-factor)*(<span class="number">1.0f</span>-factor) + v2*<span class="number">2.0f</span>*factor*(<span class="number">1.0f</span>-factor) + v3*factor*factor;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2、3D向量类"><a href="#2、3D向量类" class="headerlink" title="2、3D向量类"></a>2、3D向量类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector3D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">float</span> x,y,z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructors</span></span><br><span class="line">    Vector3D():x(<span class="number">0.0f</span>), y(<span class="number">0.0f</span>), z(<span class="number">0.0f</span>)&#123;&#125;</span><br><span class="line">    Vector3D(<span class="keyword">float</span> newX, <span class="keyword">float</span> newY, <span class="keyword">float</span> newZ):x(newX), y(newY), z(newZ)&#123;&#125;</span><br><span class="line">    Vector3D(<span class="keyword">const</span> <span class="keyword">float</span> * rhs):x(*rhs), y(*(rhs+<span class="number">1</span>)), z(*(rhs+<span class="number">2</span>))&#123;&#125;</span><br><span class="line">    Vector3D(<span class="keyword">const</span> Vector3D &amp;rhs):x(rhs.x), y(rhs.y), z(rhs.z)&#123;&#125;</span><br><span class="line">    ~Vector3D() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter,getter</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">float</span> newX, <span class="keyword">float</span> newY, <span class="keyword">float</span> newZ)</span></span>&#123;x=newX;y=newY;z=newZ;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">float</span> newX)</span> </span>&#123;x = newX;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">float</span> newY)</span> </span>&#123;y = newY;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZ</span><span class="params">(<span class="keyword">float</span> newZ)</span> </span>&#123;z = newZ;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getY</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> y;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getZ</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> z;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// normalization</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">normalize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Vector3D <span class="title">getNormalized</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// length caculation</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getLength</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">sqrt</span>(x*x+y*y+z*z));&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getSquaredLength</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x*x+y*y+z*z;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// product</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">dotProduct</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;rhs)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x*rhs.x + y*rhs.y + z*rhs.z;&#125;</span><br><span class="line">    <span class="function">Vector3D <span class="title">crossProduct</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;rhs)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> Vector3D(y*rhs.z - z*rhs.y, z*rhs.x - x*rhs.z, x*rhs.y - y*rhs.x);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// linear interpolation</span></span><br><span class="line">    <span class="function">Vector3D <span class="title">lerp</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;v2, <span class="keyword">float</span> factor)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> (*<span class="keyword">this</span>)*(<span class="number">1.0f</span>-factor) + v2*factor;&#125;</span><br><span class="line">    <span class="function">Vector3D <span class="title">QuadraticInterpolate</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;v2, <span class="keyword">const</span> Vector3D &amp;v3, <span class="keyword">float</span> factor)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> (*<span class="keyword">this</span>)*(<span class="number">1.0f</span>-factor)*(<span class="number">1.0f</span>-factor) + v2*<span class="number">2.0f</span>*factor*(<span class="number">1.0f</span>-factor) + v3*factor*factor;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overloaded operators</span></span><br><span class="line">    Vector3D <span class="keyword">operator</span>+(<span class="keyword">const</span> Vector3D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector3D(x + rhs.x, y + rhs.y, z + rhs.z);&#125;</span><br><span class="line">    Vector3D <span class="keyword">operator</span>-(<span class="keyword">const</span> Vector3D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector3D(x - rhs.x, y - rhs.y, z - rhs.z);&#125;</span><br><span class="line">    Vector3D <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">float</span> rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector3D(x*rhs, y*rhs, z*rhs);&#125;</span><br><span class="line">    Vector3D <span class="keyword">operator</span>/(<span class="keyword">const</span> <span class="keyword">float</span> rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> (equal(rhs,<span class="number">0.0f</span>))?Vector3D(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>):Vector3D(x/rhs, y/rhs, z/rhs);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Vector3D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> (equal(x,rhs.x) &amp;&amp; equal(y,rhs.y) &amp;&amp; equal(z,rhs.z));&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Vector3D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> !((*<span class="keyword">this</span>)==rhs);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> Vector3D &amp;rhs) &#123;x+=rhs.x;y+=rhs.y;z+=rhs.z;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>-=(<span class="keyword">const</span> Vector3D &amp; rhs) &#123;x-=rhs.x;y-=rhs.y;z-=rhs.z;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>*=(<span class="keyword">const</span> <span class="keyword">float</span> rhs)&#123;x*=rhs;y*=rhs;z*=rhs;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>/=(<span class="keyword">const</span> <span class="keyword">float</span> rhs)&#123;<span class="keyword">if</span>(!equal(rhs,<span class="number">0.0f</span>))&#123;x/=rhs; y/=rhs; z/=rhs;&#125;&#125;</span><br><span class="line"></span><br><span class="line">    Vector3D <span class="keyword">operator</span>-() <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector3D(-x, -y, -z);&#125;</span><br><span class="line">    Vector3D <span class="keyword">operator</span>+() <span class="keyword">const</span> &#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3、4D向量类"><a href="#3、4D向量类" class="headerlink" title="3、4D向量类"></a>3、4D向量类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector4D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">float</span> x,y,z,w;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructors</span></span><br><span class="line">    Vector4D():x(<span class="number">0.0f</span>), y(<span class="number">0.0f</span>), z(<span class="number">0.0f</span>), w(<span class="number">0.0f</span>)&#123;&#125;</span><br><span class="line">    Vector4D(<span class="keyword">float</span> newX, <span class="keyword">float</span> newY, <span class="keyword">float</span> newZ, <span class="keyword">float</span> newW):x(newX), y(newY), z(newZ), w(newW)&#123;&#125;</span><br><span class="line">    Vector4D(<span class="keyword">const</span> <span class="keyword">float</span> * rhs):x(*rhs), y(*(rhs+<span class="number">1</span>)), z(*(rhs+<span class="number">2</span>)), w(*(rhs+<span class="number">3</span>))&#123;&#125;</span><br><span class="line">    Vector4D(<span class="keyword">const</span> Vector4D &amp;rhs):x(rhs.x), y(rhs.y), z(rhs.z), w(rhs.w)&#123;&#125;</span><br><span class="line">    Vector4D(<span class="keyword">const</span> Vector3D &amp; rhs):x(rhs.x), y(rhs.y), z(rhs.z), w(<span class="number">1.0f</span>)&#123;&#125;</span><br><span class="line">    ~Vector4D() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter,getter</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">float</span> newX, <span class="keyword">float</span> newY, <span class="keyword">float</span> newZ, <span class="keyword">float</span> newW)</span></span>&#123;x=newX;y=newY;z=newZ;w=newW;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">float</span> newX)</span> </span>&#123;x = newX;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">float</span> newY)</span> </span>&#123;y = newY;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZ</span><span class="params">(<span class="keyword">float</span> newZ)</span> </span>&#123;z = newZ;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setW</span><span class="params">(<span class="keyword">float</span> newW)</span> </span>&#123;w = newW;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getY</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> y;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getZ</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> z;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getW</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> w;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// product</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">dotProduct</span><span class="params">(<span class="keyword">const</span> Vector4D &amp;rhs)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x*rhs.x + y*rhs.y + z*rhs.z + w*rhs.w;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// linear interpolation</span></span><br><span class="line">    <span class="function">Vector4D <span class="title">lerp</span><span class="params">(<span class="keyword">const</span> Vector4D &amp;v2, <span class="keyword">float</span> factor)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> (*<span class="keyword">this</span>)*(<span class="number">1.0f</span>-factor) + v2*factor;&#125;</span><br><span class="line">    <span class="function">Vector4D <span class="title">QuadraticInterpolate</span><span class="params">(<span class="keyword">const</span> Vector4D &amp;v2, <span class="keyword">const</span> Vector4D &amp;v3, <span class="keyword">float</span> factor)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> (*<span class="keyword">this</span>)*(<span class="number">1.0f</span>-factor)*(<span class="number">1.0f</span>-factor)+v2*<span class="number">2.0f</span>*factor*(<span class="number">1.0f</span>-factor)+v3*factor*factor;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overloaded operators</span></span><br><span class="line">    Vector4D <span class="keyword">operator</span>+(<span class="keyword">const</span> Vector4D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector4D(x+rhs.x, y+rhs.y, z+rhs.z, w+rhs.w);&#125;</span><br><span class="line">    Vector4D <span class="keyword">operator</span>-(<span class="keyword">const</span> Vector4D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector4D(x-rhs.x, y-rhs.y, z-rhs.z, w-rhs.w);&#125;</span><br><span class="line">    Vector4D <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">float</span> rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector4D(x*rhs, y*rhs, z*rhs, w*rhs);&#125;</span><br><span class="line">    Vector4D <span class="keyword">operator</span>/(<span class="keyword">const</span> <span class="keyword">float</span> rhs) <span class="keyword">const</span></span><br><span class="line">    &#123;<span class="keyword">return</span> (equal(rhs,<span class="number">0.0f</span>))?Vector4D(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>):Vector4D(x/rhs, y/rhs, z/rhs, w/rhs);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Vector4D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> (equal(x,rhs.x)&amp;&amp;equal(y,rhs.y)&amp;&amp;equal(z,rhs.z)&amp;&amp;equal(w,rhs.w));&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Vector4D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> !((*<span class="keyword">this</span>)==rhs);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> Vector4D &amp;rhs) &#123;x+=rhs.x;y+=rhs.y;z+=rhs.z;w+=rhs.w;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>-=(<span class="keyword">const</span> Vector4D &amp; rhs) &#123;x-=rhs.x;y-=rhs.y;z-=rhs.z;w-=rhs.w;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>*=(<span class="keyword">const</span> <span class="keyword">float</span> rhs)&#123;x*=rhs;y*=rhs;z*=rhs;w*=rhs;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>/=(<span class="keyword">const</span> <span class="keyword">float</span> rhs)&#123;<span class="keyword">if</span>(!equal(rhs,<span class="number">0.0f</span>))&#123;x/=rhs; y/=rhs; z/=rhs; w/=rhs;&#125;&#125;</span><br><span class="line"></span><br><span class="line">    Vector4D <span class="keyword">operator</span>-() <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector4D(-x, -y, -z, -w);&#125;</span><br><span class="line">    Vector4D <span class="keyword">operator</span>+() <span class="keyword">const</span> &#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二、矩阵"><a href="#二、矩阵" class="headerlink" title="二、矩阵"></a>二、矩阵</h1><p>&emsp;&emsp;矩阵本质就是向量的进一步扩展的，一个$n\times m$的矩阵可看成$n$个$m$维行向量组成或者$m$个$n$维列向量组成，关于矩阵的基本概念、操作请看<a href="https://blog.csdn.net/AutisticPatient/article/details/62892100" target="_blank" rel="noopener">这里</a>。通常我们采用方阵来描述线性变换。所谓线性变换，即变换之后保留了直线而不被弯曲，平行线依然平行，原点没有变化，但其他的几何性质如长度、角度、面积和体积可能被变换改变了。直观来说，线性变换可能“拉伸”坐标系，但不会“弯曲”或“卷折”坐标系。</p><p>&emsp;&emsp;矩阵在计算机中有行主序存储、列主序存储两种方式，行主序存储即按照顺序逐行存储，列主序存储则按照顺序逐列存储。图形学渲染中我们通常采用的是列主序的方式，<strong>以下的讨论都是列主序的矩阵存储方式。</strong>那么矩阵是如何变换向量的？</p><p>&emsp;&emsp;<strong>向量在几何上能被解释成一系列与轴平行的位移</strong>，一般来说，任意向量$\vec v$都能写成如下的形式：</p><script type="math/tex; mode=display">\vec v=\left[\begin{matrix}x\\y\\z\end{matrix}\right]=\left[\begin{matrix}x\\0\\0\end{matrix}\right]+\left[\begin{matrix}0\\y\\0\end{matrix}\right]+\left[\begin{matrix}0\\0\\z\end{matrix}\right]=x\left[\begin{matrix}1\\0\\0\end{matrix}\right]+y\left[\begin{matrix}0\\1\\0\end{matrix}\right]+z\left[\begin{matrix}0\\0\\1\end{matrix}\right] \tag {1}</script><p>&emsp;&emsp;公式$(1)$右边的单位向量就是$x$、$y$、$z$轴方向的向量，<strong>向量的每个坐标都表明了平行于相应坐标轴的有向位移</strong>。我们记$\vec p$、$\vec q$、$\vec r$分别为公式$(1)$中右边的$x$、$y$、$z$轴的单位列向量，则有：</p><script type="math/tex; mode=display">\vec v=x\vec p+y\vec q+z\vec r=\left[\begin{matrix}\vec p &\vec q&\vec r\end{matrix}\right]\left[\begin{matrix}x \\y\\z\end{matrix}\right] \tag {2}</script><p>&emsp;&emsp;向量$\vec v$就变成了向量$\vec p$、$\vec q$、$\vec r$的线性表示，向量$\vec p$、$\vec q$、$\vec r$称作基向量。以上仅仅讨论的是笛卡尔坐标系，但更通用的情况是，一个$3$维坐标系能用任意$3$个线性无关的基向量表示，以列向量$\vec p$、$\vec q$、$\vec r$构建$3\times 3$的矩阵$M$：</p><script type="math/tex; mode=display">M=\left[\begin{matrix}\vec p &\vec q&\vec r\end{matrix}\right]=\left[\begin{matrix}p_x &q_x&r_x\\p_y &q_y&r_y\\p_z &q_z&r_z\end{matrix}\right] \tag {3}</script><p>&emsp;&emsp;结合公式$(2)$和公式$(3)$，即有：</p><script type="math/tex; mode=display">\vec v=M\left[\begin{matrix}x \\y\\z\end{matrix}\right] \tag{4}</script><p>&emsp;&emsp;坐标系变换矩阵的每一列（如果是行主序，就是每一行）都是该坐标系的基向量，一个点$v$右乘该矩阵就相当于执行了一次坐标系转换。<strong>求解线性变换矩阵的关键就是根据当前的坐标系求解变换之后的坐标系的基向量，然后将基向量填入向量位置！</strong></p><p>&emsp;&emsp;一个矩阵类通常有如下方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix4x4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">float</span> entries[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructors</span></span><br><span class="line">    Matrix4x4()&#123;loadIdentity();&#125;</span><br><span class="line">    Matrix4x4(<span class="keyword">float</span> e0, <span class="keyword">float</span> e1, <span class="keyword">float</span> e2, <span class="keyword">float</span> e3,</span><br><span class="line">              <span class="keyword">float</span> e4, <span class="keyword">float</span> e5, <span class="keyword">float</span> e6, <span class="keyword">float</span> e7,</span><br><span class="line">              <span class="keyword">float</span> e8, <span class="keyword">float</span> e9, <span class="keyword">float</span> e10,<span class="keyword">float</span> e11,</span><br><span class="line">              <span class="keyword">float</span> e12,<span class="keyword">float</span> e13,<span class="keyword">float</span> e14,<span class="keyword">float</span> e15);</span><br><span class="line">    Matrix4x4(<span class="keyword">const</span> <span class="keyword">float</span> *rhs);</span><br><span class="line">    Matrix4x4(<span class="keyword">const</span> Matrix4x4 &amp;rhs);</span><br><span class="line">    ~Matrix4x4() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter,getter</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setEntry</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">float</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getEntry</span><span class="params">(<span class="keyword">int</span> position)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Vector4D <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> position)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Vector4D <span class="title">getColumn</span><span class="params">(<span class="keyword">int</span> position)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadIdentity</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadZero</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overloaded operators</span></span><br><span class="line">    Matrix4x4 <span class="keyword">operator</span>+(<span class="keyword">const</span> Matrix4x4 &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    Matrix4x4 <span class="keyword">operator</span>-(<span class="keyword">const</span> Matrix4x4 &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    Matrix4x4 <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix4x4 &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    Matrix4x4 <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">float</span> rhs) <span class="keyword">const</span>;</span><br><span class="line">    Matrix4x4 <span class="keyword">operator</span>/(<span class="keyword">const</span> <span class="keyword">float</span> rhs) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Matrix4x4 &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Matrix4x4 &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> Matrix4x4 &amp; rhs);</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>-=(<span class="keyword">const</span> Matrix4x4 &amp; rhs);</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>*=(<span class="keyword">const</span> Matrix4x4 &amp; rhs);</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>*=(<span class="keyword">const</span> <span class="keyword">float</span> rhs);</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>/=(<span class="keyword">const</span> <span class="keyword">float</span> rhs);</span><br><span class="line"></span><br><span class="line">    Matrix4x4 <span class="keyword">operator</span>-() <span class="keyword">const</span>;</span><br><span class="line">    Matrix4x4 <span class="keyword">operator</span>+() <span class="keyword">const</span> &#123;<span class="keyword">return</span> (*<span class="keyword">this</span>);&#125;</span><br><span class="line">    Vector4D <span class="keyword">operator</span>*(<span class="keyword">const</span> Vector4D rhs) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inverse, transpose</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inverted</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Matrix4x4 <span class="title">getInverse</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transpose</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Matrix4x4 <span class="title">getTranspose</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invertTranspose</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Matrix4x4 <span class="title">getInverseTranspose</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// operation on space</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTranslation</span><span class="params">(<span class="keyword">const</span> Vector3D &amp; translation)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setScale</span><span class="params">(<span class="keyword">const</span> Vector3D &amp; scaleFactor)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRotationAxis</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> angle, <span class="keyword">const</span> Vector3D &amp; axis)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRotationX</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> angle)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRotationY</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> angle)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRotationZ</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> angle)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRotationEuler</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> angleX, <span class="keyword">const</span> <span class="keyword">double</span> angleY, <span class="keyword">const</span> <span class="keyword">double</span> angleZ)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPerspective</span><span class="params">(<span class="keyword">float</span> fovy, <span class="keyword">float</span> aspect, <span class="keyword">float</span> near, <span class="keyword">float</span> far)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPerspective</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> top, <span class="keyword">float</span> near, <span class="keyword">float</span> far)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOrtho</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> top, <span class="keyword">float</span> near, <span class="keyword">float</span> far)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1、线性变换、仿射变换"><a href="#1、线性变换、仿射变换" class="headerlink" title="1、线性变换、仿射变换"></a>1、线性变换、仿射变换</h2><p>&emsp;&emsp;满足$F(a+b)=F(a)+F(b)$和$F(ka)=kF(a)$的映射$F(a)$就是线性的。对于映射$F(a)=Ma$，当$M$为任意方阵时，也可以说明$F$映射是一个线性变换。在计算机图形学中，缩放、旋转的变换操作都是线性的，但是<strong>平移不是线性变换</strong>。</p><p>&emsp;&emsp;具有$v’=Mv’+b$形式的变换都是仿射变换。平移作为最常用的变换之一，然而却不是线性变换；所以为了包括平移变换提出了仿射变换。仿射变换是指线性变换后接着平移。因此，仿射变换的集合是线性变换的超集，任何线性变换都是仿射变换，但不是所有的仿射变换都是线性变换。<strong>为了统一用矩阵表示低维度的仿射变换，我们可以通过高维度的线性变换来完成，为此引入了$4$维齐次坐标。</strong>（当然引入第$4$维$w$还有其他的用途，如当$w=0$时，可解释为无穷远的“点”，其意义是描述方向），关于齐次坐标的更多内容请查看<a href="https://www.cnblogs.com/J1ac/p/9340622.html" target="_blank" rel="noopener">这里</a>。</p><p>&emsp;&emsp;从而，对于高维度来说只是经历了一次切变+投影变换就可以实现低维度的平移（更多内容查看<a href="https://www.matongxue.com/madocs/244.html#/madoc" target="_blank" rel="noopener">这里</a>），在$3D$渲染中，我们采用$4\times 4$的矩阵做相应的变换。关于平移和缩放不再赘述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4x4::setTranslation(<span class="keyword">const</span> Vector3D &amp;translation)</span><br><span class="line">&#123;</span><br><span class="line">    loadIdentity();</span><br><span class="line">    entries[<span class="number">12</span>] = translation.x;</span><br><span class="line">    entries[<span class="number">13</span>] = translation.y;</span><br><span class="line">    entries[<span class="number">14</span>] = translation.z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Matrix4x4::setScale(<span class="keyword">const</span> Vector3D &amp;scaleFactor)</span><br><span class="line">&#123;</span><br><span class="line">    loadIdentity();</span><br><span class="line">    entries[<span class="number">0</span>]  = scaleFactor.x;</span><br><span class="line">    entries[<span class="number">5</span>]  = scaleFactor.y;</span><br><span class="line">    entries[<span class="number">10</span>] = scaleFactor.z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、绕任意轴旋转"><a href="#2、绕任意轴旋转" class="headerlink" title="2、绕任意轴旋转"></a>2、绕任意轴旋转</h2><p>&emsp;&emsp;在3D中，绕坐标轴旋转，而不是绕点旋转，此时首先需要定义的是何为旋转正方向： 左手坐标系中定义此方向的规则为左手法则。首先，要明确旋转轴指向哪个方向。当然，旋转轴在理论上是无限延伸的，但我们还是要认为它有正端点和负端点。与笛卡尔坐标轴定义坐标系相同，左手法则是这样的:伸出左手，大拇指向上，其余手指弯曲。大拇指指向旋转轴的正方向，此时，四指弯曲的方向就是旋转的正方向。<strong>右手坐标系则根据右手法则利用右手判断旋转正方向，本文讨论的是常见的右手坐标系。</strong></p><p> &emsp;&emsp;在旋转变换中，一个常见的特殊情况就是绕$x$轴、绕$y$轴、绕$z$轴旋转，这类的旋转矩阵求解比较简单，只需牢牢记住<strong>列主序矩阵的列向量就是变换后的坐标系的基向量</strong>即可快速推导出相应的旋转矩阵：</p><script type="math/tex; mode=display">R_x(\theta)=\left[\begin{matrix}1&0&0\\0&cos\theta&-sin\theta\\0&sin\theta&cos\theta \end{matrix}\right]\\R_y(\theta)=\left[\begin{matrix}cos\theta&0&sin\theta\\0&1&0\\-sin\theta&0&cos\theta \end{matrix}\right]\\R_z(\theta)=\left[\begin{matrix}cos\theta&-sin\theta&0\\sin\theta&cos\theta&0\\0&0&1\end{matrix}\right] \tag {5}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4x4::setRotationX(<span class="keyword">const</span> <span class="keyword">double</span> angle)</span><br><span class="line">&#123;</span><br><span class="line">    loadIdentity();</span><br><span class="line">    entries[<span class="number">5</span>]  =  <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">cos</span>(M_PI*angle/<span class="number">180</span>));</span><br><span class="line">    entries[<span class="number">6</span>]  =  <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">sin</span>(M_PI*angle/<span class="number">180</span>));</span><br><span class="line">    entries[<span class="number">9</span>]  = -entries[<span class="number">6</span>];</span><br><span class="line">    entries[<span class="number">10</span>] =  entries[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Matrix4x4::setRotationY(<span class="keyword">const</span> <span class="keyword">double</span> angle)</span><br><span class="line">&#123;</span><br><span class="line">    loadIdentity();</span><br><span class="line">    entries[<span class="number">0</span>]  =  <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">cos</span>(M_PI*angle/<span class="number">180</span>));</span><br><span class="line">    entries[<span class="number">2</span>]  = -<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">sin</span>(M_PI*angle/<span class="number">180</span>));</span><br><span class="line">    entries[<span class="number">8</span>]  = -entries[<span class="number">2</span>];</span><br><span class="line">    entries[<span class="number">10</span>] =  entries[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Matrix4x4::setRotationZ(<span class="keyword">const</span> <span class="keyword">double</span> angle)</span><br><span class="line">&#123;</span><br><span class="line">    loadIdentity();</span><br><span class="line">    entries[<span class="number">0</span>]  =  <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">cos</span>(M_PI*angle/<span class="number">180</span>));</span><br><span class="line">    entries[<span class="number">1</span>]  =  <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">sin</span>(M_PI*angle/<span class="number">180</span>));</span><br><span class="line">    entries[<span class="number">4</span>]  = -entries[<span class="number">1</span>];</span><br><span class="line">    entries[<span class="number">5</span>]  =  entries[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是更一般的情况是绕任意轴进行旋转，构建这样的矩阵稍微有点麻烦，我们接下来就做一些绕任意轴旋转的矩阵构建推到。在这里我们不考虑平移，因而围绕旋转的轴一定是通过原点的。如下图1所示，将$\vec v$旋转到$\vec v ‘$，任意轴用单位向量$\vec n$表示，绕$\vec n$旋转$\theta$角度的矩阵记为$R(\vec n, \theta)$，$\vec v’$是向量绕轴$\vec n$旋转后的向量，即$\vec v’=R(\vec n,\theta)\vec v$。</p><p><img src="https://img-my.csdn.net/uploads/201304/08/1365419995_7039.png" alt="img"></p><p><center>图1 绕任意轴旋转</center><br>&emsp;&emsp;<strong>我们的目标就是用$\vec v$、$\vec n$和$\theta$来表示$\vec v’$，从而构造出$R(\vec n, \theta)$。</strong>首先将$\vec v$分解成平行于$\vec n$的向量$\vec v_{||}$和垂直于$\vec n$的分量$\vec v_{⊥}$，而$\vec v’_{⊥}$是垂直于$\vec n$的分向量。注意，$\vec n$是单位向量，但$\vec v$不是单位向量，可得$\vec v$在$\vec n$方向的投影向量$\vec v_{||}$为：</p><script type="math/tex; mode=display">\vec v_{||}=(\vec v\cdot\vec n)\vec n \tag {6}</script><p>&emsp;&emsp;从而根据$\vec v_{||}$和$\vec v$可知$\vec v_{⊥}$和$w$，$w$是垂直于$\vec n$和$\vec v_{⊥}$的向量：</p><script type="math/tex; mode=display">\vec v_{⊥}=\vec v-\vec v_{||} \tag {7}</script><script type="math/tex; mode=display">w=\vec n \times \vec v_{⊥} = \vec n\times (\vec v-\vec v_{||})\\=\vec n\times\vec v-\vec n\times\vec v_{||}=\vec n\times\vec v-0=\vec n\times \vec v \tag{8}</script><p>&emsp;&emsp;$\vec w$和$\vec v_{⊥}$相互垂直，$\vec w$、$\vec v_{⊥}$和$\vec v’_{⊥}$在同一个平面上，$\vec v’_{⊥}$和$\vec v_{⊥}$的夹角为$\theta$，从而$\vec v’_{⊥}$可由$\vec w$和$\vec v_{⊥}$线性表示为：</p><script type="math/tex; mode=display">\vec v'_{⊥}=cos\theta\vec v_{⊥}+sin\theta\vec w\\=cos\theta(\vec v-(\vec v\cdot\vec n)\vec n)+sin\theta(\vec n\times\vec v)\tag {9}</script><p>&emsp;&emsp;最后，根据公式$(6)$和公式$(9)$我们已知$\vec v_{||}$和$\vec v’_{⊥}$，从而可以得出$\vec v’$：</p><script type="math/tex; mode=display">\vec v'=\vec v_{||}+\vec v'_{⊥}\\=cos\theta(\vec v-(\vec v\cdot\vec n)\vec n)+sin\theta(\vec n\times\vec v)+(\vec v\cdot\vec n)\vec n \tag {10}</script><p>&emsp;&emsp;由公式$(10)$可知，我们已经用$\vec v$、$\vec n$和$\theta$表示$\vec v’$，那如何根据上述的公式$(10)$构建旋转矩阵$R(\vec n, \theta)$？还是那个思路：<strong>列主序变换矩阵的列向量就是变换后的坐标系的基向量</strong>。我们只需求出笛卡尔坐标系的$\vec x$、$\vec y$、$\vec z$三个轴方向上的基向量按照公式$(10)$旋转之后的基向量$\vec x’$、$\vec y’$、$\vec z’$，然后填入矩阵$R(\vec n, \theta)$即可，以$\vec x=[1\ \ 0 \ \ 0]^T$为例：</p><script type="math/tex; mode=display">\vec x'=cos\theta(\vec x-(\vec x\cdot\vec n)\vec n)+sin\theta(\vec n\times\vec x)+(\vec x\cdot\vec n)\vec n=\left[\begin{matrix}n^2_x(1-cos\theta)+cos\theta \\n_xn_y(1-cos\theta)+n_zsin\theta \\n_xn_z(1-cos\theta)-n_ysin\theta) \end{matrix}\right] \tag {11}</script><p>&emsp;&emsp;$\vec y=[0\ \  1\ \  0]^T$和$\vec z=[0\ \  0\ \  1]^T$同理：</p><script type="math/tex; mode=display">\vec y'=\left[\begin{matrix}n_xn_y(1-cos\theta)-n_zsin\theta\\n^2_y(1-cos\theta)+cos\theta\\n_yn_z(1-cos\theta)+n_xsin\theta\end{matrix}\right] \tag {12}</script><script type="math/tex; mode=display">\vec z'=\left[\begin{matrix}n_xn_z(1-cos\theta)+n_ysin\theta\\n_yn_z(1-cos\theta)-n_xsin\theta\\n^2_z(1-cos\theta)+cos\theta\end{matrix}\right] \tag {13}</script><p>&emsp;&emsp;将$\vec x’$、$\vec y’$、$\vec z’$合并到$R(\vec n, \theta)$中：</p><script type="math/tex; mode=display">R(\vec n, \theta)=\left[\begin{matrix}\vec x'&\vec y'&\vec z'\end{matrix}\right]\\=\begin{bmatrix}{n_x}^2(1-cos\theta)+cos\theta&n_xn_y(1-cos\theta)-n_zsin\theta&n_xn_z(1-cos\theta)+n_ysin\theta\\n_xn_y(1-cos\theta)+n_zsin\theta&n^2_y(1-cos\theta)+cos\theta&n_yn_z(1-cos\theta)-n_xsin\theta\\n_xn_z(1-cos\theta)-n_ysin\theta)&n_yn_z(1-cos\theta)+n_xsin\theta&n^2_z(1-cos\theta)+cos\theta\end{bmatrix} \tag {14}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4x4::setRotationAxis(<span class="keyword">const</span> <span class="keyword">double</span> angle, <span class="keyword">const</span> Vector3D &amp;axis)</span><br><span class="line">&#123;</span><br><span class="line">    Vector3D u = axis.getNormalized();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> sinAngle = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">sin</span>(M_PI*angle/<span class="number">180</span>));</span><br><span class="line">    <span class="keyword">float</span> cosAngle = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">cos</span>(M_PI*angle/<span class="number">180</span>));</span><br><span class="line">    <span class="keyword">float</span> oneMinusCosAngle = <span class="number">1.0f</span> - cosAngle;</span><br><span class="line"></span><br><span class="line">    loadIdentity();</span><br><span class="line"></span><br><span class="line">    entries[<span class="number">0</span>]  = (u.x)*(u.x) + cosAngle*(<span class="number">1</span>-(u.x)*(u.x));</span><br><span class="line">    entries[<span class="number">4</span>]  = (u.x)*(u.y)*(oneMinusCosAngle) - sinAngle*u.z;</span><br><span class="line">    entries[<span class="number">8</span>]  = (u.x)*(u.z)*(oneMinusCosAngle) + sinAngle*u.y;</span><br><span class="line"></span><br><span class="line">    entries[<span class="number">1</span>]  = (u.x)*(u.y)*(oneMinusCosAngle) + sinAngle*u.z;</span><br><span class="line">    entries[<span class="number">5</span>]  = (u.y)*(u.y) + cosAngle*(<span class="number">1</span>-(u.y)*(u.y));</span><br><span class="line">    entries[<span class="number">9</span>]  = (u.y)*(u.z)*(oneMinusCosAngle) - sinAngle*u.x;</span><br><span class="line"></span><br><span class="line">    entries[<span class="number">2</span>]  = (u.x)*(u.z)*(oneMinusCosAngle) - sinAngle*u.y;</span><br><span class="line">    entries[<span class="number">6</span>]  = (u.y)*(u.z)*(oneMinusCosAngle) + sinAngle*u.x;</span><br><span class="line">    entries[<span class="number">10</span>] = (u.z)*(u.z) + cosAngle*(<span class="number">1</span>-(u.z)*(u.z));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、透视投影、正交投影"><a href="#3、透视投影、正交投影" class="headerlink" title="3、透视投影、正交投影"></a>3、透视投影、正交投影</h2><p>&emsp;&emsp;$3D$空间中的物体最终都要通过投影显示到$2D$的屏幕上，这一过程就是投影变换。投影变换矩阵将视图空间中的顶点数据变换到裁剪空间，裁剪空间中的顶点最后通过透视除法被变换到标准化设备坐标（$NDC$）。通常由两类投影：透视投影、正交投影。</p><h3 id="透视投影矩阵"><a href="#透视投影矩阵" class="headerlink" title="透视投影矩阵"></a>透视投影矩阵</h3><p>&emsp;&emsp;关于透视投影矩阵的前世今生我不过多说，直接上透视投影矩阵的推导过程。一个视锥体我们目前用六个参数表示：$left$，$right$，$bottom$，$top$，$near$，$far$，简写为$l$、$r$、$b$、$t$、$n$和$f$，即视锥体的六个面。<strong>我们的目标就是将视图空间中在视锥体内的点变换到标准化设备坐标中的立方体内。</strong>即$x$轴方向从$[l,r]$映射到$[-1,1]$，$y$轴方向从$[b,t]$映射到$[-1,1]$，$z$轴方向从$[-n,-f]$映射到$[-1,1]$。</p><p>&emsp;&emsp;<strong>可能你会觉得奇怪，$z$轴方向为什么是从$[-n,-f]$映射到$[-1,1]$？这是因为摄像机空间的坐标系是右手坐标系，在视图空间中摄像机是朝向视图坐标系的$z$轴的负方向，如下图左边所示，$+Y$、$+Z$、$+X$标准摄像机坐标系的三个轴，而摄像机的观察视锥体是朝向$-Z$方向的。而$NDC$又是左手坐标系，朝向$+Z$方向，所以我们要取负。</strong></p><p><img src="http://www.songho.ca/opengl/files/gl_projectionmatrix01.png" alt="OpenGL Perspective Frustum and NDC"></p><p><center>图2 透视投影视锥和标准化设备坐标</center><br><img src="http://www.songho.ca/opengl/files/gl_projectionmatrix03.png" alt="Top View of Frustum"></p><p><center>图3 从-Y方向看去的视锥横截面</center><br><img src="http://www.songho.ca/opengl/files/gl_projectionmatrix04.png" alt="Side View of Frustum"></p><p><center>图4 从-X方向看去的视锥横截面</center><br>&emsp;&emsp;在视锥体中的顶点$(x_e,y_e,z_e)$被投影到视锥体的近平面，近平面上的点我们记为$(x_p,y_p,-n)$。如图3和图4所示，根据三角形相似的原理，我们有：</p><script type="math/tex; mode=display">\frac{x_p}{x_e}=\frac{-n}{z_e}\ \rightarrow\ x_p=\frac{-n\cdot x_e}{z_e}=\frac{n\cdot x_e}{-z_e} \tag {15}</script><script type="math/tex; mode=display">\frac{y_p}{y_e}=\frac{-n}{y_e}\ \rightarrow\ y_p=\frac{-n\cdot y_e}{z_e}=\frac{n\cdot y_e}{-z_e} \tag {16}</script><p>&emsp;&emsp;注意到公式$(15)$和$(16)$中分母都是一个$-z_e$，这与我们将裁剪空间中的顶点做透视除法相对应，透视投影然后做透视除法如下公式$(17)$、$(18)$所示：</p><script type="math/tex; mode=display">\left(\begin{matrix}x_{clip}\\y_{clip}\\z_{clip}\\w_{clip}\end{matrix}\right)=M_{projection}\cdot\left(\begin{matrix}x_{eye}\\y_{eye}\\z_{eye}\\w_{eye}\end{matrix}\right) \tag {17}</script><script type="math/tex; mode=display">\left(\begin{matrix}x_{ndc}\\y_{ndc}\\z_{ndc}\end{matrix}\right)=\left(\begin{matrix}x_{clip}/w_{clip}\\y_{clip}/w_{clip}\\z_{clip}/w_{clip}\end{matrix}\right) \tag {18}</script><p>&emsp;&emsp;为了便于构建矩阵（$x_e$和$y_e$均与$-z_e$相除，不好构建矩阵），我们令裁剪空间中的$w_{clip}$为$-z_e$，将除以$-z_e$的这一步挪到了透视除法去做。故目前的透视矩阵就变为：</p><script type="math/tex; mode=display">\left(\begin{matrix}x_{c}\\y_{c}\\z_{c}\\w_{c}\end{matrix}\right)=\left(\begin{matrix}.&.&.&.\\.&.&.&.\\.&.&.&.\\0&0&-1&0\end{matrix}\right)    \left(\begin{matrix}x_{e}\\y_{e}\\z_{e}\\w_{e}\end{matrix}\right) \tag  {19}</script><p>&emsp;&emsp;其中”$.$”均表示未知。得到在近平面的$x_p$和$y_p$之后，我们还要将$x_p$映射到$[-1,1]$范围，同理$y_p$也是。以$x_p$为例，我们知道其值域为$[l,r]$。为了将$x_p$其映射到$[-1,1]$，我们首先将其映射到$[0,1]$，不难得到如下式子：</p><script type="math/tex; mode=display">\frac{x_p-l}{r-l}\in[0,1] \tag {20}</script><p>&emsp;&emsp;式$(20)$乘上一个$2$再减去$1$就映射到了$[-1,1]$，映射之后记为$x_n$：</p><script type="math/tex; mode=display">x_n=2\frac{x_p-l}{r-l}-1=\frac{2x_p}{r-l}-\frac{r+l}{r-l}\in[-1,1] \tag {21}</script><p>&emsp;&emsp;同理$y_p$到$y_n$的映射：</p><script type="math/tex; mode=display">y_n=\frac{2y_p}{r-l}-\frac{t+b}{t-b}\in[-1,1] \tag {22}</script><p>&emsp;&emsp;然后将公式$(15)$中的$x_p$带入公式$(21)$，将公式$(16)$中的$y_p$带入公式$(22)$，以$x_p$为例：</p><script type="math/tex; mode=display">x_n=\frac{2x_p}{r-l}-\frac{r+l}{r-l}=\frac{2\frac{n\cdot x_e}{-z_e}}{r-l}-\frac{r+l}{r-l}\\=\frac{2n\cdot x_e}{(r-l)(-z_e)}-\frac{r+l}{r-l}=\frac{\frac{2n}{r-l}\cdot x_e}{-z_e}-\frac{r+l}{r-l}\\=\frac{\frac{2n}{r-l}\cdot x_e}{-z_e}+\frac{\frac{r+l}{r-l}\cdot z_e}{-z_e}=\underbrace{(\frac{2n}{r-l}\cdot x_e+\frac{r+l}{r-l}\cdot z_e)}_{x_c}/-z_e \tag {23}</script><p>&emsp;&emsp;其中$x_c$即公式$(19)$中的裁剪空间中的$x$轴坐标值。$y_p$同理可得$y_c$:</p><script type="math/tex; mode=display">y_n=\underbrace{(\frac{2n}{t-b}\cdot y_e+\frac{t+b}{t-b}\cdot z_e)}_{y_c}/-z_e \tag {24}</script><p>&emsp;&emsp;现在我们已经知道了$x_c$和$y_c$分辨关于$x_e$、$y_e$以及$z_e$的表达形式，我们可以填充式$(19)$中的投影矩阵第一行与第二行：</p><script type="math/tex; mode=display">\left(\begin{matrix}x_{c}\\y_{c}\\z_{c}\\w_{c}\end{matrix}\right)=\left(\begin{matrix}\frac{2n}{r-l}&0&\frac{r+l}{r-l}&0\\0&\frac{2n}{t-b}&\frac{t+b}{t-b}&0\\0&0&A&B\\0&0&-1&0\end{matrix}\right)    \left(\begin{matrix}x_{e}\\y_{e}\\z_{e}\\w_{e}\end{matrix}\right) \tag  {25}</script><p>&emsp;&emsp;现在我们还剩下投影矩阵的第三行还不知道。因为我们知道$z$的投影与$x_e$和$y_e$无关，只与$z_e$、$w_e$有关，故可以假设投影矩阵的第三行如上式$(25)$所示，$A$和$B$就是我们假设的要求解的未知表达式。此外，在视图空间中的$w_e$是等于$1$的，$w_c$即前面提到的$-z_e$，从而有：</p><script type="math/tex; mode=display">z_n=z_c/w_c=\frac{Az_e+Bw_e}{-z_e}=\frac{Az_e+B}{-z_e} \tag {26}</script><p>&emsp;&emsp;为了求出公式$(26)$中的$A$和$B$，我们取两个极端的例子：在$-n$处的$z$值被映射到$-1$，在$-f$处的$z$值被映射到$1$，将$(z_n,z_e)=(-1,-n)$和$(z_n,z_e)=(1,-f)$带入式$(26)$中，可得方程组：</p><script type="math/tex; mode=display">\begin{cases}\frac{-An+B}{n}=-1\\\frac{-Af+B}{f}=1\\\end{cases}\ \rightarrow\ \begin{cases}{-An+B}=-n\\{-Af+B}=f\\\end{cases} \tag {27}</script><p>&emsp;&emsp;求解方程$(27)$，可得$A$与$B$如下所示：</p><script type="math/tex; mode=display">A=-\frac{f+n}{f-n}\\B=-\frac{2fn}{f-n} \tag {28}</script><p>&emsp;&emsp;将公式$(28)$带入公式$(26)$中：</p><script type="math/tex; mode=display">z_n=\underbrace{(-\frac{f+n}{f-n}z_e-\frac{2fn}{f-n})}_{z_c}/{-z_e} \tag {29}</script><p>&emsp;&emsp;我们最终得到了$z_c$关于$z_e$的表达式，将$A$与$B$填入式$(25)$的投影矩阵即可，$M_{projection}$就是我们一直在寻求的透视投影矩阵：</p><script type="math/tex; mode=display">M_{projection}=\left(\begin{matrix}\frac{2n}{r-l}&0&\frac{r+l}{r-l}&0\\0&\frac{2n}{t-b}&\frac{t+b}{t-b}&0\\0&0&-\frac{f+n}{f-n}&-\frac{2fn}{f-n}\\0&0&-1&0\end{matrix}\right)     \tag {30}</script><p>&emsp;&emsp;公式$(30)$中的透视投影矩阵只是一个通用的形式，在视图空间中的视锥体通常都是关于$x$轴和$y$轴对称的，从而有$r=-l$、$t=-b$，将式$(30)$简化成如下形式：</p><script type="math/tex; mode=display">M_{projection}=\left(\begin{matrix}\frac{2n}{r-l}&0&0&0\\0&\frac{2n}{t-b}&0&0\\0&0&-\frac{f+n}{f-n}&-\frac{2fn}{f-n}\\0&0&-1&0\end{matrix}\right)     \tag {31}</script><p>&emsp;&emsp;&emsp;但是通常我们传入构建透视矩阵函数的参数是$fovy$（$y$轴方向的视域角）、$aspect$（屏幕的宽高比）、$near$（近平面）以及$far$（远平面），如何根据这些参数构造式$(31)$的透视投影矩阵呢？注意到$r-l=width$即近平面宽度，$t-b=height$即近平面的高度，我们可以根据$fovy$和$aspect$得出$width$和$height$，具体细节不再赘述：</p><script type="math/tex; mode=display">r-l=width=2*near*aspect*tan(fovy/2)\\t-b=height=2*near*tan(fovy/2)</script><script type="math/tex; mode=display">M_{projection}=\left(\begin{matrix}\frac{1}{aspect*tan(fovy/2)}&0&0&0\\0&\frac{1}{tan(fovy/2)}&0&0\\0&0&-\frac{f+n}{f-n}&-\frac{2fn}{f-n}\\0&0&-1&0\end{matrix}\right)     \tag {32}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4x4::setPerspective(<span class="keyword">float</span> fovy, <span class="keyword">float</span> aspect, <span class="keyword">float</span> near, <span class="keyword">float</span> far)</span><br><span class="line">&#123;</span><br><span class="line">    loadZero();</span><br><span class="line">    <span class="comment">// convert fov from degrees to radians</span></span><br><span class="line">    <span class="keyword">float</span> rFovy = fovy*M_PI/<span class="number">180</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> tanHalfFovy = tanf(<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(rFovy*<span class="number">0.5f</span>));</span><br><span class="line">    entries[<span class="number">0</span>]         = <span class="number">1.0f</span>/(aspect*tanHalfFovy);</span><br><span class="line">    entries[<span class="number">5</span>]         = <span class="number">1.0f</span>/(tanHalfFovy);</span><br><span class="line">    entries[<span class="number">10</span>]        = -(far+near)/(far-near);</span><br><span class="line">    entries[<span class="number">11</span>]        = <span class="number">-1.0f</span>;</span><br><span class="line">    entries[<span class="number">14</span>]        = (<span class="number">-2.0f</span>*near*far)/(far-near);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正交投影矩阵"><a href="#正交投影矩阵" class="headerlink" title="正交投影矩阵"></a>正交投影矩阵</h3><p>&emsp;&emsp;理解了透视投影矩阵的构造之后，正交投影就简单太多了，正交投影只需做简单的线性映射就行了。只需将$x$轴方向从$[l,r]$映射到$[-1,1]$，$y$轴方向从$[b,t]$映射到$[-1,1]$，$z$轴方向从$[-n,-f]$映射到$[-1,1]$，而这个映射的过程很简单，正如前面公式$(20)$和$(21)$那样，先映射到$[0,1]$，再映射到$[0,2]$，最后映射到$[-1,1]$，这个过程我也不细说了，直接上结果：</p><script type="math/tex; mode=display">M_{projection}=\left(\begin{matrix}\frac{2}{r-l}&0&0&-\frac{r+l}{r-l}\\0&\frac{2}{t-b}&0&-\frac{t+b}{t-b}\\0&0&\frac{-2}{f-n}&-\frac{f+n}{f-n}\\0&0&0&1\end{matrix}\right)     \tag {33}</script><p>&emsp;&emsp;然后又因为视锥体关于$x$轴、$y$轴对称，简化的正交投影矩阵就为：</p><script type="math/tex; mode=display">M_{projection}=\left(\begin{matrix}\frac{2}{r-l}&0&0&0\\0&\frac{2}{t-b}&0&0\\0&0&\frac{-2}{f-n}&-\frac{f+n}{f-n}\\0&0&0&1\end{matrix}\right)     \tag {33}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4x4::setOrtho(<span class="keyword">float</span> left, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> top, <span class="keyword">float</span> near, <span class="keyword">float</span> far)</span><br><span class="line">&#123;</span><br><span class="line">    loadIdentity();</span><br><span class="line">    entries[<span class="number">0</span>]     =  <span class="number">2.0f</span>/(right-left);</span><br><span class="line">    entries[<span class="number">5</span>]     =  <span class="number">2.0f</span>/(top-bottom);</span><br><span class="line">    entries[<span class="number">10</span>]    = <span class="number">-2.0f</span>/(far-near);</span><br><span class="line">    entries[<span class="number">12</span>]    = -(right+left)/(right-left);</span><br><span class="line">    entries[<span class="number">13</span>]    = -(top+bottom)/(top-bottom);</span><br><span class="line">    entries[<span class="number">14</span>]    = -(far+near)/(far-near);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、lookAt函数构造视图矩阵"><a href="#4、lookAt函数构造视图矩阵" class="headerlink" title="4、lookAt函数构造视图矩阵"></a>4、lookAt函数构造视图矩阵</h2><p>&emsp;&emsp;视图矩阵的工作目标是将世界坐标系中的所有物体的顶点的坐标从世界坐标系转换到摄像机坐标系。这是因为摄像机坐标系的原点不一定与世界坐标系重合，同时由于自身的旋转，坐标轴也一定不与世界坐标系的坐标轴平行。为完成工作任务，需要分为两步走：首先整体平移，将摄像机平移至世界坐标系原点，然后将顶点从世界坐标系变换至摄像机坐标系。</p><p>&emsp;&emsp;lookAt函数的输入参数分别为：$eye$摄像机的位置，$target$摄像机目标点，$up$世界空间的上向量,。首先我们要根据这些参数确定摄像机坐标系的三个轴向量，<strong>其中需要非常注意的就是变换到视图空间中时摄像机是朝向视图空间的$-Z$方向的，所以求视图空间中的$Z$轴时是摄像机的位置减去目标点的位置</strong>：</p><script type="math/tex; mode=display">Z = normalize(eye - target)\\X = normalize(cross(up, Z))\\Y = normalize(cross(Z,X))</script><p>&emsp;&emsp;通过以上的方式我们就求出了视图空间的三条轴向量，再加上摄像机的位置我们就可以求出将世界坐标变换到与视图坐标重合的矩阵了，记为$M=T\cdot R$，其中$T$是平移到摄像机位置$eye$的变换矩阵，$R$是旋转到摄像机坐标轴方向的旋转矩阵：</p><script type="math/tex; mode=display">M=T\cdot R=\left[\begin{matrix}1&0&0&eye_x\\0&1&0&eye_x\\0&0&1&eye_x\\0&0&0&1\end{matrix}\right]\cdot\left[\begin{matrix}X_x&Y_x&Z_x&0\\X_y&Y_y&Z_y&0\\X_z&Y_z&Z_z&0\\0&0&0&1\end{matrix}\right] \tag {34}</script><p>&emsp;&emsp;<strong>然而公式$(34)$并不是我们要求的视图矩阵，上式中的矩阵$M$仅仅是将世界坐标轴变换到摄像机坐标轴。摄像机只是一个虚拟的物品，我们不能将上述的矩阵$M$作用于摄像机，因为摄像机根本不存在！我们视图矩阵最终作用的世界空间中的物体，这就涉及到了一个相对运动的概念！</strong></p><p>&emsp;&emsp;<strong>当我们向前移动摄像机的时候，可以看成是摄像机不动，而物体朝着与摄像机朝向相反的方向移动。当我们向右旋转摄像机时，相当于摄像机不动而物体朝着摄像机的左边移动。摄像机的构造得益于相对于运动的理论，计算机图形学中的虚拟$3D$摄像机实际上是通过物体的移动来实现的，所以我们要构造的视图矩阵是公式$(34)$中的逆矩阵。</strong></p><script type="math/tex; mode=display">viewMatrix = M^{-1}=(T\cdot R)^{-1}=R^{-1}\cdot T^{-1}=\left[\begin{matrix}X_x&Y_x&Z_x&0\\X_y&Y_y&Z_y&0\\X_z&Y_z&Z_z&0\\0&0&0&1\end{matrix}\right]^{-1}\cdot\left[\begin{matrix}1&0&0&eye_x\\0&1&0&eye_x\\0&0&1&eye_x\\0&0&0&1\end{matrix}\right]^{-1} \tag {35}</script><p>&emsp;&emsp;由上式可知，构造视图矩阵涉及到$R$和$T$的求逆，其中的平移矩阵$T$的求逆则是直接取平移量的相反数即可：</p><script type="math/tex; mode=display">T^{-1}=\left[\begin{matrix}1&0&0&eye_x\\0&1&0&eye_x\\0&0&1&eye_x\\0&0&0&1\end{matrix}\right]^{-1}=\left[\begin{matrix}1&0&0&-eye_x\\0&1&0&-eye_x\\0&0&1&-eye_x\\0&0&0&1\end{matrix}\right] \tag {36}</script><p>&emsp;&emsp;至于旋转矩阵$R$，我们知道旋转矩阵都是正交矩阵，正交矩阵的一个特点就是它的逆等于它的转置：</p><script type="math/tex; mode=display">R^{-1}=\left[\begin{matrix}X_x&Y_x&Z_x&0\\X_y&Y_y&Z_y&0\\X_z&Y_z&Z_z&0\\0&0&0&1\end{matrix}\right]^{-1}=\left[\begin{matrix}X_x&X_y&X_z&0\\Y_x&Y_y&Y_z&0\\Z_x&Z_y&Z_z&0\\0&0&0&1\end{matrix}\right] \tag {37}</script><p>&emsp;&emsp;最后，我们得到视图矩阵：</p><script type="math/tex; mode=display">viewMatrix=R^{-1}\cdot T^{-1}=\left[\begin{matrix}X_x&X_y&X_z&0\\Y_x&Y_y&Y_z&0\\Z_x&Z_y&Z_z&0\\0&0&0&1\end{matrix}\right]\cdot\left[\begin{matrix}1&0&0&-eye_x\\0&1&0&-eye_x\\0&0&1&-eye_x\\0&0&0&1\end{matrix}\right]\\=\left[\begin{matrix}X_x&X_y&X_z&-(\vec X\cdot \vec {eye})\\Y_x&Y_y&Y_z&-(\vec Y\cdot \vec {eye})\\Z_x&Z_y&Z_z&-(\vec Z\cdot \vec {eye})\\0&0&0&1\end{matrix}\right] \tag {38}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4x4::setLookAt(Vector3D cameraPos, Vector3D target, Vector3D worldUp)</span><br><span class="line">&#123;</span><br><span class="line">    Vector3D zAxis = cameraPos - target;</span><br><span class="line">    zAxis.normalize();</span><br><span class="line">    Vector3D xAxis = worldUp.crossProduct(zAxis);</span><br><span class="line">    xAxis.normalize();</span><br><span class="line">    Vector3D yAxis = zAxis.crossProduct(xAxis);</span><br><span class="line">    yAxis.normalize();</span><br><span class="line"></span><br><span class="line">    loadIdentity();</span><br><span class="line">    entries[<span class="number">0</span>] = xAxis.x;</span><br><span class="line">    entries[<span class="number">4</span>] = xAxis.y;</span><br><span class="line">    entries[<span class="number">8</span>] = xAxis.z;</span><br><span class="line"></span><br><span class="line">    entries[<span class="number">1</span>] = yAxis.x;</span><br><span class="line">    entries[<span class="number">5</span>] = yAxis.y;</span><br><span class="line">    entries[<span class="number">9</span>] = yAxis.z;</span><br><span class="line"></span><br><span class="line">    entries[<span class="number">2</span>] = zAxis.x;</span><br><span class="line">    entries[<span class="number">6</span>] = zAxis.y;</span><br><span class="line">    entries[<span class="number">10</span>] = zAxis.z;</span><br><span class="line"></span><br><span class="line">    entries[<span class="number">12</span>] = -(xAxis.dotProduct(cameraPos));</span><br><span class="line">    entries[<span class="number">13</span>] = -(yAxis.dotProduct(cameraPos));</span><br><span class="line">    entries[<span class="number">14</span>] = -(zAxis.dotProduct(cameraPos));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>$[1]$ <a href="http://www.songho.ca/opengl/gl_projectionmatrix.html" target="_blank" rel="noopener">http://www.songho.ca/opengl/gl_projectionmatrix.html</a></p><p>$[2]$ <a href="https://blog.csdn.net/zsq306650083/article/details/8773996" target="_blank" rel="noopener">https://blog.csdn.net/zsq306650083/article/details/8773996</a></p><p>$[3]$ <a href="https://blog.csdn.net/y1196645376/article/details/78463248" target="_blank" rel="noopener">https://blog.csdn.net/y1196645376/article/details/78463248</a></p><p>$[4]$ <a href="https://www.cnblogs.com/J1ac/p/9340622.html" target="_blank" rel="noopener">https://www.cnblogs.com/J1ac/p/9340622.html</a></p><p>$[5]$ <a href="https://learnopengl-cn.github.io/01 Getting started/08 Coordinate Systems/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Soft Renderer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> Soft Renderer </tag>
            
            <tag> 3D Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流体模拟Fluid Simulation：流体模拟基础</title>
      <link href="/2019/05/01/fluidSimulation/"/>
      <url>/2019/05/01/fluidSimulation/</url>
      
        <content type="html"><![CDATA[<p>本文主要参考文献《FLUID SIMULATION SIGGRAPH 2007 Course Notes》，结合我的理解单纯地讲述一下流体渲染的一些基础知识，本人水平有限，如有错误，欢迎指出。本文只是单纯针对流体模拟领域，可能一些地方不太严谨，但是对于虚拟模拟来说是可行的。即便如此，本文涉及到大量的数学方法。</p><a id="more"></a><ul><li>矢量微积分</li><li>Naiver-Stokes偏微分方程组</li><li>N-S方程的分步求解</li><li>对流算法</li></ul><h2 id="一、矢量微积分"><a href="#一、矢量微积分" class="headerlink" title="一、矢量微积分"></a>一、矢量微积分</h2><p>&emsp;&emsp;高等数学中太多数讨论的是一维的微积分，而矢量微积分则是一维微积分的高维扩展。矢量微积分的三个基础算子：<strong>梯度</strong>（符号为$∇$），<strong>散度</strong>（符号为$∇\cdot$)，<strong>旋度</strong>（符号为$∇\times$），在此基础上流体力学中经常用到的还有拉普拉斯算子。</p><h3 id="1、梯度（Gradient）"><a href="#1、梯度（Gradient）" class="headerlink" title="1、梯度（Gradient）"></a>1、梯度（Gradient）</h3><p>&emsp;&emsp;梯度实际上就是矢量的空间偏导数，且结果依然是一个矢量，$2$维的梯度如下：</p><script type="math/tex; mode=display">∇f(x,y)=(\frac{\partial f}{\partial x},\frac{\partial f}{\partial y}) \tag {1.1}</script><p>&emsp;&emsp;依此类推，$3$维的梯度有如下形式：</p><script type="math/tex; mode=display">∇f(x,y,z)=(\frac{\partial f}{\partial x},\frac{\partial f}{\partial y},\frac{\partial f}{\partial z}) \tag {1.2}</script><p>&emsp;&emsp;有时也会采用如下形式来表示梯度：</p><script type="math/tex; mode=display">∇f=\frac{\partial f}{\partial \vec x} \tag {1.3}</script><p>&emsp;&emsp;梯度通常用来近似计算函数值（实际上就是一维形式的推广)：</p><script type="math/tex; mode=display">f(\vec x+\Delta \vec x)\approx f(\vec x)+∇f(\vec x)\cdot \Delta \vec x \tag {1.4}</script><p>&emsp;&emsp;同样的，多个函数的梯度就构成了一个矩阵：</p><script type="math/tex; mode=display">∇\vec F=∇(f,g,h)=\left(   \begin{matrix}   \frac{\partial f}{\partial x} & \frac{\partial f}{\partial y} & \frac{\partial f}{\partial z} \\   \frac{\partial g}{\partial x} & \frac{\partial g}{\partial y} & \frac{\partial g}{\partial z} \\   \frac{\partial h}{\partial x} & \frac{\partial h}{\partial y} & \frac{\partial h}{\partial z} \\  \end{matrix}  \right)  =\left( \begin{matrix}∇f\\ ∇g\\ ∇h\\ \end{matrix}  \right) \tag {1.5}</script><h3 id="2、散度（Divergence）"><a href="#2、散度（Divergence）" class="headerlink" title="2、散度（Divergence）"></a>2、散度（Divergence）</h3><p>&emsp;&emsp;散度算子仅仅应用于向量场，它衡量在某一点出相应的矢量聚集或者发散程度，测量方向为<strong>径向</strong>，结果为标量。$2$维、$3$维形式的散度算子如下所示：</p><script type="math/tex; mode=display">∇\cdot \vec u=∇\cdot (u,v)=\frac{\partial u}{\partial x}+\frac{\partial v}{\partial y}</script><script type="math/tex; mode=display">∇\cdot \vec u=∇\cdot (u,v,w)=\frac{\partial u}{\partial x}+\frac{\partial v}{\partial y}+\frac{\partial w}{\partial z} \tag {1.6}</script><p>&emsp;&emsp;输入是矢量，而输出为标量。类比梯度，散度符号$∇\cdot \vec u$可以理解为梯度$∇$与矢量$\vec u$的点乘：</p><script type="math/tex; mode=display">∇\cdot \vec u=(\frac{\partial}{\partial x},\frac{\partial}{\partial y},\frac{\partial}{\partial z})\cdot (u,v,w)=\frac{\partial}{\partial x}u+\frac{\partial}{\partial y}v+\frac{\partial}{\partial z}w \tag {1.7}</script><p>&emsp;&emsp;若矢量场散度为$0$，则称该矢量场<strong>无散度</strong>。</p><h3 id="3、旋度（Curl）"><a href="#3、旋度（Curl）" class="headerlink" title="3、旋度（Curl）"></a>3、旋度（Curl）</h3><p>&emsp;&emsp;旋度衡量围绕某一点的旋转速度，测量方向为<strong>切向</strong>，三维形式的旋度是一个向量：</p><script type="math/tex; mode=display">∇\times \vec u=∇\times (u,v,w)=(\frac{\partial w}{\partial y}-\frac{\partial v}{\partial z},\frac{\partial u}{\partial z}-\frac{\partial w}{\partial x},\frac{\partial v}{\partial x}-\frac{\partial u}{\partial y}) \tag {1.8}</script><p>&emsp;&emsp;倒推到$2$维，我们取上式中的$w=0$，即矢量场为$(u,v,0)$，$2$维向量场的旋度是一个标量：</p><script type="math/tex; mode=display">∇\times \vec u=∇\times (u,v)=\frac{\partial v}{\partial x}-\frac{\partial u}{\partial y} \tag {1.9}</script><p>&emsp;&emsp;同样地，旋度符号$∇\times \vec u$我们可以理解为梯度$∇$与矢量场$\vec u$的叉乘：</p><script type="math/tex; mode=display">∇\times \vec u=(\frac{\partial }{\partial x},\frac{\partial }{\partial y},\frac{\partial }{\partial z})\times(u,v,w) \tag {1.10}</script><p>&emsp;&emsp;若矢量场旋度为$0$，则称该矢量场<strong>无旋度</strong>。</p><h3 id="4、拉普拉斯算子（Laplacian）"><a href="#4、拉普拉斯算子（Laplacian）" class="headerlink" title="4、拉普拉斯算子（Laplacian）"></a>4、拉普拉斯算子（Laplacian）</h3><p>&emsp;&emsp;拉普拉斯算子定义为梯度的散度，符号表示为$∇\cdot∇$，显然$∇\cdot$是散度，而后面的$∇$则为梯度，故拉普拉斯算子即梯度的散度，是一个二阶微分算子。$2$维、$3$维形式分别如下：</p><script type="math/tex; mode=display">∇\cdot∇f=\frac{\partial^2f}{\partial x^2}+\frac{\partial^2f}{\partial y^2}</script><script type="math/tex; mode=display">∇\cdot∇f=\frac{\partial^2f}{\partial x^2}+\frac{\partial^2f}{\partial y^2}+\frac{\partial^2f}{\partial z^2} \tag {1.11}</script><p>&emsp;&emsp;简言之，拉普拉斯算子定义如下：</p><script type="math/tex; mode=display">∇\cdot∇f=\Sigma_{i=1}^n\frac{\partial^2f}{\partial x_i^2} \tag {1.12}</script><p>&emsp;&emsp;偏微分方程$∇\cdot ∇f=0$被称为拉普拉斯方程；而如果右边为某个非$0$常数，即$∇\cdot ∇f=q$，我们称之为泊松方程。更一般地，如果梯度再乘上一个标量$a$（如$1/\rho$)，即$∇\cdot (a∇f)=q$，我们依旧称之为泊松问题。</p><h2 id="二、-Naiver-Stokes-偏微分方程组"><a href="#二、-Naiver-Stokes-偏微分方程组" class="headerlink" title="二、$Naiver-Stokes$偏微分方程组"></a>二、$Naiver-Stokes$偏微分方程组</h2><p>&emsp;&emsp;流体模拟器的构建主要围绕著名的不可压缩$Navier-Stokes$方程展开，它是一个流体力学领域的偏微分方程，方程形式如下：</p><script type="math/tex; mode=display">\frac{\partial \vec u}{\partial t}+\vec u\cdot ∇\vec u+\frac1\rho∇p=\vec g+\nu∇\cdot∇\vec u \tag {2.1}</script><script type="math/tex; mode=display">∇\cdot\vec u=0 \tag {2.2}</script><p>&emsp;&emsp;这个方程组看起非常地复杂，接下来我们就把它剖析成一个个比较简单的部分来理解。</p><h3 id="1、符号标记"><a href="#1、符号标记" class="headerlink" title="1、符号标记"></a>1、符号标记</h3><p>&emsp;&emsp;我们有必要定义一些物理量的符号用以标记：</p><p>&emsp;&emsp;符号$\vec u$在流体力学中通常表示为流体的速度矢量，记$3$维的速度矢量$\vec u=(u,v,w)$；</p><p>&emsp;&emsp;希腊字符$\rho$是流体的密度，对于水，该值大约为$1000kg/m^3$，而空气则大约为$1.3kg/m^3$；</p><p>&emsp;&emsp;字符$p$代表压力，流体对任何物体施加的单位面积力；</p><p>&emsp;&emsp;字符$\vec g$则是我们熟悉的重力加速度，通常取$(0,-9.81,0)m/s^2$。我们约定$y$轴向上，而$x$轴和$z$轴在水平面上。另外补充一点，我们把其他的一些类似的力都累加到$\vec g$上，也就是我们统一用$\vec g$表示所有类似力之和，这类力我们称之为<strong>体积力</strong>（称之为体积力是因为它们的力是作用到整个流体而不只是流体的表面）；</p><p>&emsp;&emsp;希腊字符$\nu$是流体的运动粘度，它衡量流体的黏滞性。糖蜜之类的流体有非常高的粘度，而像酒精之类的流体有很低的粘度；</p><p>&emsp;&emsp;其它一些矢量微积分的符号算子前面已经提到过，不再赘述。</p><h3 id="2、动量方程"><a href="#2、动量方程" class="headerlink" title="2、动量方程"></a>2、动量方程</h3><p>&emsp;&emsp;偏微分方程$(2.1)$我们称之为<strong>动量方程</strong>，它本质上就是我们熟悉的牛顿定律$\vec F=m\vec a$的形式，描述了施加在流体上的力是如何影响流体的运动。</p><p>&emsp;&emsp;假设我们用粒子系统来模拟流体，每个粒子代表流体的一小滴，每个粒子有各自的质量$m$、体积$V$和速度$\vec u$。为了让整个粒子系统运作起来，我们必须弄清楚每个粒子所承受的力的作用。牛顿第二定律告诉我们：$\vec F=m\vec a$，而根据加速度定义，我们有：</p><script type="math/tex; mode=display">\vec a=\frac{D\vec u}{Dt} \tag {2.3}</script><p>&emsp;&emsp;符号$D$是指<strong>物质导数</strong>，所谓物质导数，就是对流体质点求导数，而且是针对流体质点（在这里就是流体粒子）而不是空间的固定点。因而牛顿第二定律就变成：</p><script type="math/tex; mode=display">m\frac{D\vec u}{Dt}=\vec F \tag {2.4}</script><p>&emsp;&emsp;那么流体粒子承受的力有哪些呢？一个最简单的力就是重力：$m\vec g$。而其他的流体质点（或其他流体粒子）也会对当前的流体粒子产生作用力。流体内部的相互作用力之一便是压力，较大压力的区域会向较低压力区域产生作用力。值得注意的是，我们只关注施加在粒子上的压力的净合力。例如，若施加在粒子上压力在每个方向上都相等，那么它的压力的合力便为0。我们用压力的负梯度（取负是因为方向是由压力大的区域指向压力小的区域）来衡量在当前流体粒子处压力的不平衡性，即取$-∇p$。那么流体粒子所承受的压力就是对$-∇p$在整个流体粒子的体积上进行积分，为了简化，我们简单地将$V$与$-∇p$相乘，故粒子压力部分为$-V∇p$。</p><p>&emsp;&emsp;其他的流体相互作用力则是由流体的黏性产生的，我们直观地把这种力理解为尽可能使得粒子以周围区域的平均速度移动的力，也就是使得粒子的速度与周围区域粒子速度的差距最小化。拉普拉斯算子是衡量一个量与之周围区域该量平均值之差的算符，因而$∇\cdot∇\vec u$是当前粒子速度矢量与周围区域平均速度矢量之差。为了计算粘滞力，我们同样对$∇\cdot∇\vec u$在整个粒子体积$V$上进行积分，与前面类似，我们简单取$V∇\cdot∇\vec u$。除此之外，我们还引进一个称为动力粘度系数的物理量，符号为$\mu$。因而粘滞力为$V\mu∇\cdot∇\vec u$。</p><p>&emsp;&emsp;把重力、压力和粘滞力综合一起，我们可得：</p><script type="math/tex; mode=display">m\frac{D\vec u}{Dt}=\vec F=m\vec g-V∇p+V\mu∇\cdot∇\vec u \tag {2.5}</script><p>&emsp;&emsp;当粒子系统中的粒子数量趋于无穷大，而每个粒子大小趋于$0$时，会产生一个问题：此时每个粒子的质量$m$和体积$V$变为$0$，此时上式变得没有意义。为此，我们把$(2.5)$式调整一下，两边同除以体积$V$，又因$\rho=m/V$，故有：</p><script type="math/tex; mode=display">\rho\frac{D\vec u}{Dt}=\rho\vec g-∇p+\mu∇\cdot∇\vec u \tag {2.6}</script><p>&emsp;&emsp;两边同除以$\rho$，移项调整：</p><script type="math/tex; mode=display">\frac{D\vec u}{Dt}+\frac1\rho∇p=\vec g+\frac\mu\rho∇\cdot∇\vec u \tag {2.7}</script><p>&emsp;&emsp;为了进一步简化，定义运动粘度为$\nu=\mu/\rho$，式$(2.7)$变为：</p><script type="math/tex; mode=display">\frac{D\vec u}{Dt}+\frac1\rho∇p=\vec g+\nu∇\cdot∇\vec u \tag {2.8}</script><p>&emsp;&emsp;我们已经快把动量方程推导出来，现在我们要把物质导数$\frac{D\vec u}{Dt}$弄清楚，为此，我们需要了解两种描述方法：<strong>拉格朗日描述</strong>和<strong>欧拉描述</strong>。</p><h3 id="3、拉格朗日描述与欧拉描述"><a href="#3、拉格朗日描述与欧拉描述" class="headerlink" title="3、拉格朗日描述与欧拉描述"></a>3、拉格朗日描述与欧拉描述</h3><p>&emsp;&emsp;当我们尝试研究流体或可变形固体的运动的时候，通常有两种方法来描述：<strong>拉格朗日描述</strong>（ Lagrangian viewpoint）、<strong>欧拉描述</strong>（Eulerian viewpoint）。</p><p>&emsp;&emsp;拉格朗日描述方法是我们比较熟悉的方法，这种描述方法把物体看成是由类似于粒子系统的形式组成，固体或流体的每个点看作一个独立的粒子，粒子有各自相应的位置$\vec x$和速度$\vec u$。我们可以把粒子理解为组成物体的分子。对于我们通常采用拉格朗日描述法进行建模模拟，即用一系列离散的粒子集来构建，粒子之间通过网格相联系。</p><p>&emsp;&emsp;欧拉描述方法则采用了完全不同的角度，它常被用于流体力学中。与拉格朗日描述追踪每个物体粒子的方法不同，欧拉描述关注点是空间中的一个固定点，并考察在这个固定点上流体性质（如密度、速度、温度等）是如何随着时间变化的。流体流动经过这个固定点可能会导致这个固定点的物理性质发生一些变化（如一个温度较高的流体粒子流经这个固定点，后面紧跟着一个温度较低的流体粒子流过固定点，那么这个固定点的温度会降低，但是并没有任何一个流体粒子的温度发生了变化）。</p><p>&emsp;&emsp;用天气测量举个简单的例子：拉格朗日描述方法就是你乘坐在一个随风而飘的热气球上，测量周围空气的压力、密度和浑浊度等天气指标；而欧拉描述方法就是你固定在地面上，测量流过的空气的天气指标。</p><p>&emsp;&emsp;欧拉描述法似乎看起来带来了一些不必要的复杂度，但是目前大多数的流体模拟器都是基于欧拉描述法，这是因为欧拉描述法相比于拉格朗日描述法有一些不可比拟的优点：欧拉描述法能够更加方便地计算一些物理量的空间导数（例如压力梯度和粘度）；而如果用粒子方法的话（即拉格朗日描述法），那么计算物理量相对于空间位置的变化是比较难的。</p><p>&emsp;&emsp;把拉格朗日描述法和欧拉描述法联系起来的关键点就是物质导数。首先从拉格朗日描述法出发，假设有一群粒子，每个粒子都有各自的位置$\vec x$和速度$\vec u$。记$q$为通用的物理量（如密度、速度和温度等），每个粒子有其对应的$q$值。方程$q(t,\vec x)$描述在时间点$t$而位置为$\vec x$的粒子对应的物理量值$q$。则一个粒子的物理量$q$随时间$t$的变化率是多少？这是一个拉格朗日描述角度下的问题，我们取对时间$t$的导数（注意用到了求导链式法则，以及$\frac{\partial q}{\partial \vec x}=∇q$和$\vec u=\frac{d\vec x}{dt}）$：</p><script type="math/tex; mode=display">\frac d{dt}q(t,\vec x)=\frac{\partial q}{\partial t}+∇q\cdot\frac{d\vec x}{dt}=\frac{\partial q}{\partial t}+∇q\cdot\vec u\equiv\frac{Dq}{Dt} \tag {2.9}</script><p>&emsp;&emsp;这就是物质导数。把式$(2.9)$代入式$(2.8)$我们就得到了流体动量方程$(2.1)$。物质导数针对的是流体质点（在这里就是流体粒子）而不是空间的固定点。式$(2.9)$写完整一点就是：</p><script type="math/tex; mode=display">\frac{Dq}{Dt}=\frac{\partial q}{\partial t}+u\frac{\partial q}{\partial x}+v\frac{\partial q}{\partial y}+w\frac{\partial q}{\partial z} \tag {2.10}</script><p>&emsp;&emsp;对于给定的速度场$\vec u$， 流体的物理性质如何在这个速度场$\vec u$下变化的计算我们称之为<strong>对流</strong>（advection）。一个最简单的对流方程，就是其物理量的物质导数为$0$，如下所示：</p><script type="math/tex; mode=display">\frac{Dq}{Dt}=0\implies\frac{\partial q}{\partial t}+\vec u\cdot ∇q = 0 \tag {2.11}</script><p>&emsp;&emsp;公式$(2.11)$的意义即在拉格朗日视角观察下，每个流体粒子的物理量保持不变。</p><h3 id="4、不可压缩性"><a href="#4、不可压缩性" class="headerlink" title="4、不可压缩性"></a>4、不可压缩性</h3><p>&emsp;&emsp;关于流体的压缩性在此不做过多的物理细节描述，只需知道一点：通常情况下流体的体积变化非常小（除开一些极端的情况，而且这些极端情况我们日常生活中较少出现）。可压缩流体的模拟涉及到非常复杂的情况，往往需要昂贵的计算资源开销，为此在计算机流体模拟中我们通常把所有的流体当作是不可压缩的，即它们的体积不会发生变化。</p><p>&emsp;&emsp;任取流体的一部分，设其体积为$\Omega$而其边界闭合曲面为$\partial\Omega$，我们可以通过围绕边界曲面$\partial\Omega$对流体速度$\vec  u$在曲面法线方向上的分量进行积分来衡量这块部分流体的体积变化速率：</p><script type="math/tex; mode=display">\frac d{dt}Volume(\Omega)=\int\int_{\partial\Omega}\vec u\cdot n \tag{2.12}</script><p>&emsp;&emsp;对于不可压缩的流体，其体积保持为某个常量，故其体积变化速率为$0$：</p><script type="math/tex; mode=display">\int\int_{\partial\Omega}\vec u\cdot n=0 \tag {2.13}</script><p>&emsp;&emsp;由高斯散度定理，我们可以把式$(2.13)$转换为体积分：</p><script type="math/tex; mode=display">\int\int_{\partial\Omega}\vec u\cdot n=\int\int\int_\Omega∇\cdot \vec u=0 \tag{2.14}</script><p>&emsp;&emsp;式$(13)$应该对任意的$\Omega$成立，意即无论$\Omega$取何值，积分值均为$0$。这种情况下只有令积分函数值取$0$方可成立，即对$0$积分无论$\Omega$取何值结果均为$0$。所以有：</p><script type="math/tex; mode=display">∇\cdot \vec u=0 \tag{2.15}</script><p>&emsp;&emsp;这就是$Navier-Stokes$方程中的不可压缩条件$(2.2)$。满足不可压缩条件的速度场被称为是<strong>无散度</strong>的，即在该速度场下流体体积既不膨胀也不坍缩，而是保持在一个常量。模拟不可压缩流体的关键部分就是使得流体的速度场保持无散度的状态，这也是流体内部压力的来源。</p><p>&emsp;&emsp;为了把压力与速度场的散度联系起来，我们在动量方程$(2.1)$两边同时取散度：</p><script type="math/tex; mode=display">∇\cdot\frac{\partial \vec u}{\partial t}+∇\cdot(\vec u\cdot ∇\vec u)+∇\cdot\frac1\rho∇p=∇\cdot(\vec g+\nu∇\cdot∇\vec u) \tag {2.16}</script><p>&emsp;&emsp;对于上式$(2.16)$第一项，我们转变一下求导次序：</p><script type="math/tex; mode=display">\frac {\partial}{\partial t}∇\cdot\vec u \tag {2.17}</script><p>&emsp;&emsp;如果满足流体不可压缩条件，那么式$(2.17)$取值$0$（因为无散度），然后我们调整一下式$(2.16)$可得关于压力的方程：</p><script type="math/tex; mode=display">∇\cdot\frac1\rho∇p=∇\cdot(-\vec u\cdot ∇\vec u+\vec g+\nu∇\cdot∇\vec u) \tag{2.18}</script><h3 id="5、丢弃粘度项"><a href="#5、丢弃粘度项" class="headerlink" title="5、丢弃粘度项"></a>5、丢弃粘度项</h3><p>&emsp;&emsp;在某些流体如蜂蜜、小水珠等的模拟中，粘滞力起着非常重要的作用。但是在大多数流体动画模拟中，粘滞力的影响微乎其微，为此秉持着方程组越简单越好的原则，我们常常丢弃粘度项。当然这也不可避免地带来一些误差，事实上，在计算流体力学中尽可能地减少丢弃粘度项带来的误差是一个非常大的挑战。下面的叙述都是基于丢弃粘度项的前提。</p><p>&emsp;&emsp;丢弃了粘度项的$Navier-Stokes$方程被称为<strong>欧拉方程</strong>，而这种理想的流体则是<strong>无粘度</strong>的。丢弃了粘度项的欧拉方程如下：</p><script type="math/tex; mode=display">\frac{D\vec u}{Dt}+\frac1\rho∇p=\vec g \tag {2.19}</script><script type="math/tex; mode=display">∇\cdot\vec u=0 \tag{2.20}</script><p>&emsp;&emsp;<strong>大多数的流体模拟的计算方程都是欧拉方程。</strong></p><h3 id="6、边界条件"><a href="#6、边界条件" class="headerlink" title="6、边界条件"></a>6、边界条件</h3><p>&emsp;&emsp;目前为止我们讨论的都是流体内部的情况，然而边界部分也是流体模拟非常关键的部分。在流体模拟中我们仅仅关注两种边界条件：<strong>固体墙</strong>（solid walls）、<strong>自由面</strong>（free surfaces）。</p><p>&emsp;&emsp;<strong>固体墙</strong>顾名思义就是流体与固体接触的边界，用速度来描述很简单：流体既不会流进固体内部也不会从固体内部流出，因此流体在固体墙法线方向上的分量为$0$：</p><script type="math/tex; mode=display">\vec u\cdot n=0 \tag {2.21}</script><p>&emsp;&emsp;当然，上述是固体自身不移动的情况下。通常来说，流体速度在法线方向上的分量与固体的移动速度在法线方向上的分量应该保持一致：</p><script type="math/tex; mode=display">\vec u\cdot n=\vec u_{solid}\cdot n \tag{2.22}</script><p>&emsp;&emsp;上述的两个公式都是仅对流体速度在法线方向上的分量做了限制，对于无粘度的流体，切线方向上的流体速度与固体的移动速度无必然的联系。</p><p>&emsp;&emsp;<strong>自由面</strong>是另外一个非常重要的边界条件，它通常就是与另外一种流体相接壤的边界部分。例如在模拟水花四溅时，水流表面不与固体接触的都是自由面（如与空气这种流体接触）。因空气密度远小于水导致空气对水体的仿真影响非常小，为了简化模拟，我们将空气所占的空间设为某个固定大气压的区域，设为$0$是最方便的方案，此时自由面就是压强$p=0$的水体表面。</p><p>&emsp;&emsp;在小规模的流体仿真中，自由面的表面张力占据着非常重要的地位。在微观分子层面下，表面张力的存在是因为不同的分子相互吸引产生的力。从几何的角度来解释就是，表面张力就是促使流体的表面积尽可能小的一种力。物理学上，两种不同的流体之间实际上存在着与表面平均曲率成正比的压力骤变：</p><script type="math/tex; mode=display">[p]=\lambda k. \tag {2.23}</script><p>&emsp;&emsp;公式$(2.23)$中的$[p]$记为压力之差。$\lambda$是表面张力系数，可以根据模拟的流体类型查找对应的张力系数（例如空气与水在室温下张力系数为$\lambda \approx 0.073N/m$）。而$k$就是平均曲率，单位为$m^{-1}$。又因为我们常常设空气的压力为$0$，因此水与空气交界的自由面的压力为：</p><script type="math/tex; mode=display">p=\lambda k \tag {2.24}</script><p>​        </p><h2 id="三、N-S方程的分步求解"><a href="#三、N-S方程的分步求解" class="headerlink" title="三、N-S方程的分步求解"></a>三、N-S方程的分步求解</h2><p>&emsp;&emsp;有了对以上对$Navier-Stokes$方程的理论支撑，接下来我们就要如何用计算机来对该组偏微分方程进行离散化求解。为了程序的松耦合性以及使计算尽可能地高效、简单，在流体模型领域，我们将流体方程分成几个独立的步骤，然后按顺序先后推进。对于不可压缩的无粘度流体方程（即前面的欧拉方程$(2.19)$和$(2.20)$，我们将其离散化成对流项（advection）如公式$(3.1)$、体积力项（body force）如公式$(3.2)$、压力/不可压缩项如公式$(3.3)$：</p><script type="math/tex; mode=display">\frac{Dq}{Dt}=0 \tag {3.1}</script><script type="math/tex; mode=display">\frac{\partial \vec u}{\partial t}=\vec g \tag {3.2}</script><script type="math/tex; mode=display">\begin{cases}\frac{\partial \vec u}{\partial t}+\frac{1}{\rho}∇p=0\\∇\cdot\vec u=0\end{cases} \tag {3.3}</script><p>&emsp;&emsp;需要注意的是，在对流项公式$(3.1)$中我们用了一个通用量的符号$q$是因为我们不仅仅要对流体的速度进行对流，还需要对其他物理量进行对流。我们记对流项公式$(3.1)$的对流计算算法为$advect(\vec u, \Delta t, q)$，即对于给定的时间步长$\Delta t$和速度场$\vec u$，对物理量q进行对流。</p><p>&emsp;&emsp;对于体积力项$(3.2)$，我们采用简单的前向欧拉法即可：$\vec u \leftarrow \vec u + g\Delta t$。</p><p>&emsp;&emsp;对于压力/不可压缩项$(3.3)$，我们用一个称为$project(\Delta t, \vec u)$的算法，通过$project(\Delta t, \vec u)$计算出正确的压力以确保速度场$\vec u$的无散度性质。欧拉方案不会着重研究具体粒子间的作用力，因而不会正向去求解$\frac{1}{\rho}∇p$，它是利用流体不可压缩的特性，将速度场$\vec u$投影到散度为$0$的空间上，间接地解算了压力项。这种思想相当于，已知一个中间量$\vec u_{temp}$，对这个中间量的唯一一个操作（如正向求解压力$\frac{1}{\rho}∇p$）不可行，但是直到最终量$\vec u_{fianl}$符号的一个性质（散度为$0$），于是只要将$\vec u_{temp}$投影到符合散度为$0$的特性平面上，即可间接地还原正向求解压力的操作，得到最终的速度场$\vec u_{temp}$。</p><p>&emsp;&emsp;对流项$advect(\vec u, \Delta t, q)$的输入速度场$\vec u$要确保为无散度的状态，投影项$project(\Delta t, \vec u)$确保了流体体积保持不变，因而投影项输出的速度场必然是无散度的。所以我们只要确保投影项$project(\Delta t, \vec u)$输出的速度场$\vec u$作为对流项$advect(\vec u, \Delta t, q)$的输入即可，这时我们的分步求解流体方程的优势就体现出来了，其伪代码如下所示。</p><hr><p><strong>算法1 Fluid Simulation($\vec u_n$, $\Delta t$):</strong></p><hr><p><strong>1:  初始化速度场$\vec u_n$,使得$\vec u_n$无散度 </strong></p><p><strong>2:  对于每个时间步$n = 0,1,2,…$</strong></p><p><strong>3: &emsp;&emsp;决定一个合理的时间步长$\Delta t = t_{n+1}-t_n$ </strong></p><p><strong>4: &emsp;&emsp;对流项计算$\vec u_A=advect(\vec u_n,\Delta t,\vec q)$ </strong></p><p><strong>5: &emsp;&emsp;体积力项计算$\vec u_B=\vec u_A+\Delta t\vec g$</strong></p><p><strong>6:  &emsp;&emsp;无散度投影$\vec u_{n+1}=project(\Delta t,\vec u_B)$ </strong></p><hr><h3 id="1、时间步长"><a href="#1、时间步长" class="headerlink" title="1、时间步长"></a>1、时间步长</h3><p>&emsp;&emsp;在流体模拟算法中，确定适当的时间步长是算法的第一步。因为计算流体模拟的最后结果是呈现在屏幕上的，所以$\Delta t$的选取与屏幕的刷新率有重要的关系。若选取的$\Delta t$有$t_n+\Delta t &gt; t_{frame}$，那么必须做一个截断使$\Delta t=t_{frame}-t_n$。此外，流体模拟的三个步骤即对流项、体积力项、无散度投影项对时间步长$\Delta t$的要求不尽相同，要选择一个满足所有要求的最小时间步长能确保计算的收敛性。此外，一方面为了流体模拟的真实性，我们可能需要选取一个足够小的时间步长来复现流体的高质量细节。另一方面，有时高性能的需求又使得我们不能选取太小的时间步长去渲染一帧。假设一帧至少要进行三个时间步的模拟，那么$\Delta t$应该至少设成帧间隔时间的三分之一。</p><h3 id="2、网格结构"><a href="#2、网格结构" class="headerlink" title="2、网格结构"></a>2、网格结构</h3><p>&emsp;&emsp;欧拉法的整个流程都是基于网格的，所以合理的网格结构是算法高效的关键点。$Harlow$和$Welch$提出了一种经典的$MAC$（marker and cell）网格结构，许多不可压缩流体模拟的算法都在这个网格结构上呈现出了良好的效率。$MAC$网格是一种交叉排列的网格，不同类型的物理量被存储于网格的不同位置。以二维的网格为例，如图3-1左图所示，流体粒子的压力数据存储于网格的中心点$P_{i,j}$，而速度则沿着笛卡尔坐标被分成了两部分。水平方向的$u$成分被存储在了网格单元竖直边的中心处，例如网格单元$(i,j)$和$(i+1,j)$之间的水平速度记为$u_{i+1/2,j}$。垂直方向的$v$成分则被存储在了网格单元水平面的中心上。这样的存储方案十分有利于估算流体流进/流出某个网格单元的量。</p><p><figure class="half">    <img src="assets/1555851524585.png">    <img src="assets/1555851793961.png"></figure></p><p><center>图3-1 MAC网格,左图二维,右图三维</center><br>&emsp;&emsp;扩展到三维的情况，$MAC$网格同样是交错排列的结构网格，如图3-1右图所示。压力数值存储在立方体网格单元的中心，三个速度分量分别被记录在立方体网格单元的三个表面的中心点上。在数值计算时，这样的分配方式使得我们可以准确地采用中心差分法计算压力梯度和速度的散度，同时克服了中心差分法的一个普遍的缺点。一维的情况为例，在网格顶点位置$…,q_{i-1},q_i,q_{i+1}…$上估算量场$q$的导数，为了无偏（所谓无偏，就是不偏向左边或者右边）估计网格顶点$i$处的$\frac{\partial q}{\partial x}$，一种比较自然的方式就是采用一阶中心差分法：</p><script type="math/tex; mode=display">(\frac{\partial q}{\partial x})_i\approx \frac{q_{i+1}-q_{i-1}}{2\Delta x} \tag {3.4}</script><p>&emsp;&emsp;公式$(3.4)$是无偏的，且精确度为$O(\Delta x^2)$。而前向欧拉差分法偏向右边且精确度只有$O(\Delta x)$：</p><script type="math/tex; mode=display">(\frac{\partial q}{\partial x})_i\approx \frac{q_{i+1}-q_i}{\Delta x} \tag {3.5}</script><p>&emsp;&emsp;然而，公式$(3.4)$存在着一个非常严重的问题：网格点$i$的估算导数完全忽略了$q_i$的值。数学上，只有常数函数的一阶导数为零。但是公式$(3.4)$遇到了锯齿函数如$q_i=(-1)^i$时，它错误地将该类函数的导数估算为$0$，这种问题被称为零空间问题（null-space problem）。</p><p>&emsp;&emsp;交叉错排的$MAC$网格完美地克服了中心差分法的零空间问题，同时也保持了它的无偏二阶精度。在$MAC$网格上运用中心差分法，网格点$i$处的估算导数公式如下所示：</p><script type="math/tex; mode=display">(\frac{\partial q}{\partial x})_i\approx\frac{q_{i+1/2}-q_{i-1/2}}{\Delta x} \tag {3.6}</script><p>&emsp;&emsp;$MAC$网格确实给流体的压力计算和不可压缩性的处理带来了很大的便利，但与此同时也带来了一些其他方面的麻烦。如果我们要估算某个地方的速度向量，即便采样点恰好在网格点上我们也要做一些插值才能获取相应的速度向量。在网格点处，我们通常采用平均法，以二维为例：</p><script type="math/tex; mode=display">\vec u_{i,j}=(\frac{u_{i-1/2,j}+u_{i+1/2,j}}{2},\frac{v_{i,j-1/2}+v_{i,j+1/2}}{2}),\\\vec u_{i+1/2,j}=(u_{i+1/2,j},\frac{v_{i,j-1/2}+v_{i,j+1/2}+v_{i+1,j-1/2}+v_{i+1,j+1/2}}{4}),\\\vec u_{i,j+1/2}=(\frac{u_{i-1/2,j}+u_{i+1/2,j}+u_{i-1/2,j+1}+u_{i+1/2,j+1}}{4},v_{i,j+1/2}).\tag {3.7}</script><p>&emsp;&emsp;最后，在实现中下标索引一般没有浮点数之说，前面直接采用$i+1/2$的记法是为了便于叙述。一般约定如下：</p><script type="math/tex; mode=display">p(i,j,k)=p_{i,j,k},\\u(i,j,k)=u_{i-1/2,j,k},\\v(i,j,k)=v_{i,j-1/2,k},\\w(i,j,k)=w_{i,j,k-1/2}. \tag{3.8}</script><p>&emsp;&emsp;因而对于$nx\times ny\times nz$分辨率的网格，压力数值存储在$nx\times ny\times nz$的数组中，速度的$u$成分存储在$(nx+1)\times ny\times nz$数组中，速度的$v$成分存储在$nx\times (ny+1)\times nz$数组中，速度的$w$成分存储在$nx\times ny\times (nz+1)$数组中。</p><h2 id="四、对流算法"><a href="#四、对流算法" class="headerlink" title="四、对流算法"></a>四、对流算法</h2><p>&emsp;&emsp;求解如下所示的对流方程是流体模拟的关键一步：</p><script type="math/tex; mode=display">\frac{Dq}{Dt}=0 \tag {4.1}</script><p>&emsp;&emsp;我们把这个对流数值计算的算法记为：</p><script type="math/tex; mode=display">q^{n+1}=advect(\vec u,\Delta t,q^n) \tag {4.2}</script><p>&emsp;&emsp;公式$(4.2)$中的各个符号含义：</p><p>&emsp;&emsp;$\vec u$：在$MAC$网格上的离散化的速度场；</p><p>&emsp;&emsp;$\Delta t$：时间步长；</p><p>&emsp;&emsp;$q^n$：当前的物理量场$q$（如流体密度、速度、燃烧物浓度等）；</p><p>&emsp;&emsp;$q^{n+1}$：经过对流后得到的新的量场。</p><p>&emsp;&emsp;在这里要特别注意，输入对流算法的速度场$\vec u$必须是无散度的，否则模拟结果会出现一些奇怪的失真现象。</p><h3 id="1、半拉格朗日对流算法（Semi-Lagrangian-Advection）"><a href="#1、半拉格朗日对流算法（Semi-Lagrangian-Advection）" class="headerlink" title="1、半拉格朗日对流算法（Semi-Lagrangian Advection）"></a>1、半拉格朗日对流算法（Semi-Lagrangian Advection）</h3><p>&emsp;&emsp;一维情况下，对流方程$(4.1)$写成偏微分的形式如下：</p><script type="math/tex; mode=display">\frac{\partial q}{\partial t}+u\frac{\partial q}{\partial x}=0 \tag {4.3}</script><p>&emsp;&emsp;分别采用前向欧拉差分法计算对时间的偏导和中心差分法计算对空间的偏导，我们有：</p><script type="math/tex; mode=display">\frac{q^{n+1}_{i}-q^n_i}{\Delta t}+u^n_i\frac{q^n_{i+1}-q^n_{i-1}}{2\Delta x}=0 \tag {4.4}</script><p>&emsp;&emsp;转成以$q^{n+1}_i$为计算目标的显式公式，得：</p><script type="math/tex; mode=display">q^{n+1}_i=q^n_i-\Delta t u^n_i\frac{q^n_{i+1}-q^n_{i-1}}{2\Delta x} \tag {4.5}</script><p>&emsp;&emsp;公式$(4.5)$看起来没什么问题，但是却存在非常严重的漏洞。首先，前向欧拉法被证明是无条件不稳定的空间离散方法：无论取多么小Δ𝑡，随着时间步的推进，累积误差终将发散。即使使用更稳定的时间积分方法来取代前向欧拉方法，解决了时间上的PDE（Partial Differential Equation，偏微分方程）计算，空间上的PDE计算还是会带来重大的麻烦。标准中心差分方法不可避免地会出现的零空间问题，具有高频震荡性质的速度场对空间的导数被错误地计算为$0$或几乎为$0$，低离速度分量被分离出来，从而导致模拟效果中出现许多奇怪的高频摆动和震荡。</p><p>&emsp;&emsp;针对这些问题，研究者们提出了一个解然不同的、更加简单和更具物理直观意义的半拉格朗日法。之所以叫半拉格朗日法，是因为这种方法是以拉格朗日视角去解决欧拉视角的对流方程（“半”字的由来）。假设我们的目标是求解网格点$\vec x_G$的在第$n+1$个时间步时关于物理量$q$的新值，记为$q^{n+1}_G$。在拉格朗日的视角下，我们可以寻找在第$n+1$时间步之前，是空间中的哪一个点上的流体粒子在速度场$\vec u$的作用下“流向”了$\vec x_G$，我们记这个粒子在第$n$个时间步时的网格位置为$\vec x_P$，则第$n+1$个时间步时$\vec x_G$的$q^{n+1}_G$即为第$n$个时间步时$\vec x_P$的$q^{n}_P$。如下图4-1为半拉格朗日对流法的示意图。</p><p><img src="assets/1555901521756.png" alt="1555901521756"></p><p><center>图4-1 半拉格朗日对流法</center><br>&emsp;&emsp;半拉格朗日对流法的第一步就是要找出$\vec x_P$，为此我们根据$\vec x_G$做反向的追踪。粒子位置对时间的导数就是速度场：</p><script type="math/tex; mode=display">\frac{d\vec x}{dt}=\vec u(\vec x) \tag {4.6}</script><p>&emsp;&emsp;经过一个时间步长$\Delta t$之后，粒子由$\vec x_P$移动到$\vec x_G$。为了得到$\vec x_P$，最简单的方法就是采用前向欧拉法进行倒推：</p><script type="math/tex; mode=display">\vec x_P=\vec x_G-\Delta t\vec u(\vec x_G) \tag {4.7}</script><p>&emsp;&emsp;然而前向欧拉法只有一阶的精度，若在不改变$\Delta t$的情况下提高精度，我们可以采用高阶的龙格库塔法（Runge-Kutta method）。采用二阶的龙格库塔法如下所示：</p><script type="math/tex; mode=display">\vec x_{mid}=\vec x_G-\frac12\Delta t\vec u(\vec x_G),\\\vec x_P=\vec x_G-\Delta t\vec u(\vec x_{mid}). \tag {4.7}</script><p>&emsp;&emsp;倒推得到$\Delta  t$之前的网格位置$\vec x_P$一般不会恰好在网格顶点上，为此我们需要做些插值。三维模拟通常采用三线性插值，而二维的则采用双线性插值。</p><script type="math/tex; mode=display">q^{n+1}_G=interpolate(q_n,\vec x_P) \tag {4.8}</script><h3 id="2、边界情况"><a href="#2、边界情况" class="headerlink" title="2、边界情况"></a>2、边界情况</h3><p>&emsp;&emsp;若我们倒推得到的$\vec x_P$仍然在流体的内部，那么做插值是完全没问题的。但若$\vec x_P$在流体的边界之外呢？这种情况的出现的原因通常有两个：一个是$\vec x_P$确确实实在流体的外部且即将流入流体内部，另一个是由前向欧拉法或龙格库塔法的数值计算方法带来的误差导致。</p><p>&emsp;&emsp;在一种情况下，我们应该知道当流体流入时其携带的物理量，此时我们将这个外部流入的物理量作为返回值即可。例如，第$n$个时间步时的外部流体以速度$\vec U$和温度$T$在第$n+1$个时间步时注入流体内部$\vec x_G$的位置，那么$\vec T^{n+1}_G$的值就为$T$。</p><p>&emsp;&emsp;在第二种由误差导致的情况下，一个适当的策略就是根据边界上的最近点外推出所求得物理量。在模拟某些流体时，外推变得很简单。例如，在模拟烟雾时我们简单地假设烟雾流体外部即空气的速度风场为某个常数$\vec U$（可能为$0$），这样边界上的速度场都取$\vec U$。但还有一些必须根据流体内部的已知量外推出未知量，这时情况就变得比较复杂了。具体如何外推将在后面介绍，目前我们只需要知道大概的步骤：首先寻找边界上的最近点，然后在最近点的领域内插值获取相应的物理量场。</p><h3 id="3、时间步长大小"><a href="#3、时间步长大小" class="headerlink" title="3、时间步长大小"></a>3、时间步长大小</h3><p>&emsp;&emsp;对任何一种数值计算方法的主要的考虑点就是它是否稳定。幸运的是，<strong>半拉格朗日对流法已经被证明是一种无条件稳定的算法</strong>：无论$\Delta t$取多大，它永远不会出现数值爆炸的现象。因为每一个新值$q$的确定，都是通过对旧值得插值，无论是线性插值、双线性插值还是三线性插值，$q$的大小都是处于插值点之间，不会得到比原来插值点更大或者更小的值，因而$q$是有上下界的。这使得我们可以尽情地根据所需的模拟质量和模拟效率去调整时间步长。</p><p>&emsp;&emsp;但是在实践中，时间步长的大小也不能选得太过极端，否则会产生一些奇观的现象。Foster和Fekiw提出了一个对$\Delta t$的限制：流体粒子在$\Delta t$内的倒推轨迹最多经过某个常数个网格单元为宜，例如5个：</p><script type="math/tex; mode=display">\Delta t \leq \frac{5\Delta x}{u_{max}} \tag {4.9}</script><p>&emsp;&emsp;公式$(4.9)$中，$u_{max}$是速度场的最大值，我们可以简单地取 存储在网格中的最大速度值。一个更鲁棒的方法考虑了体积力（如重力、浮力等）对最大速度的影响：</p><script type="math/tex; mode=display">u_{max}=max(|u^n|)+\Delta t|g| \tag {4.10}</script><p>&emsp;&emsp;将不等式$(4.9)$的最大值带入公式$(4.10)$，我们有：</p><script type="math/tex; mode=display">u_{max}=max(|u^n|)+\frac{5\Delta x}{u_{max}}|g| \tag {4.11}</script><p>&emsp;&emsp;取一个简单的速度上界（简化了公式$(4.11)$），$u_{max}$：</p><script type="math/tex; mode=display">u_{max}=max(|u^n|)+\sqrt{5\Delta xg} \tag {4.12}</script><p>&emsp;&emsp;这样确保了$u_{max}$始终为正，且避免公式$(4.9)$的除$0$错误。</p><p>&emsp;&emsp;关于时间步长的讨论离不开$CFL$（以Courant、Friedrichs、Lewy三人的名字命名）条件。$CFL$条件是一个简单而直观的判断计算是否收敛的必要条件。它的直观物理解释就是时间推进求解的速度必须大于物理扰动传播的速度，只有这样才能将物理上所有的扰动俘获到。满足$CFL$条件意味着当$\Delta x$和$\Delta t$趋于取极限$0$时，数值计算所求的解就会收敛到原微分方程的解。</p><p>&emsp;&emsp;对于半拉格朗日对流法，其满足$CFL$条件当且仅当在极限情况下，追踪得到的粒子轨迹足够逼近真实的轨迹。足够逼近的意思是经过正确的网格插值能够得到正确的依赖域（即差分格式的依赖域包含了原微分方程的依赖域），追踪的轨迹就会收敛到正确真实的轨迹。</p><p>&emsp;&emsp;因而，对于采用标准的显式有限差分法的对流方程求解，为了保证收敛，我们要求$q^{n+1}$的新值是由以当前网格点为中心、以$C\Delta x$（$C$是一个小的整数常量）为半径的邻域范围内插值得到：</p><script type="math/tex; mode=display">\Delta t \leq C\frac{\Delta x}{|\vec u|} \tag {4.13}</script><p>&emsp;&emsp;公式$(4.13)$中的$C$被称为$CFL$数，因而不等式$(4.9)$可以看成是公式$(4.13)$取$CFL$数为$5$得到。</p><h3 id="4、数值耗散"><a href="#4、数值耗散" class="headerlink" title="4、数值耗散"></a>4、数值耗散</h3><p>&emsp;&emsp;对流算法在对流获取新的物理量场$q^{n+1}_i$时会进行一些插值操作，插值不可避免地会平滑物理量场，这带来了一些数值耗散。一次两次的数值耗散不会由太大的影响，但是在流体模拟中我们会在每个时间步都进行对流运算，反反复复的平滑操作将数值耗散不断扩大，损失大量的流体细节。</p><p>&emsp;&emsp;以一维的对流项计算为例，流体速度为常量$u&gt;0$：</p><script type="math/tex; mode=display">\frac{\partial q}{\partial t}+u\frac{\partial q}{\partial x}=0 \tag {4.14}</script><p>&emsp;&emsp;假设$\Delta t &lt; \frac{\Delta x}{u}$，即单个时间步长内粒子追踪轨迹长度小于单个网格单元的大小。我们的目标点是$x_i$，则倒推得到的粒子位置就落在了$[x_{i-1},x_i]$上的$x_i-\Delta tu$，然后进行线性插值得到$q^{n+1}_i$：</p><script type="math/tex; mode=display">q^{n+1}=\frac{\Delta tu}{\Delta x}q^n_{i-1}+(1-\frac{\Delta tu}{\Delta x})q^n_i \tag {4.15}</script><p>&emsp;&emsp;将公式$(4.15)$整理一下，有：</p><script type="math/tex; mode=display">q^{n+1}_i=q^n_i-\Delta tu\frac{q^n_i-q^n_{i-1}}{\Delta x} \tag {4.16}</script><p>&emsp;&emsp;公式$(4.16)$实际上正好就是采用时间上的前向欧拉差分法和空间上的单向有限差分法的欧拉方案，把$q^n_i$看成是$q^n$关于$x_i$的函数，对$q^n_{i-1}$进行泰勒级数展开：</p><script type="math/tex; mode=display">q^n_{i-1}=q^n_i-(\frac{\partial q}{\partial x})^n_i\Delta x+(\frac{\partial^2q}{\partial x^2})^n_i\frac{\Delta x^2}{2}+O(\Delta x^3) \tag {4.17}</script><p>&emsp;&emsp;将公式$(4.17)$代入公式$(4.16)$，并做一些变量消去，可得：</p><script type="math/tex; mode=display">q^{n+1}_i=q^n_i-\Delta tu(\frac{\partial q}{\partial x})^n_i+\Delta tu\Delta x(\frac{\partial^2q}{\partial x^2})^n_i+O(\Delta x^2) \tag {4.18}</script><p>&emsp;&emsp;在二阶截断误差的情况下，结合公式$(4.18)$和公式$(4.14)$，有：</p><script type="math/tex; mode=display">\frac{\partial q}{\partial t}+u\frac{\partial q}{\partial x}=u\Delta x(\frac{\partial^2q}{\partial x^2}) \tag {4.19}</script><p>&emsp;&emsp;右边就是对流方程计算时引入的额外类似粘度乘上系数$u\Delta x$的项。<strong>这也就是说，当我们采用简单的半拉格朗日法去求解无粘度的对流方程时，模拟的结果却看起来我们像时在模拟有粘度的流体。这就是数值耗散！</strong>当然，当$\Delta x\to 0$时，这个数值耗散系数也会趋于$0$，所以取时间步无穷小时能够得到正确的模拟结果，但这需要耗费巨额的计算资源开销。我们通常模拟的流体大多数都是无粘度的，所以如何减少这个数值耗散是个至关重要的难题。</p><p>&emsp;&emsp;一个简单有效的修复数值耗散的方法就是采用更加锐利的插值方法，从而尽可能地减少由插值带来的数值耗散。在一维的情况时，我们采用三次插值（cubic interpolant）如下公式$(4.21)$，而不是简单的一次线性插值$(4.20)$：</p><script type="math/tex; mode=display">q\approx(1-s)x_i+sx_{i+1} \tag {4.20}</script><script type="math/tex; mode=display">q\approx[-\frac13s+\frac12s^2-\frac16s^3]q_{i-1}+[1-s^2+\frac12(s^3-s)]q_i\\+[s+\frac12(s^2-s^3)]q_{i+1}+[\frac16(s^3-s)]q_{i+2} \tag {4.21}</script><p>&emsp;&emsp;扩展到二维或者三维就是双三次插值（bicubic interpolation）或三三次插值（tricubic interpolation）。以二维情况为例，我们可以先沿着$x$轴做第一遍的三次插值如公式$(4.22)$，然后再沿着$y$轴做第二遍插值如公式$(4.23)$：</p><script type="math/tex; mode=display">q_{j-1}=w_{-1}(s)q_{i-1,j-1}+w_0(s)+q_{i,j-1}+w_1(s)q_{i+1,j-1}+w_2(s)q_{i+2,j-1},\\q_{j}=w_{-1}(s)q_{i-1,j}+w_0(s)+q_{i,j}+w_1(s)q_{i+1,j}+w_2(s)q_{i+2,j},\\q_{j+1}=w_{-1}(s)q_{i-1,j+1}+w_0(s)+q_{i,j+1}+w_1(s)q_{i+1,j+1}+w_2(s)q_{i+2,j+1},\\q_{j+2}=w_{-1}(s)q_{i-1,j+2}+w_0(s)+q_{i,j+2}+w_1(s)q_{i+1,j+2}+w_2(s)q_{i+2,j+2}. \tag {4.22}</script><script type="math/tex; mode=display">q=w_{-1}(t)q_{j-1}+w_0(t)q_j+w_1(t)q_{j+1}+w_2(t)q_{j+2} \tag {4.23}</script><p>&emsp;&emsp;当然也可以先沿着$y$轴，然后再沿着$x$轴做插值操作。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Fluid Simulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> Fluid Simulation </tag>
            
            <tag> Naiver-Stokes Equations </tag>
            
            <tag> Advection </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

{"meta":{"title":"YangWC's Blog","subtitle":null,"description":"Personal blog website.","author":"WC Yang","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"L-系统语法规则构建三维分形树","slug":"LSystem","date":"2019-04-25T12:42:49.161Z","updated":"2019-04-27T07:03:09.058Z","comments":true,"path":"2019/04/25/LSystem/","link":"","permalink":"http://yoursite.com/2019/04/25/LSystem/","excerpt":"本次我将带来L系统构建分形树的实现。树一直都是虚拟室外景观中非常重要的一部分。目前模拟树的方法有很多，其中最为廉价的就是公告牌了，用一个2D的平面去仿造三维立体的效果，在以前显卡还不强力的时候这是个不错的选择，即使是现在也有用武之地。还有通过三维建模工具建立的三维模型，这些三维模型非常逼真，但是有个非常大的缺点，就是顶点多了很多，所以需要进一步的处理，如LOD算法来降低显卡的负担。实际上也可以和公告牌结合起来，例如远处就没有必要用模型去渲染了，直接用公告牌，如此折中也不错。还有一种方法就是通过程序来构建树的结构，在这里我将介绍通过L-系统语法规则进行植物建模。采用的图形API为OpenGL3.3+，可编程管线。","text":"本次我将带来L系统构建分形树的实现。树一直都是虚拟室外景观中非常重要的一部分。目前模拟树的方法有很多，其中最为廉价的就是公告牌了，用一个2D的平面去仿造三维立体的效果，在以前显卡还不强力的时候这是个不错的选择，即使是现在也有用武之地。还有通过三维建模工具建立的三维模型，这些三维模型非常逼真，但是有个非常大的缺点，就是顶点多了很多，所以需要进一步的处理，如LOD算法来降低显卡的负担。实际上也可以和公告牌结合起来，例如远处就没有必要用模型去渲染了，直接用公告牌，如此折中也不错。还有一种方法就是通过程序来构建树的结构，在这里我将介绍通过L-系统语法规则进行植物建模。采用的图形API为OpenGL3.3+，可编程管线。 前言 L-系统原理介绍 L-系统建模实践 实现效果演示 前言本次我将带来L系统构建分形树的实现。树一直都是虚拟室外景观中非常重要的一部分。目前模拟树的方法有很多，其中最为廉价的就是公告牌了，用一个2D的平面去仿造三维立体的效果，在以前显卡还不强力的时候这是个不错的选择，即使是现在也有用武之地。还有通过三维建模工具建立的三维模型，这些三维模型非常逼真，但是有个非常大的缺点，就是顶点多了很多，所以需要进一步的处理，如LOD算法来降低显卡的负担。实际上也可以和公告牌结合起来，例如远处就没有必要用模型去渲染了，直接用公告牌，如此折中也不错。还有一种方法就是通过程序来构建树的结构，在这里我将介绍通过L-系统语法规则进行植物建模。采用的图形API为OpenGL3.3+，可编程管线。 L-系统原理介绍L-系统的定义Lindenmayer 系统（简称为L-系统），是由生物学家Aristid Lindenmayer于1968年引进的一种字符串迭代重写机制，被认为是植物生长的数学理论。其核心概念是重写，也成为迭代重写。一般情况下，重写是通过应用一个重写规则或产生式的集合，对简单的初始目标中的部分（可以是一部分也可以是多个部分）进行连续置换来定义复杂目标的技术。在L-系统中，产生式是并行地、同时替换所给字符串中的所有字符，这种区别反映了L-系统的生物学动机。如下图所示，是利用迭代重写规则生成的雪花曲线。 开始由初始图形和生成规则，生成规则是由一条定向的折线形成的、边长为r的N次等边图形，我们称之为规则模型，这样每一步都利用规则模型替换前一个图形的每一条直线边，使得置换的生成规则与被置换的区间具有相同的端点。迭代四次后生成的图形类似雪花图形。这里说得有点抽象，下面就具体举个粒子。 L-系统的形式化语言是基于字符表示。假设初始字符串为A，生成规则（或产生式规则）为： $$A -&gt; aB$$$$B -&gt; bA$$则经过一次推导，第一个生成规则符合第一个条件，则由aB代替A，其结果为aB。第二次推导，根据第二个生成规则，字符B由bA代替，其余的没有生成规则的字符不变，也就是复制过来，其结果为abA，以此类推，abA产生abaB，继续下去依次得到ababA、ababaB等等。这个迭代重写机制不难理解。 ###L-系统的几何解释经过语法规则迭代重写得到的仅仅是一串字符串，我们还需要对这些字符进行解析。Prusinkiewicz提出解析L-系统的海龟解释方法。海龟解释的基本思想如下：平面上海龟的当前状态由一个三原数组(x,y,a)来定义，其中笛卡儿坐标(x,y)表示海龟的位置，角度a为海龟的前进方向，可以解释为海龟面对的方向。给出步长d和角度的增量sita，海龟根据以下符号所代表的命令做出反应。 F：海龟向前移动一个步长d，海龟的位置变为(x1,y1,a)，其中，x1 = x + dcos(a)，y1 = y + dsin(a)，在点(x,y)和(x1,y1)之间画一条线段。 f：向前移动一个步长d，不画线段。 +：向左转角度sita，海龟的下一个状态为(x1,y1,a+sita)，角的正方向为逆时针方向。 -：向右转角度sita，海龟的下一个状态为(x1,y1,a-sita)。 [：将海龟的当前状态压如堆栈。 ]：从堆栈中弹出当前海龟的状态。 假设有字符串：F[-F[-F -F]FF -F - FF]FF -F -FF另海龟的初始方向角为90度，旋转角增量为90度，前进步长为d（单个方格的长度），则海龟的爬行路径如图所示： 这只是个简单的例子，而且是二维平面上的。现在我们把它扩展到三维空间，海龟在空间的当前位置是由三个向量[x,y,z]表示的，他们分别表示海龟前进的方向、向左的方向和向上的方向，三个方向向量是相互垂直的单位向量。海龟的旋转可由以下方程完成：$$[x1,y1,z1] = [x,y,z]*R$$其中R是一个3×3的矩阵，当旋转角为alpha的时候，绕向量x、y、z的旋转矩阵表示如下： 海龟在空间中旋转的方向如图所示: +：向左旋转角度sita，使用旋转矩阵Rz(sita)； -：向右旋转角度sita，使用旋转矩阵Rz(-sita)； &amp;：向下旋转角度sita，使用旋转矩阵Ry(sita)； ^：向上旋转角度sita，使用旋转矩阵Ry(-sita)； \\：向左滚动角度sita，使用旋转矩阵Rx(sita)； /：向右滚动角度sita，使用旋转矩阵Rx(-sita)； 其中Rx(sita)、Ry(sita)、Rz(sita)分别表示绕x、y、z轴旋转sita角度。通过以上的方式控制海龟的旋转方向，就可以利用L-系统绘制三维空间上的图形。 好了，经过上面的长篇大论，相信都已经对L-系统有了一个清晰的认识，接下来我们就进行实践。 L-系统建模实践随机L-系统为了构建更加真实的植物，现在引入随机L-系统。相比确定性L-系统，随机L-系统加入了一个随机的概率，这个概率表现在产生式上。举个简单的粒子：$$w:F$$$$F-&gt;F[+F]F[-F]F、F[+F]F、F[-F]F$$这就是一个简单随机L-系统实例，注意到F的替换规则有三个，分别是F[+F]F[-F]F、F[+F]F和F[-F]F，那么替换的时候选哪个？这个时候就是靠概率来决定了，令三个产生式被选中的概率都是三分之一，替换的时候根据概率选取用哪个来进行替换。这样产生的植物局部是随机的，但是整体上维持了该种植物的一般性特征。 语法解析器现在我们来构建一个语法解析器。这个语法解析器根据初始字符串、需要迭代的层级、产生式进行字符串的平行重写迭代。两个for循环就搞定了，外层循环是迭代的层级，内聪循环则是对当前的字符串进行替换。废话不多少，核心代码如下： 1234567891011121314151617181920212223242526272829303132333435363738void Grammar::Iteration(int level)&#123;//字符串迭代重写，level为迭代次数 srand(time(NULL)); result = start; for(int i = 0;i &lt; level;i ++)&#123; string tmpstr = \"\"; for(int j = 0;j &lt; result.size();j ++)&#123; tmpstr += search(result[j]); &#125; result = tmpstr; &#125;&#125;string Grammar::search(char target)&#123; int index = find(target); if(index == -1)&#123; //在产生式中没有它的替换规则，那么直接就是复制它自身 string ret; ret.push_back(target); return ret; &#125; //generations里面存储了产生式，用pair&lt;char,vector&lt;string&gt; &gt;的数据结构 int num = generations[index].second.size(); int index = rand()%num;//在多个产生式中等概率选取一个 return generations[index].second[index];&#125;int Grammar::find(char target)&#123; for(int i = 0;i &lt; generations.size();i ++)&#123; if(generations[i].first == target) return i; &#125; return -1;//未找到替换产生式&#125; 字符串几何解释器现在我们就一个具体实例实践：起始字符串：{S}产生式：S -&gt; F[^$X][%X][&amp;%X]X -&gt; F[^%D][&amp;$D][/$D][%D]、F[&amp;%D][$D][/$D][^%D]D -&gt; F[^$X][%FX][&amp;%X]迭代层级：8层经过以上的规则和层级，我们就会得到一大串一大串的字符，这些字符都存储了植物的分形信息。由于太过冗长，我就不贴出来了。得到后的字符串还仅仅是字符串，接下来我就对这串字符串进行几何解释。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100struct State&#123; glm::vec3 pos; glm::vec3 dir; float length; float radius; int level;&#125;;void LSystemTree::generateFractal()&#123; //trunks存储树干，包含了树干的起点和终点 trunks.clear(); //leafs存树树叶的位置 leafs.clear(); //curState记录当前的状态，包括位置和方向，还有长度和半径 //长度和半径用于树干的构造 curState.pos = glm::vec3(0,0,0); curState.dir = glm::vec3(0,1,0); curState.length = length; curState.level = 1; curState.radius = radius; //状态栈 std::stack&lt;State&gt;stacks; for(int i = 0;i &lt; grammar.getResult().size();i ++)&#123; //从字符串中选取一个字符串进行操作 char ch = grammar.getResult()[i]; Trunk tmp; switch(ch)&#123; //遇到字符F，则前进一段距离，获得一段树干 case 'F':&#123; tmp.start = curState.pos; curState.pos += curState.dir*(float)curState.length; tmp.end = curState.pos; tmp.radius = curState.radius; tmp.level = curState.level; trunks.push_back(tmp); break; &#125; //遇到$字符，则绕Y轴旋转dy角度，dy = 30.0f case '$':&#123; curState.dir = Geometry::RotateY(curState.dir,dy); break; &#125; //遇到%字符，绕Y轴旋转-dy角度，dy = 30.0f case '%':&#123; curState.dir = Geometry::RotateY(curState.dir,-dy); break; &#125; //遇到^字符，绕X轴旋转dx角度，dx = 35.0f case '^':&#123; curState.dir = Geometry::RotateX(curState.dir,dx); break; &#125; //遇到&amp;字符，绕X轴旋转-dx角度，dx = 35.0f case '&amp;':&#123; curState.dir = Geometry::RotateX(curState.dir,-dx); break; &#125; //遇到*字符，绕Z轴旋转dz角度，dz = 35.0f case '*':&#123; curState.dir = Geometry::RotateZ(curState.dir,dz); break; &#125; //遇到/字符，绕Z轴旋转dz角度，dz = 35.0f case '/':&#123; curState.dir = Geometry::RotateZ(curState.dir,-dz); break; &#125; //遇到[字符，将当前状态压入栈中保存，然后将当前状体中的长度和半径以一个比例 //消减，其实是进入了子枝干，长度和半径需要消减 //这里lengthFactor = 0.75，radiusFactor = 0.72。 case '[':&#123; stacks.push(curState); curState.length *= lengthFactor; curState.radius *= radiusFactor; curState.level += 1; break; &#125; //遇到]字符，将栈顶状态释放 case ']':&#123; //若当前层级是最高层，说明当前已经走到了叶子，将其记录到leafs中 if(curState.level == grammar.getLevel())&#123; Trunk tm = trunks[trunks.size()-1]; Leaf rs; rs.dir = tm.end - tm.start; rs.pos = tm.end; leafs.push_back(rs); &#125; curState = stacks.top(); stacks.pop(); break; &#125; default: break; &#125; &#125;&#125; 经过以上的几何解释过程，我们就得到了两个信息，trunks和leafs，这两个vector分别存储了树干和树叶。每个树干包含起点和终点，以及长度和半径信息。树叶中主要是位置以及方向向量。有了这些信息，我们下一步就是进行构造植物模型。 分形树的构建在上一步中我们已经得到了树干和树叶的信息，那该怎么通过OpenGL画出来呢？最简单的就是树干直接用线，设定一定的线宽。但是这种方法太过粗糙，线宽的设定也有上限，最多只能为10，在调试阶段或许还有用。比较好的方法就是通过圆柱来表示树干，这个圆柱不需要要太过精细。但是现在我们遇到两个问题。第一，现代OpenGL太底层了，没有提供画圆柱API，这需要我们自己去弄，不难；第二，如何在空间中的任意两点之间画一个圆柱，这个可以先在原点画一个圆柱，然后求出旋转和平移矩阵，将其平移到目标位置。 根据圆的方程可以构建圆柱如下，我们在原点处向着z轴的正方向构建，所以圆柱起点为(0,0,0)，而终点为(0,0,len)，len为圆柱的长度。同时圆柱和不需要太过精细，5片矩形实际上够了。123456789101112131415161718192021222324void CylinderMesh(float len,float radius,vector&lt;glm::vec3&gt;&amp;vertice) &#123; unsigned int slice = 6; float delta = 360.0f/(float)(slice-1.0); for(unsigned int x = 0;x &lt; slice-1;x ++)&#123; float angle = delta*x; float rc1 = radius*cos(glm::radians(angle)); float rs1 = radius*sin(glm::radians(angle)); float rc2 = radius*cos(glm::radians(angle+delta)); float rs2 = radius*sin(glm::radians(angle+delta)); glm::vec3 point1 = glm::vec3(rc1,rs1,len); glm::vec3 point2 = glm::vec3(rc1,rs1,0.0); glm::vec3 point3 = glm::vec3(rc2,rs2,len); glm::vec3 point4 = glm::vec3(rc2,rs2,0.0); vertice.push_back(point1); vertice.push_back(point2); vertice.push_back(point3); vertice.push_back(point3); vertice.push_back(point2); vertice.push_back(point4); &#125;&#125; 现在我们需要求出旋转平移矩阵，将原点处的圆柱平移到目标位置。废话少说，12345678910111213141516171819glm::mat4 GetTranMat(glm::vec3 start,glm::vec3 end,glm::mat4 &amp;nmats)&#123; glm::mat4 trans(1.0f); //求出平移矩阵，这个简单，就是目标位置的起始点 trans = glm::translate(trans,start); glm::vec3 z = glm::vec3(0,0,-1); glm::vec3 p = start - end; //叉乘获取一个垂直于z轴和目标向量的向量，实际上就是旋转轴！ glm::vec3 t = glm::cross(z,p); float Pi = 3.1415926; //点乘，然后单位化，然后通过acos获取他们的夹角！ float angle = acos(glm::dot(z,p)/glm::length(p)); glm::mat4 rotas(1.0f); //根据旋转轴旋转angle角度 rotas = glm::rotate(rotas,angle,t); nmats = rotas; //顺序是先旋转后平移 return trans*rotas;&#125; 通过以上的计算就求出了旋转平移矩阵，那么多的树干，只需要求一个圆柱的网格顶点，然后计算出相应的缩放矩阵和旋转平移矩阵就能获取目标网格顶点了！ 实现效果演示加上纹理映射和光照阴影，效果如下：其中的粒子效果是前介绍过的了。比较大颗的树是迭代了7层，小颗的则是迭代了4层。 参考资料：《基于L-系统的虚拟植物形态建模方法研究》李纪永参考博客：http://blog.csdn.net/Mahabharata_/article/details/66967837?locationNum=10&amp;fps=1","categories":[],"tags":[{"name":"Computer Graphic","slug":"Computer-Graphic","permalink":"http://yoursite.com/tags/Computer-Graphic/"},{"name":"L-System","slug":"L-System","permalink":"http://yoursite.com/tags/L-System/"},{"name":"Tree modeling","slug":"Tree-modeling","permalink":"http://yoursite.com/tags/Tree-modeling/"}]},{"title":"粒子群优化算法、差分进化算法","slug":"PSO","date":"2019-04-25T12:39:31.550Z","updated":"2019-04-27T07:00:53.812Z","comments":true,"path":"2019/04/25/PSO/","link":"","permalink":"http://yoursite.com/2019/04/25/PSO/","excerpt":"本次带来粒子群优化算法和差分进化算法，解决单目标连续优化问题。算法的benchmark全部来自http://www.ntu.edu.sg/home/epnsugan/index_files/CEC2018/CEC2018.htm 。这上面有30个测试函数，每个函数基本上有2维、10维、20维、30维、50维、100维的版本，提供了一个c语言的function文件，包含了全部benchmark函数，测试可直接调用。","text":"本次带来粒子群优化算法和差分进化算法，解决单目标连续优化问题。算法的benchmark全部来自http://www.ntu.edu.sg/home/epnsugan/index_files/CEC2018/CEC2018.htm 。这上面有30个测试函数，每个函数基本上有2维、10维、20维、30维、50维、100维的版本，提供了一个c语言的function文件，包含了全部benchmark函数，测试可直接调用。 前言 算法理论 算法实践 可视化 前言本次带来粒子群优化算法和差分进化算法，解决单目标连续优化问题。算法的benchmark全部来自http://www.ntu.edu.sg/home/epnsugan/index_files/CEC2018/CEC2018.htm。这上面有30个测试函数，每个函数基本上有2维、10维、20维、30维、50维、100维的版本，提供了一个c语言的function文件，包含了全部benchmark函数，测试可直接调用。这也是本人的一项课程的课程作业，如有错误，欢迎指出，共同学习！谢谢。整个项目源码可在github下载:https://github.com/ZeusYang/AILearning/tree/master/SingleObjectiveOpt 算法理论粒子群优化算法简介 粒子群优化算法( Particle Swarm Optimization，PSO）是进化计算的一个分支，是一种模拟自然界的生物活动的随机搜索算法。PSO模拟了自然界鸟群捕食和鱼群捕食的过程。通过群体中的协作寻找到问题的全局最优解。它是1995年由美国学者Eberhart和Kennedy提出的，现在已经广泛应用于各种工程领域的优化问题之中。PSO从鸟群觅食模型中得到启示并用于解决优化问题。PSO中，每个优化问题的解都是搜索空间中的一只鸟。我们称之为“粒子”。所有的粒子都有一个由被优化的函数决定的适应值(fitness value)，每个粒子还有一个速度决定他们飞翔的方向和距离。然后粒子们就追随当前的最优粒子在解空间中搜索。 算法流程及伪代码 PSO 初始化为一群随机粒子(随机解)。然后通过迭代找到最优解。在每一次迭代中，粒子通过跟踪两个”极值”来更新自己。第一个就是粒子本身所找到的最优解，这个解叫做个体极值pBest。另一个极值是整个种群目前找到的最优解，这个极值是全局极值gBest。另外也可以不用整个种群而只是用其中一部分作为粒子的邻居，那么在所有邻居中的极值就是局部极值。 更新公式及其参数说明每个粒子个体的速度和位置更新的公式如下：v[]和present[]为个体的速度数组和位置数组，每个粒子都有它相应的速度和位置，速度的维度和变量的维度保持一致。w为惯性权重，它控制着前一速度对当前速度的影响，用于平衡算法的探索和开发能力。c1和c2是加速系数，它代表了粒子向自身极值pBest和全局极值gBest推进的加速权值。除了这些参数之外，还有种群规模N，也就是用多少个粒子实例去优化，它影响着算法的搜索能力和计算量。结束条件可以用一定的迭代次数替换，达到一定的迭代次数之后算法就会收敛，不再推进。12v[] = w * v[] + c1 * rand() * (pbest[] - present[]) + c2 * rand() * (gbest[] - present[])present[] = present[] + v[] PSO对种群规模要求不高，一般取20-40就可以达到很好的求解效果，不过对于比较难的问题或者特定类别的问题，粒子数可以取到100或200。 惯性权重我这里取0.5，代表前一速度对当前速度有一半的贡献。 c1和c2通常都等于2.0，代表着对两个引导方向的同等重视 。 终止条件决定算法运行的结束，由具体的应用和问题本身确定。有几种做法：(1)将最大循环数设定为500，1000，5000，或者最大的函数评估次数，等等;(2)也可以使用算法求解得到一个可接受的解作为终止条件;(3)或者是当算法在很长一段迭代中没有得到任何改善，则可以终止算法. 差分进化算法简介 差分进化算法（DE）是Rainer Storn 和Kenneth Price在1996 年为求解切比雪夫多项式而提出。DE是一种随机的并行直接搜索算法,它可对非线性不可微连续空间函数进行最小化,以其易用性、稳健性和强大的全局寻优能力在多个领域取得成功。DE也是基于群体的启发式搜索算法，群中的每个个体对应一个解向量。差分进化算法的进化流程则与遗传算法非常类似，都包括变异、杂交和选择操作，但这些操作的具体定义与遗传算法有所不同。 算法流程及伪码 DE算法通过采用浮点矢量进行编码生成种群个体。在DE算法寻优的过程中，首先，从父代个体间选择两个个体进行向量做差生成差分矢量；其次，选择另外一个个体与差分矢量求和生成实验个体；然后，对父代个体与相应的实验个体进行交叉操作，生成新的子代个体；最后在父代个体和子代个体之间进行选择操作，将符合要求的个体保存到下一代群体中去。 具体流程如下：(1)、确定差分进化算法控制参数，确定适应度函数。差分进化算法控制参数包括：种群大小NP、缩放因子F与杂交概率CR。(2)、随机产生初始种群。(3)、对初始种群进行评价，即计算初始种群中每个个体的适应度值。(4)、判断是否达到终止条件或进化代数达到最大。若是，则终止进化，将得到最佳个体作为最优解输出；若否，继续。(5)、进行变异和交叉操作，得到中间种群。(6)、在原种群和中间种群中选择个体，得到新一代种群。(7)、进化代数g=g+1，转步骤(4) 更新公式及其参数说明差异演化算法主要涉及群体规模M 、缩放因子F以及交叉概率CR三个参数的设定。M：一般介于5×n 与10×n 之间, 但不能少于4, 否则无法进行变异操作，n是维度; F ：一般在[ 0, 2 ]之间选择, 通常取0. 5;CR：一般在[ 0, 1 ]之间选择, 比较好的选择应在0. 3 左右, CR 大些收敛速度会加快, 但易发生早熟现象。 算法实践粒子群优化算法 随机初始化每个粒子 123456789101112131415srand((unsigned)time(NULL)); int population = static_cast&lt;int&gt;(getParameters(tr(\"population\")));//种群大小 int dimension = static_cast&lt;int&gt;(getParameters(tr(\"dimension\")));//维度 int generation = static_cast&lt;int&gt;(getParameters(tr(\"generation\")));//迭代次数 double lowbounding = getParameters(tr(\"lowbounding\")); double upbounding = getParameters(tr(\"upbounding\")); group.clear(); group.resize(generation,std::vector&lt;std::vector&lt;double&gt; &gt;(population, std::vector&lt;double&gt;(dimension,0.0))); for (int i = 0; i &lt; population; i++) &#123; for (int j = 0; j &lt; dimension; j++) &#123; group[0][i][j] = lowbounding + (double)(rand() / (double)RAND_MAX) * (upbounding - lowbounding); &#125; &#125; 更新每个粒子的速度和位置 12345678910111213141516171819202122232425262728293031void PSOAlgorithm::update(int curGeneration)&#123;//更新速度和位置 int dimension = static_cast&lt;int&gt;(getParameters(tr(\"dimension\"))); int population = static_cast&lt;int&gt;(getParameters(tr(\"population\"))); double w = getParameters(tr(\"w\"));//惯性权重 double c1 = getParameters(tr(\"c1\"));//加速系数 double c2 = getParameters(tr(\"c2\"));//加速系数 double upbounding = getParameters(tr(\"upbounding\"));//上界 double lowbounding = getParameters(tr(\"lowbounding\"));//下界 for(auto i = 0;i &lt; population;++i)&#123; for(auto j = 0;j &lt; dimension;++j)&#123; double pre = velocity[i][j]; //更新速度 velocity[i][j] = w*pre + c1*(double)(rand()/(double)RAND_MAX)* (pBest[i][j] - group[curGeneration - 1][i][j]) + c2*(double)(rand()/(double)RAND_MAX)* (gBest[j] - group[curGeneration - 1][i][j]); if(velocity[i][j] &gt; 200)velocity[i][j] = 200; //位置更新 group[curGeneration][i][j] = group[curGeneration-1][i][j] + velocity[i][j]; //边界处理 if(group[curGeneration][i][j] &gt; upbounding) group[curGeneration][i][j] = upbounding; if(group[curGeneration][i][j] &lt; lowbounding) group[curGeneration][i][j] = lowbounding; &#125; &#125;&#125; 更新每个粒子的历史最优和全局最优、 12345678910111213141516void PSOAlgorithm::curAndgloBest(int curGeneration)&#123;//计算当前最优解和全局最优解 int population = static_cast&lt;int&gt;(getParameters(tr(\"population\"))); int dimension = static_cast&lt;int&gt;(getParameters(tr(\"dimension\"))); int func_num = static_cast&lt;int&gt;(getParameters(tr(\"function\")));//函数编号 for (auto i = 0; i &lt; population; ++i) &#123; double value = functions(group[curGeneration][i], func_num, dimension); if (value &lt; functions(pBest[i], func_num, dimension)) pBest[i] = group[curGeneration][i]; if (functions(pBest[i], func_num, dimension) &lt; functions(gBest, func_num, dimension))&#123; gBest = pBest[i]; bestValue.first = i; bestValue.second = functions(pBest[i], func_num, dimension); &#125; &#125;&#125; 算法核心 12345678910111213void PSOAlgorithm::process()&#123; curAndgloBest(0);//计算初始代最优解 int generation = static_cast&lt;int&gt;(getParameters(tr(\"generation\")));//迭代次数 for (auto current = 1; current &lt; generation; ++current) &#123; update(current); curAndgloBest(current); calcCurrentValue(pBest); if(generation &lt;= 100 || (generation &gt; 100 &amp;&amp; generation % 2 == 0)) emit frameUpdate(avgValue,currentValue,minY,maxY,current,generation,bestValue); &#125; emit processFinished(getResult(gBest));&#125; 粒子群优化算法 随机产生初始种群 123456789101112131415srand((unsigned)time(NULL)); int population = static_cast&lt;int&gt;(getParameters(tr(\"population\")));//种群大小 int dimension = static_cast&lt;int&gt;(getParameters(tr(\"dimension\")));//维度 int generation = static_cast&lt;int&gt;(getParameters(tr(\"generation\")));//迭代次数 double lowbounding = getParameters(tr(\"lowbounding\")); double upbounding = getParameters(tr(\"upbounding\")); group.clear(); group.resize(generation,std::vector&lt;std::vector&lt;double&gt; &gt;(population, std::vector&lt;double&gt;(dimension,0.0))); for (int i = 0; i &lt; population; i++) &#123; for (int j = 0; j &lt; dimension; j++) &#123; group[0][i][j] = lowbounding + (double)(rand() / (double)RAND_MAX) * (upbounding - lowbounding); &#125; &#125; 核心算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071void DEAlgorithm::process()&#123; int population = static_cast&lt;int&gt;(getParameters(tr(\"population\")));//种群大小 int dimension = static_cast&lt;int&gt;(getParameters(tr(\"dimension\")));//维度 int generation = static_cast&lt;int&gt;(getParameters(tr(\"generation\")));//迭代次数 double lowbounding = getParameters(tr(\"lowbounding\")); double upbounding = getParameters(tr(\"upbounding\")); double DE_F = getParameters(tr(\"F\"));//缩放因子 double DE_CR = getParameters(tr(\"CR\"));//交叉概率 int func_num = static_cast&lt;int&gt;(getParameters(tr(\"function\")));//函数编号 double bestSolution = 100000000;//目前全局最优解 //开始迭代 for(auto t=1;t&lt;generation;t++)&#123; //变异 for(int i=0;i&lt;population;i++)&#123; //随机选三个向量 std::vector&lt;bool&gt; selected(population,false); selected[i] = true; int pick[3]; for(auto k=0;k&lt;3;k++)&#123; pick[k] = rand() % population; while(selected[pick[k]])pick[k] = rand() % population; selected[pick[k]] = true; &#125; for(auto j=0;j&lt;dimension;j++)&#123; //变异操作公式 group[t][i][j] = group[t-1][pick[0]][j] + DE_F * (group[t-1][pick[1]][j] - group[t-1][pick[2]][j]); //边界处理 if(group[t][i][j]&lt;lowbounding) group[t][i][j] = lowbounding; else if(group[t][i][j]&gt;upbounding) group[t][i][j] = upbounding; &#125; &#125; //交叉 for(auto i=0;i&lt;population;i++)&#123; for(auto j=0;j&lt;dimension;j++)&#123; if(((rand() % 100) / 100.0) &lt;= DE_CR || j == (rand() % dimension)) group[t][i][j] = group[t][i][j]; else group[t][i][j] = group[t-1][i][j]; &#125; &#125; //选择替换，贪心策略 for(auto i=0;i&lt;population;i++)&#123; if(functions(group[t][i],func_num,dimension) &lt;= functions(group[t-1][i],func_num,dimension))&#123; group[t][i] = group[t][i]; bestSolution = bestSolution &lt; functions(group[t][i],func_num,dimension) ? bestSolution : functions(group[t][i],func_num,dimension); if(bestSolution &lt; functions(group[t][i],func_num,dimension))&#123; bestValue.first = i; bestValue.second = bestSolution; solution = group[t][i]; &#125; &#125; else&#123; group[t][i] = group[t-1][i]; &#125; &#125; //计算当前种群的全部值 calcCurrentValue(group[t]); if(generation &gt; 300 &amp;&amp; generation % 2 == 0)&#123; emit frameUpdate(avgValue,currentValue,minY,maxY,t,generation,bestValue); &#125; else&#123; emit frameUpdate(avgValue,currentValue,minY,maxY,t,generation,bestValue); &#125; &#125; emit processFinished(getResult(solution));&#125; 以上只是算法的核心部分，更多的细节请看源码。 可视化用Qt做了个可视化，可以调节参数，显示了种群个体的每个个体的适应值以及整个种群的适应值收敛曲线。粒子群算法：可以看到最后粒子都收敛了，在同一条直线上：差分进化算法：总的来说，差分进化算法略占优势，收敛的速度也比较快，粒子群算法比较没那么稳定. 整个项目源码可在github下载：https://github.com/ZeusYang/AILearning/tree/master/SingleObjectiveOpt","categories":[],"tags":[{"name":"PSO","slug":"PSO","permalink":"http://yoursite.com/tags/PSO/"},{"name":"DE","slug":"DE","permalink":"http://yoursite.com/tags/DE/"},{"name":"AI","slug":"AI","permalink":"http://yoursite.com/tags/AI/"}]},{"title":"迷宫生成、寻路","slug":"maze","date":"2019-04-25T12:34:35.749Z","updated":"2019-04-27T06:58:15.666Z","comments":true,"path":"2019/04/25/maze/","link":"","permalink":"http://yoursite.com/2019/04/25/maze/","excerpt":"本次带来迷宫相关的算法，迷宫的算法涉及到不少经典的图论算法，在游戏中NPC这些算法被大量的运用，深入了解和学习这些算法是为开发游戏打下坚实的基础。除了纯算法以外，我还借用了OpenGL将这些算法的演算过程可视化出来，借用这些动画演算，可加深对算法的理解，枯燥的算法一下子有趣了起来呢！","text":"本次带来迷宫相关的算法，迷宫的算法涉及到不少经典的图论算法，在游戏中NPC这些算法被大量的运用，深入了解和学习这些算法是为开发游戏打下坚实的基础。除了纯算法以外，我还借用了OpenGL将这些算法的演算过程可视化出来，借用这些动画演算，可加深对算法的理解，枯燥的算法一下子有趣了起来呢！ 前言 数据结构准备 迷宫生成算法 迷宫寻路算法 前言本次带来迷宫相关的算法，迷宫的算法涉及到不少经典的图论算法，在游戏中NPC这些算法被大量的运用，深入了解和学习这些算法是为开发游戏打下坚实的基础。除了纯算法以外，我还借用了OpenGL将这些算法的演算过程可视化出来，借用这些动画演算，可加深对算法的理解，枯燥的算法一下子有趣了起来！ 本工程全部源码及可执行程序可在github下载：https://github.com/ZeusYang/Breakout。其中的Maze目录就是本次迷宫的项目文件了，可执行程序exe在Maze/x64/Release下，编译的64位程序，可直接运行。 程序操作说明：1、2、3数字键是生成迷宫指令，分别是深度优先、随机Prim、四叉树分割迷宫生成算法，A/a、B/b、C/c字符键是迷宫寻路指令，分别是深度优先、广度优先、A星算法迷宫寻路。按下之后再按Enter即自动开始对应的操作。注意先生成迷宫再进行寻路，否则没有意义，因为一开始都是封闭墙。 数据结构准备迷宫本质上是一个二维平面，我们用一个二维数组表示，然后数组中的每个元素都是一个迷宫单元。定义迷宫单元[x,y]，每个迷宫单元有上、下、左、右四面墙，初始时四面墙都存在。为了方面，我们定义下面的结构体： 12345678910111213141516enum Neighbor &#123; LEFT = 0, UP = 1, RIGHT = 2, DOWN = 3 &#125;;struct Cell &#123;//迷宫单元 int neighbors[4];//四个方向的邻居 int visited;//记录是否访问过了 //以下用于寻路算法 glm::ivec2 prev;//记录前驱 //用于A星算法的open表、closed表 bool inOpen, inClosed; //启发式函数fn = gn + hn //其中gn为起点到n的实际距离，hn为n到终点的哈密顿 int gn, hn; Cell() :visited(0),inOpen(false),inClosed(false) &#123; neighbors[LEFT] = neighbors[UP] = neighbors[RIGHT] = neighbors[DOWN] = 0; &#125;&#125;; 然后声明一个类–MazeAlgorithm，在这里我们将要实现六个算法，每个算法的数据结构如下：12345678910111213141516const int row, col;//迷宫单元的行、列数static std::vector&lt;std::vector&lt;Cell&gt;&gt; cells;//迷宫单元矩阵//迷宫生成算法一数据结构:深度优先的栈std::stack&lt;glm::ivec2&gt; record;//迷宫生成算法二数据结构：随机Prim算法的链表std::list&lt;glm::ivec2&gt; prim;//迷宫生成算法三数据结构：四叉树广度优先的队列std::queue&lt;std::pair&lt;glm::ivec2, glm::ivec2&gt;&gt; recursive;//迷宫寻路算法一数据结构：深度优先的栈std::stack&lt;glm::ivec2&gt; path_dfs;//迷宫寻路算法一数据结构：广度优先的队列std::queue&lt;glm::ivec2&gt; path_bfs;//迷宫寻路算法一数据结构：A星算法的优先队列std::priority_queue&lt;Node,std::vector&lt;Node&gt;,Compare&gt; path_astar; 以上仅仅是一部分，具体的细节请看源码。 迷宫生成算法这里我实现的迷宫生成算法有三个，分别是：深度优先、随机Prim、四叉树分割。 深度优先就是表面上的意思，深度优先的方法生成迷宫，当然跟普通的深度优先搜索有点差别，它加入了随机性，先看伪代码： 12345678910将起点作为当前迷宫单元并标记为已访问 while 还存在未标记的迷宫单元 if 当前迷宫单元有未被访问过的的相邻的迷宫单元 then 随机选择一个未访问的相邻迷宫单元 将当前迷宫单元入栈 移除当前迷宫单元与相邻迷宫单元的墙 标记相邻迷宫单元并用它作为当前迷宫单元 else if 栈不空 栈顶的迷宫单元出栈 令其成为当前迷宫单元 算法的主要思想就是，每次在当前迷宫单元中寻找与其相邻的未访问过的迷宫单元，然后选择这些邻居其中的一个访问下去，直到所有的单元都被访问到。就是从起点开始随机走，走不通了就返回上一步，从下一个能走的地方再开始随机走。 那么如何实现呢，我们用一个栈来进行深度优先遍历，栈的元素是数组的下标。下面代码中的frame纯属用于演示动画，可去掉直接得结果，还有栈的初始化请在源代码中Generation_Init()函数查看。123456789101112131415161718192021222324252627282930313233343536std::stack&lt;glm::ivec2&gt; record;...bool MazeAlgorithm::Generator_Dfs() &#123; frame = 5;//用于演示动画 while (!record.empty() &amp;&amp; frame--) &#123;//当队列或者frame不减到0时 cells[cur.x][cur.y].visited = 1;//标记当前的位置为访问过的了 bool hasNeigh = false;//是否有邻居未访问 std::vector&lt;std::pair&lt;glm::ivec2,int&gt;&gt; tmp; //记录未访问的邻居, tmp.second代表它是哪个邻居 glm::ivec2 loc; //寻找是否存在未访问的邻居 for (auto x = 0; x &lt; 4; ++x) &#123; loc = glm::ivec2(cur.x + to[x][0], cur.y + to[x][1]); if (CouldMove(loc) &amp;&amp; !cells[loc.x][loc.y].visited) &#123;//有未访问的邻居 tmp.push_back(&#123; loc,x &#125;);//加入tmp中，然后随机选择一个 hasNeigh = true; &#125; &#125; if (hasNeigh) &#123;//从未访问的邻居中随机选择一个 int got = rand() % tmp.size(); record.push(cur);//当前迷宫单元入栈 //拆掉cur和tmp[got]之间的墙 cells[cur.x][cur.y].neighbors[tmp[got].second] = 1; cells[tmp[got].first.x][tmp[got].first.y].neighbors[(tmp[got].second + 2) % 4] = 1; //令当前标记变为该邻居 cur = tmp[got].first; &#125; else &#123;//没找到一个未被访问的邻居，是时候回溯了 cur = record.top(); record.pop(); &#125; &#125; //栈尾空代表已经结束了 if (record.empty())return true; else return false;&#125; 然后用OpenGL做出的动画如下：可以看到就是沿着一条路一直走下去，没路再回溯。这就是深度优先。 随机Prim与深度优先不同，随机Prim算法是随机地在迷宫单元列表中随机选取一个迷宫单元，新加入列表和之前加入列表的迷宫单元有同等的概略被选中。对于选中的迷宫单元，标记为被访问状态，并把它从列表中删除，然后依旧查看它的四面邻居的情况，从所有被访问过的邻居中随机选一个，打通这个邻居和当前迷宫单元之前的墙，对所有未被访问过的邻居我们将其放入列表中。注意到我们有删除操作，但是又要求随机访问。这里我采用了链表，我想了下可以用另一种方法替代，但是对于规模不是非常巨大的来说是几乎没什么差别。废话不多说，伪代码如下： 1234567891011list = 迷宫单元的列表，这里是索引set = 暂存一个迷宫单元的被访问过的邻居将起点加入list中while list不空 从list中随机选一个元素cur 将cur从list中删除，标记cur的迷宫单元为被访问状态 对于cur的四个邻居 该邻居被访问过，加入set中 否则加入list中 if set非空 从中随机选一个，打通cur和被选中的迷宫单元之间的墙 随机Prim的等概率性使得所有的迷宫单元优先级几乎等同，因此其分支更多，生成的迷宫更复杂，难度更大。1234567891011121314151617181920212223242526272829303132333435363738bool MazeAlgorithm::Generator_Prim() &#123; frame = 5;//frame同上 //prim为list while (!prim.empty() &amp;&amp; frame--) &#123; //随机从list中选一个 int choice = rand() % prim.size(); auto it = prim.begin(); std::advance(it, (choice == 0) ? 0 : choice); cur = *it; //标记为已访问过，然后从List删除 cells[cur.x][cur.y].visited = 1; prim.erase(it); //查看邻居的情况 std::vector&lt;std::pair&lt;glm::ivec2, int&gt;&gt; tmp; //记录未访问的邻居 //四个邻居 for (auto x = 0; x &lt; 4; ++x) &#123; glm::ivec2 loc = glm::ivec2(cur.x + to[x][0], cur.y + to[x][1]); if (CouldMove(loc)) &#123;//边界检查 //被访问过，加入tmp中，接下来要随机抽取这些 if (cells[loc.x][loc.y].visited == 1)tmp.push_back(std::pair&lt;glm::ivec2, int&gt;(loc, x)); else if (cells[loc.x][loc.y].visited == 0) &#123; //未被访问过，加入list中，并标记为2，代表他们在list中 prim.push_back(loc); cells[loc.x][loc.y].visited = 2; &#125; &#125; &#125; //有未被访问过的邻居 if (!tmp.empty()) &#123; //从中随机选一个，打通他们之间的墙 int got = rand() % tmp.size(); cells[cur.x][cur.y].neighbors[tmp[got].second] = 1; cells[tmp[got].first.x][tmp[got].first.y].neighbors[(tmp[got].second + 2) % 4] = 1; &#125; &#125; if (prim.empty())return true; else return false;&#125; 可以看到这种方法有点广度优先的影子，这是因为迷宫单元之间的优先级等同。此算法生成迷宫难度最大。 四叉树分割在有些地方那个也叫递归分割，但实际上可以不用递归，它的本质上就是一颗四叉树。每一次在当前的迷宫范围内用十字分割成四个子空间，在十字四个方向中随机三个墙上挖洞，随机对每个子空间进行同样的操作，知道子空间不可再分。可以看到原理非常简单，但生成迷宫的效率却是最高的，然后此法生成的迷宫教为简单，直路较多。我们直接对迷宫单元数组进行操作，采用广度优先遍历四叉树的方法，每次划分四个子空间。伪代码如下： 12345678910111213141516queue = &#123;(r1,r2,c1,c2)|r1为最小行，r2为最大行，c1和c2同理，换成列&#125;将迷宫矩阵范围(0,rows,0,cols)放入queue中while queue不空 从queue取队头元素，出队 if r1 &lt; r2 且 c1 &lt; c2 then 在r1和r2之间选取随机数r 在c1和c2之间选取随机数c 用(r,c)对该范围进行分割 在(r,c)的四个方向上随机选三个，打通他们的墙 然后用(r,c)十字分割当前的范围，将四个子空间入队 else if r1 &lt; r2 此时子空间变成了一条竖线，我们只在行方向上进行操作和分割 然后两个子空间加入队列 else if c1 &lt; c2 此时子空间变成了一条横线，我们只在列方向上进行操作和分割 然后两个子空间加入队列 利用递归实现此算法非常简洁明了，但是我为了能够追踪演算过程采用了bfs方法实现，比较繁琐，如下，更多细节请查看源代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970bool MazeAlgorithm::Generator_Recursive() &#123; frame = 10; //recursive是queue，其中的元素为pair&lt;glm::ivec2,glm::ivec2&gt; //first为行范围，second为列范围 while (!recursive.empty() &amp;&amp; frame--) &#123; std::pair&lt;glm::ivec2, glm::ivec2&gt; head = recursive.front(); recursive.pop(); //head.first == head.second情况下变成了一条线，需要特殊处理 if (head.first.x &lt; head.first.y &amp;&amp; head.second.x &lt; head.second.y) &#123; glm::ivec2 center; //在[head.first,head.first)之间选择一个坐标，根据这个坐标进行分割 center.x = head.first.x + rand() % (head.first.y - head.first.x); center.y = head.second.x + rand() % (head.second.y - head.second.x); int subRow[2], subCol[2];//存储四个方向上的随机数 //在center四个方向上随机选取 subRow[0] = head.first.x + rand() % (center.x - head.first.x + 1); subRow[1] = center.x + 1 + rand() % (head.first.y - center.x); subCol[0] = head.second.x + rand() % (center.y - head.second.x + 1); subCol[1] = center.y + 1 + rand() % (head.second.y - center.y); //获取四个方向上的随机迷宫单元 glm::ivec2 meta[4]; meta[LEFT] = glm::ivec2(center.x, subCol[0]); meta[UP] = glm::ivec2(subRow[0], center.y); meta[RIGHT] = glm::ivec2(center.x, subCol[1]); meta[DOWN] = glm::ivec2(subRow[1], center.y); int notOpen = rand() % 4;//随机选一个迷宫单元不打通，剩下的三个都打通 for (auto x = 0; x &lt; 4; ++x) &#123; if (x != notOpen) &#123;//在这三个迷宫单元挖洞 //左、右打通它的下面，上、下打通它的右面 glm::ivec2 near = (x % 2 == 0) ? glm::ivec2(meta[x].x + 1, meta[x].y) : glm::ivec2(meta[x].x, meta[x].y + 1); //哪面墙 int which = (x % 2 == 0) ? DOWN : RIGHT; //打通meta[x]和near之间的墙 cells[meta[x].x][meta[x].y].neighbors[which] = 1; cells[near.x][near.y].neighbors[(which + 2) % 4] = 1; &#125; &#125; //然后再对当前的四个子空间进行同样处理，入队 recursive.push(std::pair&lt;glm::ivec2, glm::ivec2&gt;(&#123; glm::ivec2(head.first.x,center.x), glm::ivec2(head.second.x,center.y) &#125;)); recursive.push(std::pair&lt;glm::ivec2, glm::ivec2&gt;(&#123; glm::ivec2(head.first.x,center.x), glm::ivec2(center.y + 1,head.second.y) &#125;)); recursive.push(std::pair&lt;glm::ivec2, glm::ivec2&gt;(&#123; glm::ivec2(center.x + 1,head.first.y), glm::ivec2(head.second.x,center.y) &#125;)); recursive.push(std::pair&lt;glm::ivec2, glm::ivec2&gt;(&#123; glm::ivec2(center.x + 1,head.first.y), glm::ivec2(center.y + 1,head.second.y) &#125;)); &#125; else if (head.first.x &lt; head.first.y) &#123;//子空间变成了一条竖线，其他同上 int rm = head.first.x + rand() % (head.first.y - head.first.x); cells[rm][head.second.x].neighbors[DOWN] = 1; cells[rm + 1][head.second.x].neighbors[UP] = 1; recursive.push(std::pair&lt;glm::ivec2, glm::ivec2&gt;(&#123; glm::ivec2(head.first.x,rm), glm::ivec2(head.second.x,head.second.x) &#125;)); recursive.push(std::pair&lt;glm::ivec2, glm::ivec2&gt;(&#123; glm::ivec2(rm + 1,head.first.y), glm::ivec2(head.second.x,head.second.x) &#125;)); &#125; else if (head.second.x &lt; head.second.y) &#123;//子空间变成了一条横线，其他同上 int cm = head.second.x + rand() % (head.second.y - head.second.x); cells[head.first.x][cm].neighbors[RIGHT] = 1; cells[head.first.x][cm+1].neighbors[LEFT] = 1; recursive.push(std::pair&lt;glm::ivec2, glm::ivec2&gt;(&#123; glm::ivec2(head.first.x,head.first.x), glm::ivec2(head.second.x,cm) &#125;)); recursive.push(std::pair&lt;glm::ivec2, glm::ivec2&gt;(&#123; glm::ivec2(head.first.x,head.first.x), glm::ivec2(cm + 1,head.second.y) &#125;)); &#125; &#125; if (recursive.empty()) return true; else return false;&#125; 此方法速度很快，可以看到生成的迷宫较为简单，直路多，适合fps等类的游戏。 迷宫寻路算法这里我实现的迷宫寻路算法有三个，分别是：深度优先搜索、广度优先搜索、A星搜索算法。 ####深度优先搜索基本的图算法遍历操作，没什么特别的，深度优先搜索出来的路径不一定是最短的，它遵循的原则是找到就好。 12345678910111213141516171819202122232425262728bool MazeAlgorithm::Pathfinding_Dfs() &#123; //深度优先遍历寻路 frame = 10; while (!path_dfs.empty() &amp;&amp; frame--) &#123; glm::ivec2 head = path_dfs.top(); path_dfs.pop(); //寻找邻居 for (auto x = 0; x &lt; 4; ++x) &#123; glm::ivec2 loc(head.x + to[x][0], head.y + to[x][1]); if (CouldMove(loc) &amp;&amp; !cells[loc.x][loc.y].visited //未访问 &amp;&amp; cells[head.x][head.y].neighbors[x] == 1) &#123;//且无墙隔着 cells[loc.x][loc.y].prev = head;//记录前驱，然后要倒推路径 path_dfs.push(loc); cells[loc.x][loc.y].visited = 1; //找到终点了 if (loc == glm::ivec2(row - 1, col - 1)) &#123; //清空dfs栈，停止搜索 while (!path_dfs.empty())path_dfs.pop(); &#125; &#125; &#125; &#125; if (path_dfs.empty()) &#123;//从终点倒退路径到起点 GetSolution(); return true; &#125; else return false;&#125; 广度优先搜索也是基本的图算法，它像病毒爆发一样向着终点蔓延，广度优先搜索得到的路径是最短的，它遵循的原则是一起找，谁先找到就谁是答案。 12345678910111213141516171819202122232425262728bool MazeAlgorithm::Pathfinding_Bfs() &#123; //广度优先遍历寻路-&gt;最短路径 frame = 10; while (!path_bfs.empty() &amp;&amp; frame--) &#123; glm::ivec2 head = path_bfs.front(); path_bfs.pop(); //寻找邻居 for (auto x = 0; x &lt; 4; ++x) &#123; glm::ivec2 loc(head.x + to[x][0], head.y + to[x][1]); if (CouldMove(loc) &amp;&amp; !cells[loc.x][loc.y].visited //未访问 &amp;&amp; cells[head.x][head.y].neighbors[x] == 1) &#123;//且无墙隔着 cells[loc.x][loc.y].prev = head;//记录前驱，然后要倒推路径 path_bfs.push(loc); cells[loc.x][loc.y].visited = 1; //找到终点了 if (loc == glm::ivec2(row - 1, col - 1)) &#123; //清空dfs栈，停止搜索 while (!path_bfs.empty())path_bfs.pop(); &#125; &#125; &#125; &#125; if (path_bfs.empty()) &#123;//从终点倒退路径到起点 GetSolution(); return true; &#125; else return false;&#125; 广度优先遍历像病毒蔓延一样。 A星搜索算法A星搜索算法是比较经典的寻路算法了，我在前面的博文中有一篇关于A星算法，这里不再赘述和。我采用的启发式函数是fn = gn + hn，其中gn为起点到n的实际距离，hn为n到终点的哈密顿距离，采用优先队列实现，更多细节请看源代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344bool MazeAlgorithm::Pathfinding_Astar() &#123; frame = 10; while (!path_astar.empty() &amp;&amp; frame--) &#123; Node head = path_astar.top(); path_astar.pop(); //标记为放入closed表 cells[head.index.x][head.index.y].inOpen = false; cells[head.index.x][head.index.y].inClosed = true; cells[head.index.x][head.index.y].visited = 1; ////找到终点了 if (head.index == glm::ivec2(row - 1, col - 1)) &#123; //清空queue，停止搜索 while (!path_astar.empty())path_astar.pop(); break; &#125; for (auto x = 0; x &lt; 4; ++x) &#123;//查看邻居 glm::ivec2 loc(head.index.x + to[x][0], head.index.y + to[x][1]); if (CouldMove(loc) &amp;&amp; cells[head.index.x][head.index.y].neighbors[x] == 1) &#123;//无墙隔着 if (cells[loc.x][loc.y].inClosed)continue;//已在closed表中，不管它 if (!cells[loc.x][loc.y].inOpen) &#123;//不在open表中，加入open表 path_astar.push(Node(loc.x, loc.y)); cells[loc.x][loc.y].inOpen = true; cells[loc.x][loc.y].prev = head.index; cells[loc.x][loc.y].gn = cells[head.index.x][head.index.y].gn + 1; cells[loc.x][loc.y].hn = DirectLen(loc, glm::ivec2(row - 1, col - 1)); &#125; else &#123;//已在open表中，我们进行比较，然后修改前驱 int orig = cells[loc.x][loc.y].gn + cells[loc.x][loc.y].hn; int nows = cells[head.index.x][head.index.y].gn + cells[loc.x][loc.y].hn + 1; if (nows &lt; orig) &#123; cells[loc.x][loc.y].prev = head.index; cells[loc.x][loc.y].gn = cells[head.index.x][head.index.y].gn + 1; cells[loc.x][loc.y].hn = cells[loc.x][loc.y].hn; &#125; &#125; &#125; &#125; &#125; if (path_astar.empty()) &#123;//从终点倒退路径到起点 GetSolution(); return true; &#125; else return false;&#125; A星算法围绕启发式函数进行蔓延。 本工程全部源码及可执行程序可在github下载：https://github.com/ZeusYang/Breakout。其中的Maze目录就是本次迷宫的项目文件了，可执行程序exe在Maze/x64/Release下，编译的64位程序，可直接运行。 参考博客：https://blog.csdn.net/juzihongle1/article/details/73135920","categories":[],"tags":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/tags/AI/"},{"name":"Maze","slug":"Maze","permalink":"http://yoursite.com/tags/Maze/"},{"name":"BFS & DFS","slug":"BFS-DFS","permalink":"http://yoursite.com/tags/BFS-DFS/"}]},{"title":"贪吃蛇智能自动寻食","slug":"snake","date":"2019-04-25T12:28:49.816Z","updated":"2019-04-27T07:01:48.415Z","comments":true,"path":"2019/04/25/snake/","link":"","permalink":"http://yoursite.com/2019/04/25/snake/","excerpt":"本次带来智能贪吃蛇的实现，以尽最大的可能吃掉食物，甚至最后达到满屏的效果。界面部分采用OpenGL制作，辅以炫酷的粒子效果。","text":"本次带来智能贪吃蛇的实现，以尽最大的可能吃掉食物，甚至最后达到满屏的效果。界面部分采用OpenGL制作，辅以炫酷的粒子效果。 前言 简单的框架 贪吃蛇AI实现 算法实现 实现展示 前言本次带来智能贪吃蛇的实现，以尽最大的可能吃掉食物，甚至最后达到满屏的效果。界面部分采用OpenGL制作，辅以炫酷的粒子效果。整个工程以及可执行exe可以在github下载：https://github.com/ZeusYang/Breakout其中的GreedySnake就是本工程项目目录。 简单的框架Shader类:编译、链接着色器程序，包括顶点着色器、片元着色器、几何着色器，也提供设置GPU中的uniform变量的接口。Texture2D类:封装了OpenGL的纹理接口，用于从数据中创建纹理，指定纹理格式，并用于绑定。ResourceManager类:资源管理器，用于管理着色器资源和纹理资源，统一给每个着色器命名进行管理，提供从文件中获取着色器代码进而传入Shader类进行编译以及读取图片数据生成纹理，保存所有着色器程序和纹理的副本。SpriteRenderer类:渲染精灵，这里是一个2D的四边形，提供一个统一的四边形VAO接口，一个精灵有不同的位置、大小、纹理、旋转角度、颜色。PostProcessor类:后期特效处理，主要使用OpenGL的帧缓冲技术，将游戏渲染后的画面进一步地处理，这里包括震荡、反相、边缘检测和混沌。TextRenderer类:文本渲染，用于渲染文字。GameObject类:游戏物品的高层抽象，每个游戏物品有位置、大小、速度、颜色、旋转度、是否实心、是否被破坏、纹理等属性，每次调用SpriteRenderer类的一个实例的Draw方法渲染GameObject。SnakeObject类:继承自GameObject类，用于绘制蛇身。ISoundEngine:第三方库irrKlang的实例，用于播放游戏音效。Algorithm类:算法类，贪吃蛇AI的全部算法逻辑都在这里。 贪吃蛇AI实现寻路策略我们已知食物的位置和蛇头的位置，那么怎么寻找蛇头到食物的位置呢？方法有多种，如A*算法、宽度优先遍历。这里我采用的是宽度优先遍历，在一个二维的数组上，从食物出发，用宽度优先遍历的方法计算出格子中非蛇身到食物的最短距离。一次bfs之后，这个二维格子上就标记好了到食物的最短距离，bfs就是我们搜索的核心： 12345678910111213141516171819202122232425262728293031bool Algorithm::RefreshBoard(const std::list&lt;Object&gt; &amp;psnake, const Object &amp;pfood, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;pboard) &#123; /* 从食物出发，利用广度优先遍历向四周扩散 从而得到pboard中每个格子到达food的路径长度 */ std::queue&lt;glm::ivec2&gt; record; record.push(pfood.Index); std::vector&lt;std::vector&lt;bool&gt;&gt;visited; visited.resize(pboard.size(), std::vector&lt;bool&gt;(pboard[0].size(), false)); visited[pfood.Index.x][pfood.Index.y] = true; glm::ivec2 cur; bool found = false; while (!record.empty()) &#123; glm::ivec2 head = record.front(); record.pop(); //向四个方向扩展 for (auto x = 0; x &lt; 4; ++x) &#123; cur = glm::ivec2(head.x + dir[x][0], head.y + dir[x][1]); //碰到边界或已经访问过了 if (!CouldMove(cur) || visited[cur.x][cur.y])continue; if (cur == psnake.front().Index)found = true;//找到蛇头 if (pboard[cur.x][cur.y] &lt; SNAKE) &#123;//不是蛇身 pboard[cur.x][cur.y] = pboard[head.x][head.y] + 1; record.push(cur); visited[cur.x][cur.y] = true; &#125; &#125; &#125; return found;&#125; 贪吃蛇寻食策略上面已经给出了一种搜索算法，但是简单的使用bfs算法只能使蛇运行非常短的一段时间，一段时间之后它就被自己的身体困住了。每次都单纯地使用BFS，最终有一天， 贪吃蛇会因为这种不顾后果的短视行为而陷入困境。 聪明的蛇会考虑吃食物的后果，也就是吃完这个食物自己还安全吗？那么自己定义安全的局面呢？我们知道，蛇头在移动的过程中，蛇尾部分是不断地有空位空出来的，蛇永远不死的最好策略就是追着自己的尾巴跑！现在我们定义这样的安全策略，如果蛇吃完这个食物之后，蛇头到蛇尾之间有通路的话，那么就定义为安全的！ 每次寻找到食物的一个路径，我们就模拟蛇头移动过去吃食物了，然后再用bfs算法搜索蛇头到蛇尾之间是否存在通路。这是我们目前的策略。值得注意的是，蛇每走一步，整个蛇身会移动，也就是说蛇在移动的过程中，整个局面是不断变化，所以我们不能只一次bfs就够了，而是每走一步，我们按照前面的策略模拟一次，不断寻找安全的路径！ 那么现在我们的问题是，如果蛇和食物之间不存在安全的路径或蛇和食物之间根本就没有通路该如何？也就是说吃完食物之后蛇头和蛇尾没有通路了或根本吃不到食物，这种情况下蛇可能很快就被自己饶进了死胡同然后over了。这时我们先用远大的目光，暂时不要去管食物，我们先追着蛇尾跑，在追着蛇尾的过程中出现安全的路径我们再过去吃食物。 现在新的问题又来了，如果蛇和食物之间没有路径且蛇头和蛇尾之间也没有路径该怎么办？这个时候没什么办法了，只能将就地走走停停，每次只走一步，更新布局，然后再判断蛇和食物间是否有安全路径； 没有的话，蛇头和蛇尾间是否存在路径；还没有，再挑一步可行的来走。 一般来说，我们让蛇头和食物之间的路径尽可能短，就是快点吃掉食物，而蛇头和蛇尾之间的路尽可能地长，尽可能地慢。这样蛇头和蛇尾间才能腾出更多的空间，空间多才有得发展。 所以针对食物和蛇尾，我们有：目标是食物时，选最短路径；目标是蛇尾时，选最长路径。 好的现在我们整理一下整个贪吃蛇AI的策略:123456If hasPath(head,food) &amp;&amp; safe(head,tail): then go one step ahead toward food.else if hasPath(head,tail( then go one step ahead toward tail.else just find any possible step to go. 算法实现核心部分： 12345678910111213//AI思考glm::ivec2 Algorithm::AIThinking() &#123; ResetBoard(snake, *food, board); glm::ivec2 move; if (RefreshBoard(snake, *food, board))//可以吃到食物 move = FindSafeWay();//找到一条安全的路 else move = FollowTail();//不可吃到食物，跟随尾巴 if(move == glm::ivec2(-1,-1))//不能跟随尾巴，任意路径 move = AnyPossibleWay(); return move;&#125; 12345678910111213141516171819202122232425if (this-&gt;State == GAME_ACTIVE ) &#123;//AI模式 //AI策略 glm::ivec2 move = algorithm-&gt;AIThinking(); //没找到任何路径，游戏结束 if (move == glm::ivec2(-1, -1))this-&gt;State = GAME_LOST; else &#123; //走出一步 bool isCollision = algorithm-&gt;make_move(move); if (isCollision) &#123;//碰撞,boom fireindex = (fireindex + 1) % 3; firetimer[fireindex] = 2.0f; firework-&gt;Position = food-&gt;Position; boom[fireindex]-&gt;Reset(); boom[fireindex]-&gt;Update(0.f, *firework, 400, firework-&gt;Size / 2.0f, 3, fireindex); sound-&gt;play2D(\"../res/Audio/get.wav\", GL_FALSE); //获取一分 ++score; &#125; if (algorithm-&gt;win) &#123;//满屏了 State = GAME_WIN; return; &#125; food-&gt;Position = Index(algorithm-&gt;food-&gt;Index);//更新食物位置 &#125;&#125; 算法类：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697struct Object &#123; glm::ivec2 Index;//数组下标 glm::vec3 Color;//颜色 Object(int r,int c) :Index(r, c) &#123; int decision = rand() % 4; switch (decision) &#123; case 0:Color = glm::vec3(0.2f, 0.6f, 1.0f); break; case 1:Color = glm::vec3(0.0f, 0.7f, 0.0f); break; case 2:Color = glm::vec3(0.8f, 0.8f, 0.4f); break; case 3:Color = glm::vec3(1.0f, 0.5f, 0.0f); break; default: Color = glm::vec3(1.0f, 0.5f, 0.0f); break; &#125; &#125;&#125;;//算法逻辑类class Algorithm&#123;public: Algorithm(GLuint x,GLuint y); //随机产生新的食物 glm::ivec2 NewFood(); //重置 void ResetBoard(const std::list&lt;Object&gt; &amp;psnake, const Object &amp;pfood, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;pboard); void ResetSnakeAndFood(); //广度优先遍历整个board的情况 bool RefreshBoard(const std::list&lt;Object&gt; &amp;psnake, const Object &amp;pfood, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;pboard); glm::ivec2 FindSafeWay();//找到一条安全的路径 glm::ivec2 AnyPossibleWay();//随便找一条路 glm::ivec2 AIThinking();//AI思考 void Display(); bool make_move(glm::ivec2 step);//移动蛇身 void VirtualMove();//虚拟探测性检测 bool IsTailInside();//评测是否蛇尾和蛇头之间有路径 glm::ivec2 FollowTail();//朝蛇尾方向走 std::list&lt;Object&gt; snake;//蛇 std::shared_ptr&lt;Object&gt; food;//食物 bool win; private: //行数、列数 GLuint row, col; std::vector&lt;std::vector&lt;int&gt; &gt;board;//用来标记board中每个位置的状况，0是空的，1是蛇身，2是食物 //虚拟记录贪吃蛇的情况 std::vector&lt;std::vector&lt;int&gt; &gt;tmpboard; std::list&lt;Object&gt; tmpsnake; int EMPTY, SNAKE, FOOD; //边界判断 inline bool CouldMove(glm::ivec2 &amp;target) &#123; if (target.x &lt; 0 || target.x &gt;= row)return false; if (target.y &lt; 0 || target.y &gt;= col)return false; return true; &#125; //二维数组的结点向上、下、左、右四个扩展方向 const int dir[4][2] = &#123; &#123; -1,0 &#125;,&#123; +1,0 &#125;,&#123; 0,-1 &#125;,&#123; 0,+1 &#125; &#125;; //找到一条最短的路径的方向 inline glm::ivec2 ShortestMove(glm::ivec2 target, const std::vector&lt;std::vector&lt;int&gt; &gt; &amp;pboard)&#123; int minv = SNAKE; glm::ivec2 move(-1,-1); for (auto x = 0; x &lt; 4; ++x) &#123; glm::ivec2 tmp = glm::ivec2(target.x + dir[x][0], target.y + dir[x][1]); if (CouldMove(tmp) &amp;&amp; minv &gt; pboard[tmp.x][tmp.y]) &#123; minv = pboard[tmp.x][tmp.y]; move = tmp; &#125; &#125; return move; &#125; //找到一条最长的路径的方向 inline glm::ivec2 LongestMove(glm::ivec2 target, const std::vector&lt;std::vector&lt;int&gt; &gt; &amp;pboard) &#123; int mxav = -1; glm::ivec2 move(-1, -1); for (auto x = 0; x &lt; 4; ++x) &#123; glm::ivec2 tmp = glm::ivec2(target.x + dir[x][0], target.y + dir[x][1]); if (CouldMove(tmp) &amp;&amp; pboard[tmp.x][tmp.y] &lt; EMPTY &amp;&amp; mxav &lt; pboard[tmp.x][tmp.y]) &#123; mxav = pboard[tmp.x][tmp.y]; move = tmp; &#125; &#125; return move; &#125;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189Algorithm::Algorithm(GLuint x, GLuint y) :row(x), col(y), FOOD(0), EMPTY((row + 1)*(col + 1)), SNAKE(2 * EMPTY)&#123; food = std::make_shared&lt;Object&gt;(NewFood().x, NewFood().y); board.resize(row, std::vector&lt;int&gt;(col, EMPTY)); win = false;&#125;void Algorithm::ResetBoard(const std::list&lt;Object&gt; &amp;psnake, const Object &amp;pfood, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;pboard) &#123; for (auto &amp;t : pboard) std::fill(t.begin(), t.end(), EMPTY); pboard[pfood.Index.x][pfood.Index.y] = FOOD; for (auto &amp;t : psnake) pboard[t.Index.x][t.Index.y] = SNAKE;&#125;glm::ivec2 Algorithm::NewFood() &#123; glm::ivec2 loc; loc.x = rand() % row; loc.y = rand() % col; while (true) &#123; bool found = false; for (auto &amp;x : snake) &#123; if (loc == x.Index) &#123; found = true; break; &#125; &#125; if (!found)return loc; loc.x = rand() % row; loc.y = rand() % col; &#125; return loc;&#125;void Algorithm::Display() &#123; for (auto &amp;t : board) &#123; for (auto &amp;x : t) &#123; std::cout &lt;&lt; x &lt;&lt; \"-\"; &#125; std::cout &lt;&lt; \"\\n\"; &#125;&#125;bool Algorithm::RefreshBoard(const std::list&lt;Object&gt; &amp;psnake, const Object &amp;pfood, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;pboard) &#123; /* 从食物出发，利用广度优先遍历向四周扩散 从而得到pboard中每个格子到达food的路径长度 */ std::queue&lt;glm::ivec2&gt; record; record.push(pfood.Index); std::vector&lt;std::vector&lt;bool&gt;&gt;visited; visited.resize(pboard.size(), std::vector&lt;bool&gt;(pboard[0].size(), false)); visited[pfood.Index.x][pfood.Index.y] = true; glm::ivec2 cur; bool found = false; while (!record.empty()) &#123; glm::ivec2 head = record.front(); record.pop(); //向四个方向扩展 for (auto x = 0; x &lt; 4; ++x) &#123; cur = glm::ivec2(head.x + dir[x][0], head.y + dir[x][1]); //碰到边界或已经访问过了 if (!CouldMove(cur) || visited[cur.x][cur.y])continue; if (cur == psnake.front().Index)found = true;//找到蛇头 if (pboard[cur.x][cur.y] &lt; SNAKE) &#123;//不是蛇身 pboard[cur.x][cur.y] = pboard[head.x][head.y] + 1; record.push(cur); visited[cur.x][cur.y] = true; &#125; &#125; &#125; return found;&#125;bool Algorithm::make_move(glm::ivec2 step) &#123; //直接加入前面 snake.push_front(Object(step.x,step.y)); //如果加的不是食物位置,删掉最后一个 if (snake.front().Index != food-&gt;Index) &#123; snake.pop_back(); &#125; else &#123;//如果吃到食物 if (snake.size() == row*col) &#123; win = true; return true; &#125; food-&gt;Index = NewFood();//重新产生一个新的食物 return true; &#125; return false;&#125;glm::ivec2 Algorithm::AnyPossibleWay() &#123; glm::ivec2 ret = glm::ivec2(-1,-1); ResetBoard(snake, *food, board); RefreshBoard(snake, *food, board); int minv = SNAKE; for (auto x = 0; x &lt; 4; ++x) &#123; glm::ivec2 tmp = glm::ivec2(snake.front().Index.x + dir[x][0], snake.front().Index.y + dir[x][1]); if (CouldMove(tmp) &amp;&amp; minv &gt; board[tmp.x][tmp.y]) &#123; minv = board[tmp.x][tmp.y]; ret = tmp; &#125; &#125; return ret;&#125;void Algorithm::VirtualMove() &#123; tmpsnake = snake; tmpboard = board; ResetBoard(tmpsnake, *food, tmpboard); bool eaten = false; glm::ivec2 move; while (!eaten) &#123;//已确保蛇与食物有路径，所以不会陷入死循环 //搜索路径 RefreshBoard(tmpsnake, *food, tmpboard); move = ShortestMove(tmpsnake.front().Index, tmpboard);//找到最短的一步 tmpsnake.push_front(Object(move.x, move.y));//加入蛇头 if (move == food-&gt;Index) &#123;//如果走到了食物那里 eaten = true; ResetBoard(tmpsnake, *food, tmpboard); tmpboard[food-&gt;Index.x][food-&gt;Index.y] = SNAKE;//食物被蛇吃掉了 &#125; else &#123;//还没吃到食物 tmpsnake.pop_back(); &#125; &#125;&#125;bool Algorithm::IsTailInside() &#123; //将蛇尾看成食物 tmpboard[tmpsnake.back().Index.x][tmpsnake.back().Index.y] = FOOD; tmpboard[food-&gt;Index.x][food-&gt;Index.y] = SNAKE; Object tail(tmpsnake.back().Index.x, tmpsnake.back().Index.y); bool ret = RefreshBoard(tmpsnake, tail, tmpboard); for (auto x = 0; x &lt; 4; ++x) &#123; glm::ivec2 tmp = glm::ivec2(tmpsnake.front().Index.x + dir[x][0], tmpsnake.front().Index.y + dir[x][1]); if (CouldMove(tmp) &amp;&amp; tmp == tail.Index)ret = false; &#125; return ret;&#125;glm::ivec2 Algorithm::FollowTail() &#123; tmpsnake = snake; ResetBoard(tmpsnake, *food, tmpboard); //将蛇尾看成食物 tmpboard[tmpsnake.back().Index.x][tmpsnake.back().Index.y] = FOOD; tmpboard[food-&gt;Index.x][food-&gt;Index.y] = SNAKE; Object tail(tmpsnake.back().Index.x, tmpsnake.back().Index.y); RefreshBoard(tmpsnake, tail, tmpboard); //还原，排除蛇头与蛇尾紧挨着 tmpboard[tmpsnake.back().Index.x][tmpsnake.back().Index.y] = SNAKE; return LongestMove(tmpsnake.front().Index, tmpboard);&#125;glm::ivec2 Algorithm::FindSafeWay() &#123; VirtualMove();//虚拟蛇移动吃食物 if (IsTailInside())//检查吃完食物后蛇头与蛇尾之间是否存在路径 return ShortestMove(snake.front().Index, board); glm::ivec2 move = FollowTail();//没有路径则跟随尾巴 return move;&#125;//AI思考glm::ivec2 Algorithm::AIThinking() &#123; ResetBoard(snake, *food, board); glm::ivec2 move; if (RefreshBoard(snake, *food, board))//可以吃到食物 move = FindSafeWay();//找到一条安全的路 else move = FollowTail();//不可吃到食物，跟随尾巴 if(move == glm::ivec2(-1,-1))//不能跟随尾巴，任意路径 move = AnyPossibleWay(); return move;&#125;void Algorithm::ResetSnakeAndFood() &#123; snake.clear(); snake.push_back(Object(row / 2 - 1, col / 2 - 1)); snake.push_back(Object(row / 2 - 1, col / 2 + 0)); snake.push_back(Object(row / 2 - 1, col / 2 + 1)); food-&gt;Index = NewFood(); win = false;&#125; 实现展示动态gif，只录了很小的一部分。整个格子设置得太大了点，27*27。 格子设置太大也导致了后期的情况非常复杂，满屏的难度的比较大，几乎都是差了几个格子然后陷入了死胡同或者陷入了死循环（一直追着蛇尾跑）。嗯，贪吃蛇AI在这里表现可以说是差不多是98%吧。设置得格子比较少的时候，是有满屏的。格子较少的满屏：格子较多（27*27）时的最终结果，已经接近大圆满的程度了： 整个工程以及可执行exe可以在github下载：https://github.com/ZeusYang/Breakout其中的GreedySnake就是本工程项目目录。 参考博客：http://blog.renren.com/share/265863809/15651358712/2","categories":[],"tags":[{"name":"Greedy Snake","slug":"Greedy-Snake","permalink":"http://yoursite.com/tags/Greedy-Snake/"},{"name":"OpenGL","slug":"OpenGL","permalink":"http://yoursite.com/tags/OpenGL/"},{"name":"Particle Effect","slug":"Particle-Effect","permalink":"http://yoursite.com/tags/Particle-Effect/"}]},{"title":"基于GPU预计算的大气层光效渲染","slug":"atmosphere","date":"2019-04-25T11:25:47.417Z","updated":"2019-04-25T12:25:08.190Z","comments":true,"path":"2019/04/25/atmosphere/","link":"","permalink":"http://yoursite.com/2019/04/25/atmosphere/","excerpt":"本文叙述基于物理模型的大气层光效渲染，不仅考虑单重散射，而且也尝试实现多重散射的效果。主要参考论文为Eric Bruneton和Fabrice Neyret的《Precomputed Atmospheric Scattering》。","text":"本文叙述基于物理模型的大气层光效渲染，不仅考虑单重散射，而且也尝试实现多重散射的效果。主要参考论文为Eric Bruneton和Fabrice Neyret的《Precomputed Atmospheric Scattering》。 基于GPU预计算的大气层光效渲染 前言 大气物理模型 渲染方程及其实现 实验结果 参考文献前言本文叙述基于物理模型的大气层光效渲染，不仅考虑单重散射，而且也尝试实现多重散射的效果。主要参考论文为Eric Bruneton和Fabrice Neyret的《Precomputed Atmospheric Scattering》。博文如果错误，欢迎指出，非常感谢。此外，本文较多物理理论和数学推导，代码也比较多。代码已放至本人的github上：https://github.com/ZeusYang/Atmosphere 大气物理模型1、大气散射现象 大气散射是指，太阳光在射入大气层时，与大气中的空气分子或空气溶胶等发生相互作用，使得入射的光能以一定的规律在各个方向上进行重新分布的现象。太阳光在射入大气层时，遇到大气分子、尘埃、雨滴等颗粒后，都会发生散射现象。其中一部分的光能会被这些粒子吸收转化为热能，而另一部分光能则会以该粒子为中心，向四面八方扩散开来。所以，在经过了大气的散射作用之后，有部分太阳光将无法抵达地球表面。大气散射在自然界中是一种十分重要而又普遍存在的物理现象，人们平时用肉眼观察到的光很大一部分都是散射光。如果没有大气散射，那么只要不是太阳光直接照射到的位置，都将是完全黑暗的。 2、空气物理模型 空气中的介质颗粒根据其直径大小的不同可分为两种：直径远小于光线波长的空气微粒、与直径与光线波长相当的空气溶胶。由前者引起的散射我们称为Rayleigh散射，它是导致晴朗天空呈现蓝色的主要原因。由后者引起的散射我们称为Mie散射，它是导致阴霾的天空呈现灰色的原因，因为阴天的空气中存在大量与光波直径相当的水滴。 ①Rayleigh散射：由空气中远小于波长的微粒(如空气分子)引起的散射称作瑞利散射。Rayleigh散射强度与光线波长的四次方成反比，这意味着白光中波长较短的颜色光(蓝色)会比波长较长的光(红色)有更强的散射强度，导致天空在白天偏向蓝色，而在黄昏偏向橙红色。 当日出或日落的时候，由于太阳的位置接近地平线，阳光斜射入大气，会在大气层中穿过很长的距离。在这个过程中，太阳光中的蓝色光几乎都会被散射殆尽无法抵达人眼，只剩下了波长较长的红色光，所以在太阳及其周围的天空都会呈现橘红色。 Rayleigh散射的散射系数可以使用如下公式计算： $\\beta_R(\\theta)=\\frac{2\\pi^2(n^2-1)^2}{3N\\lambda^4}p_R(\\theta)$ （1） 其中$\\theta$是视线与太阳光线的夹角，$N$是大气分子密度，$n$是大气的折射率，$\\lambda$是入射光的波长，$p_R(\\theta)$是单位化的相位函数。由上可知，Rayleigh散射明显与波长的四次方成反比，在实现中我们可用一个RGB向量来表示，散射系数可表示为： $\\beta_R.rgb=(5.81,13.5,33.1)\\times10^{-6}$ （2） 由于Rayleigh散射几乎是各向同性的，即光线会被粒子向各个方向均匀散射，其相位函数可以表示为： $p_R(\\theta)=\\frac{3}{16\\pi}(1+cos^2\\theta))$ （3） 相位函数描述了散射的方向特征，也就是在视线与光线夹角为$\\theta$的情况，在总共散射的光线中有多少被散射到视线方向上，可以理解为概率或者比例。 ② Mie散射：在空气中直径与波长相当的微粒(如尘埃、雾滴等)所导致的散射现象称作Mie散射。与Rayleigh散射不同，Mie散射与波长无关，散射方向表现出明显的各向异性，光线会被粒子更多的向后方散射。而当阴雨天气时，空气中存在大量的水滴颗粒，Mie散射导致天空呈现灰白色。现今经常出现的雾霆天气，同样是因为空气中悬浮的大颗粒过多而导致的Mie散射现象。 由于Mie散射与波长无关，故可以用标量表示，Mie散射系数为： $\\beta_M.rgb=2.0\\times10^{-5}$ （4） Mie散射的方向是各向异性的，光线会被更多的向后方散射，其相位函数为： $p_M(\\theta)=\\frac{1}{4\\pi}\\frac{3(1-g^2)}{2(2+g^2)}\\frac{1+cos^2\\theta}{(1+g^2-2gcos\\theta)^{\\frac{3}{2}}}$ （5） 在公式（5）中，$\\theta$是光线方向与视线方向的夹角，而$g$表示散射的对称性。若$g$是正值，则大多数光线会被粒子向后方散射；若$g$是负值，则更多的光线会被向前方散射。通常，g取值[-0.75,0.99]。 ③ 大气密度：对于瑞利散射和米氏散射，它们对太阳光的散射作用都和空气粒子的密度有关。许多大气模型都假设摄像机总是在地面上或者是在十分接近地面的位置，这样就可以认为空气具有一个恒定的粒子密度，这就在很大程度上简化了Nishita在1993年提出的散射积分方程，并在近地空间可以得到很好的渲染效果。然而在远离地表的高空，这种做法得到的渲染结果并不准确。 实际中的大气密度在地球引力的作用下，越靠近地表空气密度越高，越远离地表空气越稀薄。所以，我们假定空气粒子的密度是沿着海拔高度h呈指数递减的： $\\rho=\\rho_0e^{-\\frac{h}{H}}$ 其中$\\rho_0$是在海平面的空气密度 （6） $h$为当前采样点的海拔高度，$H$是缩放高度（在实现中可设为大气层高度）。理论上说大气层并没有确定的高度，但在实现中我们需要一个统一高度来渲染天空弯顶，这样空气密度随着高度的增加而呈指数递减。对于Rayleigh散射与Mie散射我们分别使用不同的缩放高度:$H_R=7994km$，$H_M=1200km$。这是因为影响Mie散射的大颗粒(尘埃、水滴等)更多的存在于近地表的对流层中，再往上Mie散射效果不明显，但Rayleigh散射的作用依然存在。 3、光线内散射 太阳光在大气中传输的时候会与空气中的微粒产生交互作用。有两种重要的交互方式:散射，它改变了光线的方向；吸收，它将光能吸收并转变为其它形态的能量（如热能）。而散射效果对场景中物体的影响又分为两个方面：一方面是一部分由物体反射的光被散射到视线之外，并不能到达摄像机，因而被衰减，称作外散射；另一方面是一部分太阳光被空气中的粒子散射正对向摄像机，这些正朝向视线的散射被称作内散射。 最后抵达视点被人眼所观察到的光线可分为两部分：衰减后的物体反射辐射度、被内散射的大气散射辐照度。 $L_{viewer}=L_{object}\\cdot e^{-T(O\\to C)}+L_{inscatter}$ （7） 其中$L_{viewer}$为最终抵达摄像机的总光强，$L_{object}$为物体的反射光（当视线不与物体相交时则为$0$），$L_{inscatter}$为从O到C点路径上所有内散射光线的总和，这里暂时忽略太阳直射。 公式（7）中的$e^{-T(O\\to C)}$是光线从O点到C点的衰减系数，其中$T(O\\to C)$被称作光学深度（Optical Length)，它是散射系数与密度乘积在整条路径上的积分。 ① 光学深度：在上图中，大气层内有一点$P$，它在视线$CO$上。太阳光线照向地球，在穿过大气层的时候会受空气分子和空气溶胶的散射作用而发生衰减（外散射的影响），最终到达$P$点处的光能总量为： $L_p=L_{sun}e^{-T(A\\to P)}$ （8） 其中$L_{sun}$是太阳光到达大气层前的初始辐射度。上图中$A$点是光线到达$P$点之前与大气层的交点，则$T(A\\to P)$被称作$A$点到$P$点的光学深度（Optical Depth），它本质上就是$A$点到$P$点这条路径上散射系数乘上空气密度的积分（包含Rayleigh散射与Mie散射）： $T(A\\to P)=\\int_A^P(\\beta_R^ee^{-\\frac{h(t)}{H_R}}+\\beta_M^ee^{-\\frac{h(t)}{H_M}})dt$ （9） 公式（9）中的参数前面都已提到过：$\\beta_R^e$即Rayleigh散射系数，$\\beta_M^e$是Mie散射系数，而形如$e^{-\\frac{h}{H}}$的则分别是Rayleigh散射粒子密度分布函数、Mie散射粒子密度分布函数。在这里我们散射系数当作一个在海平面上的常数值，则式（9）可变为如下形式： $T(A\\to P)=\\beta_R^e\\int_A^Pe^{-\\frac{h(t)}{H_R}}dt+\\beta_M^e\\int_A^Pe^{-\\frac{h(t)}{H_M}}dt$ （10） 所以我们只需对AP路径上的空气密度进行积分，这个积分值被称光学长度（Optical Length），直观的意义就是在光线照射的路径上空气粒子的总量。 ② 散射系数：散射系数决定了散射介质对光线的散射的强弱程度，也反应了光线在通过该介质时的衰减程度。我们已经在前面提到，Rayleigh散射对不同波长的光线散射强度不同，在实现中我们可以将其在海平面处的散射系数设为一个三维向量： $\\beta_R.rgb=(5.81,13.5,33.1)\\times10^{-6}$ 而Mie散射对波长的变化影响不明显，所以可以将其在海平面上的散射系数设为标量： $\\beta_M.rgb=2.0\\times10^{-5}$ ③ 相位函数：己知入射光能和介质的散射系数，我们就可以计算出有多少光线会被介质散射出去。但并非所有的光线在散射之后都会朝向摄像机，有一部分会被散射到其它方向，无法被肉眼所观察到(称作外散射)。所以为了计算内散射的光线量，还需要有另外一个因子描述这个物理量。而相位函数$p(\\theta)$则描述了在该点有多少光线散射之后朝向摄像机，其中的参数$\\theta$是太阳光到点$P$的向量$LP$与点$P$到摄像机位置的向量$PC$的夹角，如下图所示。 相位函数是标准化的，函数本身在所有方向的积分为$1$。Rayleigh散射特点是各向同性，光线会以介质粒子为中心均匀地向各个方向散射，其相位函数是前面提到的公式（3）。而Mie散射呈现明显的各向异性，光线会被更多的介质粒子向后方散射，其相位函数是前面提到的公式（5）。 ④ 单重散射：目前我们讨论的都是单重散射，即太阳光在到达视点之前只会进行一次散射。点$P$的内散射光在达到视点前还会受到空气颗粒影响而衰减，衰减程度取决于点$P$到点$C$（视点）的光学深度$T(P\\to C)$，因而衰减因子为$e^{-T(P\\to C)}$。 所以最终达到视点C的内散射方程如下： $L_{inscatter}=\\int_C^OL_{sun}\\cdot e^{-T(A(s)\\to P(s))}\\cdot e^{-T(P(s)\\to C)}\\cdot (\\beta_R^se^{-\\frac{h(s)}{H_R}}p_R(\\theta)+\\beta_M^se^{-\\frac{h(s)}{H_M}}p_M(\\theta))ds$（10） 上式中有两个衰减因子，一个是从$A$到$P$的衰减因子，一个是从$P$到$C$的衰减因子。整个积分路径是从$O$到$C$，这一方程描述了从$O$到$C$路径上全部内散射光的总和。 内散射积分公式（10）中，在积分路径OC上太阳光与视线的夹角$\\theta$保持不变，因此有必要将相位函数$p(\\theta)$从积分内部中提取出来。而太阳光是平行光，$L_{sun}$是大阳光在大气层顶层的辐射度，视为常量，也可从积分内部提取出来。散射系数亦如此。故公式（10）可变为如下： $L_{inscatter}=L_{sun}p_R(\\theta)\\beta_R^s\\int_C^Oe^{-T(A(s)\\to P(s))-T(P(s)\\to C)}e^{-\\frac{h(s)}{H_R}}ds+L_{sun}p_M(\\theta)\\beta_M^s\\int_C^Oe^{-T(A(s)\\to P(s))-T(P(s)\\to C)}e^{-\\frac{h(s)}{H_M}}ds$ （11） 故要计算一个视点到物体之间的内射光线，我们需要对视线路径上每一点的衰减因子以及空气密度进行积分。 ⑤ 多重散射：光线在传输过程中被空气中的一个粒子影响，称为光的一次散射。当空气中大颗粒较多时，被粒子散射的光又会被散射方向上的其它粒子再次散射，这个过程称为多重散射（Multiple Scattering)。在晴朗干净的天空中，由于空气中大粒子的数量较少，多重散射的作用不是很明显。而在空气浑浊或黄昏时，多重散射会对场景的真实性产生较明显的影响。 我们前面的讨论都是单一散射模型。这一模型在白天的时候比较合理，这一假设在白天的时候比较合理，因为在白天的时候太阳光强度较高，多重散射作用不明显;而在傍晚的时候，由于太阳直射光强度变弱，多重散射对场景的影响会变得更加重要，在渲染真实图像中必须加以考虑。即便如此，单一散射模型在此时依旧可以提供一个相对较好的结果。 关于多重散射的文献资料较少，因为单重散射模型目前已经有了不错的渲染结果。在我阅读的这篇论文《Precomputed Atmospheric Scattering》中考虑了多重散射的情况，较为复杂，在后面论述。 ⑥ 体积光：当光线照射到遮挡物时，一部分光线会从物体的边缘和空隙中穿过，并产生很明显的光柱效果，在视觉上给人以很强的体积感，所以称之为体积光（Light shaft)。体积光在自然界中是十分常见的现象，如太阳光从云隙中透过时产生的云隙光，森林中阳光从树叶中穿过产生的光柱。体积光现象有时又被称作“丁达尔效应”。其理论基础同样是光线的散射原理，可以使用前面描述的Mie散射理论来解释。对于溶胶，其粒子大小通常与可见光的波长相当，所以在光线穿过气溶胶时，会发生明显的Mie散射现象，产生肉眼可观察到的光柱体。 渲染方程及其实现为了便于论述，我们记$L(x,v,s)$为视点$x$从方向$v$接收的总的辐射度，其中$s$是太阳方向向量。记$x_0(x,v)$为视线$v$的终点（通常为地面、物体或大气顶层）。$x$到$x_0$之间的衰减因子$T$、$x_0$处的反射辐射度$I$、在某一点$y$向$-v$内散射的辐射度$J$定义如下： $T(x,x_0)=exp(-\\int_x^{x_0}(\\beta_R^e\\rho_R(y)+\\beta_M^e\\rho_M(y))dy)$ （12） $IL=\\frac{\\alpha(x_0)}{\\pi}\\int_{2\\pi}L(x_0,\\omega,s)\\cdot n(x_0)d\\omega ,or 0$ （13） $JL=\\int_{4\\pi}\\sum_{i\\in{R,M}}\\beta_i^s(y)p_i(v\\cdot w)L(y,\\omega,s)d\\omega$ （14） 公式（12）、（13）、（14）对应上图的（a）、（b）、（c）。有了以上的函数表示，现在我们可以定义渲染方程了。 1、渲染方程 $L(x,v,s)=L_0(x,v,s)+RL+SL$ （15） $L_0(x,v,s)=T(x,x_0)L_{sum}, or 0$ （16） $RL=T(x,x_0)IL$ （17） $SL=\\int_x^{x_0}T(x,y)JLdy$ （18） $L(x,v,s)$为视点$x$从方向$v$接收的总的辐射度。$L_0$是到达$x$的太阳直射光，因此当视线$v$与太阳方向向量$s$不相等时$L_0$为0（又或者太阳被遮挡了）。$R[L]$是在点$x_0$收到的反射的辐射度。$S[L]$则是从$x_0$到$x$路径上接收的内散射光。从渲染方程可以看出，衰减因子$T$无处不在，这是因为在大气层内，涉及到光线的传播都要考虑外散射以及光线被吸收的影响。 这个渲染方程计算量非常大，尤其是公式（18），一重积分内部还嵌套了两重积分。纯粹地暴力计算对于实时渲染来说几乎不可能。为了能够实现实时渲染大气层，不少论文提出了查找表的优化思想，这是一种基于预先计算的优化方法。但大多数的论文都只是考虑了单重散射，我阅读的这篇论文《Precomputed Atmospheric Scattering》将多重散射也考虑进去了，提出了一种4维查找表的方法，在后面论述。除此之外，渲染方程也设计到大量的积分计算。为此，我们采用梯形法则和光线步进（Ray Marching）来快速计算数值积分。 下面的叙述部分，由于代码比较繁多，我尽量用伪代码描述。 2、光线衰减因子 前面已经提到过，从$x$的$x_0$光线衰减因子如下（实际计算中把散射系数提出积分外）： $T(x,x_0)=exp(-\\int_x^{x_0}(\\beta_R^e\\rho_R(y)+\\beta_M^e\\rho_M(y)dy)$ 每一帧去计算它并不现实，因此早在1994年就有人提出了查找表的优化方法。如下图所示，假设我们要计算$p$到$q$的衰减因子。$i$是$p$点沿视线与大气顶层的交点。则有：$p$到$i$的衰减因子=$p$到$q$的衰减因子乘上q到i的衰减因子（这里相乘的原因是决定衰减因子的光学深度是在其公式的指数位置上，衰减因子相乘等于相应的指数相加）。那么$p$到$q$的衰减因子=$p$到$i$的衰减因子除以$q$到$i$的衰减因子。因此只要知道点到大气顶层的衰减因子，就可计算任两点之间的光线衰减因子。 此外，O’ Neil发现了衰减因子的计算取决于两个参数:当前点的高度$r$和视线的天顶角$\\theta$。也就是说我们可以通过预先计算($r$,$\\theta$)的全部组合决定的衰减因子存放到一张纹理中，后面的实时计算直接根据需要计算的($r$,$\\theta$)查找这张纹理。为了方便，我们取参数($r$,$cos\\theta$)，记$u=cos\\theta$。 ① 点p到大气顶层的距离：即计算向量$pi$的长度。建立如图所示的坐标系，点$O$为地心，则向量$pi$距离点$p$为$d$的一点坐标($x$,$z$)为:($d\\sqrt{1-u^2}$,$r+du$) 那么设距离$d$为向量$pi$的长度，则($x$,$z$)即为点$i$的坐标。已知大气层半径为$r_{top}$，则由勾股定理有：$(d\\sqrt{1-u^2})^2+(r+du)^2=r_{top}^2$，整理后即为二元一次方程：$d^2+2rud+r^2=r_{top}^2$，其中$r$、$u$和$r_{top}$已知，可求出距离$d$。同样可通过该二元一次方程的判别式判断是否有解，从判断射线($r$,$u$)是否与大气层（或地表）存在交点。 点p到地球表面交点的距离同理，将$r_{top}$换成$r_{bottom}$即可。 ② 计算点p到i（与大气顶层的交点）的光学长度：计算衰减因子需要计算点$p$到$i$的光学深度，也就是对$p$到$i$的散射系数和空气密度乘积进行积分。其中散射系数（包括Rayleigh散射和Mie散射）系数我们取海平面上相应的散射系数，故我们只需对$p$到$i$路径的空气密度进行积分，这就是光学长度–$\\int_p^i\\rho(s)ds$。 计算积分我们采用梯度法，以光线步进（Ray Marching）循环采样计算累加和。如下图所示，假设我们取$P_1$-$P_5$这五个采样点，依次计算每个点的空气密度乘上积分步长，累加计算。计算Rayleigh光学长度和Mie光学长度均采用以上的方法计算。分别采用以上方法计算之后，再乘上相应的散射系数，就是光学深度，然后衰减因子就按照公式（12）计算即可。 ③ 坐标映射：我们把预计算的结果存入一张2D的纹理中，所以需要将($r$,$u$)映射到纹理坐标($u_r$,$v_u$)中。我们知道纹理坐标数值范围是$[0,1]$，故对于一个数值$x$，我们首先要将$x$映射到$[0,1]$，设$x$的值域为$[min,max]$。则令$x = (x-min)/(max-min)$，可将其映射到$[0,1]$。 然而值得注意的是，将$x$映射到$[0,1]$之后，边界部分我们应该要去掉。这是因为我们在对纹理进行查找时需要线性插值，边界部分会产生一些外推值。为了避免这种情况，我们进一步令$x$（此时$x$已属于$[0,1]$）： $x=\\frac{1}{2n}+x*(1.0-\\frac{1}{n)}$，其中$n$是纹理的大小，$\\frac{1}{n}$就是一个纹素的大小。如此我们将$x$由$[0,1]$映射到了$[\\frac{1}{2n},1-\\frac{1}{2n}]$上，去掉了边界部分。 接下来我们要将$r$映射到$u$，而$u$映射到$v$。 对于$r$，它代表当前点到地心的距离，显然其值域为$[r_{bottom},r_{top}]$。然而为了更高的精度（避免r接近地表时失真），我们采用了一个非线性映射的方式。如下图所示，实际上对于每个不同$r$，都对应着一个不同的$\\rho$，它是视点$p$到过视点的与地表相切的切线的切点的距离，$\\rho$的最大值则是如下图中的$H$（最小值为$0$）。故对于$r$我们采用该映射方式映射到$u_r$：$u_r=\\frac{\\rho}{H}$。 对于天顶角$u$，每个特定的天顶角，都对应着不同的距离$d$（视点到大气顶层交点的距离）。$d$的下界为$r-r_{bottom}$，上界为为$\\rho+H$。故其映射方式为：$v_u=\\frac{d-d_{min}}{d_{max}-d_{min}}$。 至于计算($\\rho$,$H$)，可以通过两个三角形勾股定理，不再赘述。我们将($r$,$u$)映射到2D纹理坐标，同样也需要逆过程，这将在预计算阶段用到。逆过程我们将上面的几个公式反推一下即可，也不再赘述。 ④ 点p到太阳的光线衰减因子：我们需要计算点$p$到太阳的光线衰减因子。太阳不是一个点光源，而是一个圆盘发光体。因此$p$到太阳的光线衰减因子，是以太阳圆盘为区域的衰减因子的积分。在这里我们把太阳圆盘区域上的衰减因子视作相同的常量。故该值等于衰减因子乘上太阳圆盘在水平线上部分占整个圆盘的比例。 设过视点p与地表相切的切线为l。当太阳天顶角$\\theta_s$大于切线l的天顶角$\\theta_h$+太阳的角半径$\\alpha_s$时，这部分比例为$0$；当$\\theta_s$小于$\\theta_h-\\alpha_s$时为$1$。故我们可以用相应的余弦值来定性地衡量这一比例（注意余弦函数在$[0,\\pi]$递减）。 当$cos\\theta_s\\leq cos(\\theta_h+\\alpha_s)\\approx cos\\theta_h-\\alpha_s sin\\theta_h$时，为$0$；（约等符号是因为$\\alpha_s→0$) 当$cos\\theta_s\\geq cos(\\theta_h-\\alpha_s)\\approx cos\\theta_h+\\alpha_s sin\\theta_h$时，为$1$。 中间部分则用埃尔米特（Hermite）插值，可直接用GLSL的smoothstep函数。 3、单重散射 单重散射是指光线在到达视点之前只发生了一次散射。接下来将叙述如何计算单重散射，如何将其映射到3D纹理上。如下图，$u$是视点$p$处实现的天顶角的$cos$值，假设太阳到达$q$点发生了散射，$pq$的距离为$d$，$u_s$是太阳光方向向量在$p$处的天顶角$cos$值，$w_s$是太阳光方向向量，$v$是太阳光方向向量与视线$pq$夹角的$cos$值，$u_{s,d}$是太阳光方向向量在$q$处的天顶角$cos$值。$r$是点$p$到地心的距离，$r_d$是点$q$到地心的距离。 到达p点的内散射辐射度为： $L_{inscatter}=\\int_P^iL_{sun}\\cdot e^{-T(A(s)\\to P(s))}\\cdot(\\beta_R^se^{-\\frac{h(s)}{H_R}}p_R(\\theta)+\\beta_M^se^{-\\frac{h(s)}{H_M}}p_M(\\theta))ds$ 其中的$L_{sun}$和两个相位函数我们先不管，计算内散射辐射度我们需要多p到大气顶层交点之间对光线衰减因子和空气密度进行积分。以上图积分点$q$为例，我们需要$q$到太阳的光线衰减因子、$p$到$q$的光线衰减因子，而这两个值可直接借助查找我们前面已经计算好的纹理获得。故对一个积分采样点，其积分函数值计算的伪代码如下。 ① 内散射积分：同样地，我们采用梯度法和光线步进法进行积分。积分路径的终端实际上不一定是大气顶层，有可能是地表，但积分过程都是一样。 ② 相位函数：对于Rayleigh相位函数和Mie相位函数，直接分别套用公式（3）和公式（5）。 ③ 坐标映射:计算单重散射积分同样非常耗费性能。因此我们一样使用预计算查找表的方法计算单重散射积分。与光线衰减因子不同的是，单重散射积分取决于四个参数，就是前面提到的($r$,$u$,$u_s$,$v$)，这意味着我们需要将这四个参数映射到4D纹理坐标。 对于$(r,u)$的坐标映射，与前面的提到的映射方法相同，这里不再赘述。 对于$v$，其值域为$[-1,1]$，我们做简单的线性映射，令$u_v=\\frac{1+v}{2}$。 对于$u_s$，通过非线性映射，如下所示（原因不明）： $a=\\frac{d-d_{min}}{d_{max}-d_{min}}$， $A=\\frac{-2.0u_{s_min}r_{bottom}}{d_{max}-d_{min}}$， $u_{u_s}=\\frac{max(1.0-\\frac{a}{A},0.0)}{1.0+a}$ 而逆过程则直接根据上述公式倒推即可。现在我们把($r$,$u$,$u_s$,$v$)映射到了4D纹理坐标，然而实际上纹理维度最多3D。故映射到4D之后，我们还要将4D坐标映射到3D坐标。为此，我们可通过取整、取模来实现。 4、多重散射 在考虑多重散射的时候，渲染方程就变为： $L=L_0+L_1+L_2+…=L_0+L_*$ （18） 其中$L_i$代表光线散射$i$重。事实上，在白天的时候多重散射的效果微乎其微，而在傍晚的时候效果较为明显一点。因此实现多重散射是性价比非常低的事情，计算量比单重散射多很多，但是渲染的提升效果可以说是非常小了。 多重散射的来源有两个：一个是经过$(n-1)$次散射之后再发生了一次散射，而另一个是从地面的反射的光线。在这里我们先暂时不讨论地面的反射。多重散射可以分解成$2$重散射、$3$重散射、$4$重散射…等等$n$重散射的累加和。而且，第$i$重散射可以根据第$i-1$重散射计算得到。 先讨论视点$p$接收到的第$n$重散射，设视点$p$沿视线$v$的终端为$i$，$q$为路径$pi$上的任意一点。对于$q$点，我们要计算$q$点接收的经过$n-1$重散射（第$n$重散射时发生内散射，射向视点）的辐射度，这需要对整个球体方向进行积分，是二重积分的计算量。然后我们需要对路径$pi$上所有的$q$点（$q$点是$pi$上的一点）进行积分，是一重积分的计算量。由此我们可以知道，计算第$n$重散射，一重积分里面嵌套了两重积分，为三重积分的计算量。如果对于每一重散射的计算，都从头开始的话，这必然导致很大的计算量，而且有不少重复的计算。 为此，对于多重散射，我们采用迭代的方式来一重一重地计算，而且同样采用查找表的优化方法。每计算一重散射，我们把结果存储到纹理中，然后下一重的散射计算就直接查找这个纹理。如此，我们通过迭代的方式避免前一重的散射计算。 然而即便如此，以三重积分的方式计算第n重散射依然存在着不少重复的部分。如下图所示，设$L$为$q$点接收的经过$n-1$重散射最后第$n$重散射到$-w$方向的总的光线辐射度。如果以三重积分计算$n$重散射，那么在$p$点和$p’$点都会重复地计算到$L$。事实上，对于$p$点到$q$点之间所有的点，都会重复地计算$L$。显然，为了性能考虑，我们必须避免这一重复的部分。以空间换时间是个不错的方法。 最终，对于计算$n$重散射我们分两步走： 第一步：对于$p$点沿视线$w$上的每一个点$q$，我们计算$q$点接收的经过$n-1$重散射的辐射度，这需要两重积分； 第二步：在$p$点沿视线$w$的路径上，计算第$n$重散射，我们查找第一步计算得到的纹理，这只需单重积分。 ① 第一步：计算$q$点接收的经过$n-1$重散射的光线（第$n$重散射射向$-w$）。 如下所示，对于所有可能的方向$w_i$，我们需要计算从$w_i$方向接收的入射辐射度$L_i$。$L_i$由两部分组成：一部分是$n-1$重散射的辐射度（可以直接查找$n-1$重散射的纹理得到）；另一部分是当射线$w_i$与地面相交时，我们需要考虑地面的反射辐射度。 $n-1$重散射辐射度由前面的迭代计算得到，不再讨论。我们需要重点讨论的是地面的反射辐射度。设射线($q$,$w_i$)与地面的交点为$r$，那么从地面接收的反射辐射度应该是以下几项的乘积： 点$q$和点$r$之间的光线衰减因子； 地面的平均反照率； 地面的Lambertian BRDF函数的$1/\\pi$； 地面接收的经过$n-2$次散射辐照度，这是个半球方向的积分，我们将在后面讨论，现在假设我们已经可以计算得到。 ② 第二步：第二步就是利用第一步的计算结果进行单次积分。在$p$点沿视线$w$的路径上，计算第$n$重散射，我们查找第一步计算得到的纹理。对于$p$到边界交点的每一个点$q$，设$q$计算得到的$n-1$重散射密度为$L$，则由$q$到$p$的辐射度应该再乘上一个$q$到$p$之间的光线衰减因子。 同样的，我们采用梯度法和光线步进计算$p$到边界路径上的黎曼和。 ③ 坐标映射：与单重散射一样。 5、地面辐照度 地面接收的辐照度是直接辐照度、单重散射或多重散射之后接收的辐照度总和，我们分为直接辐照度和间接辐照度。计算地面接收的辐照度有以下两个目的： 计算$n$重散射的时候，我们需要考虑从地面反射的辐射度； 渲染地面的需要。 ① 直接辐照度：太阳光线直达地面，中间不发生的散射（但是会向外散射导致光强减弱），所以我们将太阳的辐射度乘上地面到大气顶层的光线衰减因子即可。同时，值得注意的是太阳是一个圆盘，我们还需要考虑太阳可见圆盘的比例，这在前面已经讨论过了。比较简单，直接贴代码了。 ② 间接辐照度：间接辐照度考虑单重及多重散射，如下所示，我们需要对以地面法线为轴向的半球方向进行积分。 5、预计算 有了以上的铺垫，我们现在可以将光线衰减因子、单重散射、多重散射以及地面辐照度预先计算到纹理中，然后渲染的时候直接根据相应的参数去查找纹理（需要纹理坐标的映射）从而获取相应的值，如此在渲染时省去了大量的计算，这带来了非常大的性能提升。 实验结果演示的是一个非常简单的场景，地球以及地球表面上的球体。由于仅仅只有两个球体，那么绘制轮廓部分用光线追踪的办法是非常简单的，而且在片元着色器也很容易实现，只需求解几个二元一次方程即可。而光照部分则是查找前面已经计算好的散射纹理。 ① 实验平台: 操作系统: Windows8.1 IDE: Qt Creator 语言: C++ API: OpenGL3.3+, Qt 5.7 ② 可调参数: 太阳光谱:选择常量值还是真实值（通过真实的太阳光谱线性插值） 臭氧层:是否开启臭氧层（臭氧层也会吸收一部分光线） 散射重数:最低为$1$（即只考虑单重散射） 体积光:是否开启丁达尔效应 Rayleigh散射:是否开启rayleigh散射 Mie散射:是否开启Mie散射 Mie散射对称系数:控制Mie散射的方向性，为正则向后散射，为负则向前散射 ③ 实验结果： 1）、首先，把Rayleigh散射和Mie散射都关闭了，也就是说相当于没有大气层的存在，和月球上的情况相似，所以天空不再是蓝色而是黑色（直接看到外太空了），太阳周围也不会出现光晕。而且由于没有散射，那么阴影部分（非太阳直射的地方）将完全漆黑。 2）、现在把Rayleigh散射和Mie散射都开启。 3）、仅开启Rayleig散射，这时由于没有Mie散射，也就是我们剔除了气溶胶的作用，天空的朦胧感降为$0$，天空看着很清澈，这与我们的生活经验一致。 4）、而如果仅开启Mie散射，那么天空不会呈现蓝色，而是呈现如下情况。可以看出，Mie散射呈现的是一种丁达尔效应的朦胧感。 5）、单重散射、多重散射的对比。实现的最大难度在于多重散射，需要编写大量的代码，而且占用更多的空间，但是提升的效果其实很小。如下图。对比上面的几张图，可以看到其实单重散射的效果已经非常不错了。而且散射重数多了其实区别也不大。 6）、体积光效果：体积光效果是大气光效渲染比较复杂的一个方面，但是实现的话看起来是很令人震撼的。遗憾的是，论文作者提出的体积光实现是基于阴影体的，简单场景没什么问题，但是比较复杂的就不太现实了。 7）、Mie散射对称系数:控制Mie散射的方向性，为正则向后散射，为负则向前散射。为正时越大向后散射得越多。 8）、调整曝光率可以出现一些有趣的光效。 9）、一些从外太空观察的效果。此外，值得注意的是，渲染的速度非常快，FPS稳定在$60$。基于预先计算的查找表的优化方法把渲染时大量的计算挪到程序启动的初始阶段，而且开始阶段耗费时间也不多，最多两三秒。对于散射重数低于$10$的，几乎是秒开。 参考文献1、《Precomputed Atmospheric Scattering》 2、《SIGGRAPH 2009 - Lighting Research at Bungie》 3、《基于GPU的实时大气散射渲染优化算法研究与实现_方辰》 4、《PreethamSig2003CourseNotes》 5、《数字地球大气散射的GPU实现》 6、《基于GPU的行星大气散射效果实时渲染技术研究_刘维敏》 7、《基于GPU的地球大气散射现象可视化仿真_杜芳》 8、《多重散射的天空光照效果建模与实时绘制_艾祖亮》","categories":[],"tags":[{"name":"Computer Graphics","slug":"Computer-Graphics","permalink":"http://yoursite.com/tags/Computer-Graphics/"},{"name":"Atomsphere Rendering","slug":"Atomsphere-Rendering","permalink":"http://yoursite.com/tags/Atomsphere-Rendering/"},{"name":"BRDF","slug":"BRDF","permalink":"http://yoursite.com/tags/BRDF/"}]},{"title":"流体模拟基础","slug":"fluidSimulation","date":"2019-04-25T11:05:00.167Z","updated":"2019-04-25T12:24:36.367Z","comments":true,"path":"2019/04/25/fluidSimulation/","link":"","permalink":"http://yoursite.com/2019/04/25/fluidSimulation/","excerpt":"本文主要参考文献《FLUID SIMULATION SIGGRAPH 2007 Course Notes》，结合我的理解单纯地讲述一下流体渲染的一些基础知识，本人水平有限，如有错误，欢迎指出。本文只是单纯针对流体模拟领域，可能一些地方不太严谨，但是对于虚拟模拟来说是可行的。即便如此，本文涉及到大量的数学方法。","text":"本文主要参考文献《FLUID SIMULATION SIGGRAPH 2007 Course Notes》，结合我的理解单纯地讲述一下流体渲染的一些基础知识，本人水平有限，如有错误，欢迎指出。本文只是单纯针对流体模拟领域，可能一些地方不太严谨，但是对于虚拟模拟来说是可行的。即便如此，本文涉及到大量的数学方法。 前言 矢量微积分 Naiver-Stokes偏微分方程组 N-S方程的分步求解 对流算法 前言 本文主要参考文献《FLUID SIMULATION SIGGRAPH 2007 Course Notes》，结合我的理解单纯地讲述一下流体渲染的一些基础知识，本人水平有限，如有错误，欢迎指出。本文只是单纯针对流体模拟领域，可能一些地方不太严谨，但是对于虚拟模拟来说是可行的。即便如此，本文涉及到大量的数学方法。 一、矢量微积分高等数学中太多数讨论的是一维的微积分，而矢量微积分则是一维微积分的高维扩展。矢量微积分的三个基础算子：梯度（符号为），散度（符号为)，旋度（符号为），在此基础上流体力学中经常用到的还有拉普拉斯算子。 1、梯度（Gradient）梯度实际上就是矢量的空间偏导数，且结果依然是一个矢量，维的梯度如下： 依此类推，维的梯度有如下形式： 有时也会采用如下形式来表示梯度： 梯度通常用来近似计算函数值（实际上就是一维形式的推广)： 同样的，多个函数的梯度就构成了一个矩阵： 2、散度（Divergence）散度算子仅仅应用于向量场，它衡量在某一点出相应的矢量聚集或者发散程度，测量方向为径向，结果为标量。维、维形式的散度算子如下所示： 输入是矢量，而输出为标量。类比梯度，散度符号可以理解为梯度与矢量的点乘： 若矢量场散度为，则称该矢量场无散度。 3、旋度（Curl）旋度衡量围绕某一点的旋转速度，测量方向为切向，三维形式的旋度是一个向量： 倒推到维，我们取上式中的，即矢量场为，维向量场的旋度是一个标量： 同样地，旋度符号我们可以理解为梯度与矢量场的叉乘： 若矢量场旋度为，则称该矢量场无旋度。 4、拉普拉斯算子（Laplacian）拉普拉斯算子定义为梯度的散度，符号表示为，显然是散度，而后面的则为梯度，故拉普拉斯算子即梯度的散度，是一个二阶微分算子。维、维形式分别如下： 简言之，拉普拉斯算子定义如下： 偏微分方程被称为拉普拉斯方程；而如果右边为某个非常数，即，我们称之为泊松方程。更一般地，如果梯度再乘上一个标量（如)，即，我们依旧称之为泊松问题。 二、偏微分方程组流体模拟器的构建主要围绕著名的不可压缩方程展开，它是一个流体力学领域的偏微分方程，方程形式如下： 这个方程组看起非常地复杂，接下来我们就把它剖析成一个个比较简单的部分来理解。 1、符号标记我们有必要定义一些物理量的符号用以标记： 符号在流体力学中通常表示为流体的速度矢量，记维的速度矢量； 希腊字符是流体的密度，对于水，该值大约为，而空气则大约为； 字符代表压力，流体对任何物体施加的单位面积力； 字符则是我们熟悉的重力加速度，通常取。我们约定轴向上，而轴和轴在水平面上。另外补充一点，我们把其他的一些类似的力都累加到上，也就是我们统一用表示所有类似力之和，这类力我们称之为体积力（称之为体积力是因为它们的力是作用到整个流体而不只是流体的表面）； 希腊字符是流体的运动粘度，它衡量流体的黏滞性。糖蜜之类的流体有非常高的粘度，而像酒精之类的流体有很低的粘度； 其它一些矢量微积分的符号算子前面已经提到过，不再赘述。 2、动量方程偏微分方程我们称之为动量方程，它本质上就是我们熟悉的牛顿定律的形式，描述了施加在流体上的力是如何影响流体的运动。 假设我们用粒子系统来模拟流体，每个粒子代表流体的一小滴，每个粒子有各自的质量、体积和速度。为了让整个粒子系统运作起来，我们必须弄清楚每个粒子所承受的力的作用。牛顿第二定律告诉我们：，而根据加速度定义，我们有： 符号是指物质导数，所谓物质导数，就是对流体质点求导数，而且是针对流体质点（在这里就是流体粒子）而不是空间的固定点。因而牛顿第二定律就变成： 那么流体粒子承受的力有哪些呢？一个最简单的力就是重力：。而其他的流体质点（或其他流体粒子）也会对当前的流体粒子产生作用力。流体内部的相互作用力之一便是压力，较大压力的区域会向较低压力区域产生作用力。值得注意的是，我们只关注施加在粒子上的压力的净合力。例如，若施加在粒子上压力在每个方向上都相等，那么它的压力的合力便为0。我们用压力的负梯度（取负是因为方向是由压力大的区域指向压力小的区域）来衡量在当前流体粒子处压力的不平衡性，即取。那么流体粒子所承受的压力就是对在整个流体粒子的体积上进行积分，为了简化，我们简单地将与相乘，故粒子压力部分为。 其他的流体相互作用力则是由流体的黏性产生的，我们直观地把这种力理解为尽可能使得粒子以周围区域的平均速度移动的力，也就是使得粒子的速度与周围区域粒子速度的差距最小化。拉普拉斯算子是衡量一个量与之周围区域该量平均值之差的算符，因而是当前粒子速度矢量与周围区域平均速度矢量之差。为了计算粘滞力，我们同样对在整个粒子体积上进行积分，与前面类似，我们简单取。除此之外，我们还引进一个称为动力粘度系数的物理量，符号为。因而粘滞力为。 把重力、压力和粘滞力综合一起，我们可得： 当粒子系统中的粒子数量趋于无穷大，而每个粒子大小趋于时，会产生一个问题：此时每个粒子的质量和体积变为，此时上式变得没有意义。为此，我们把式调整一下，两边同除以体积，又因，故有： 两边同除以，移项调整： 为了进一步简化，定义运动粘度为，式变为： 我们已经快把动量方程推导出来，现在我们要把物质导数弄清楚，为此，我们需要了解两种描述方法：拉格朗日描述和欧拉描述。 3、拉格朗日描述与欧拉描述当我们尝试研究流体或可变形固体的运动的时候，通常有两种方法来描述：拉格朗日描述（ Lagrangian viewpoint）、欧拉描述（Eulerian viewpoint）。 拉格朗日描述方法是我们比较熟悉的方法，这种描述方法把物体看成是由类似于粒子系统的形式组成，固体或流体的每个点看作一个独立的粒子，粒子有各自相应的位置和速度。我们可以把粒子理解为组成物体的分子。对于我们通常采用拉格朗日描述法进行建模模拟，即用一系列离散的粒子集来构建，粒子之间通过网格相联系。 欧拉描述方法则采用了完全不同的角度，它常被用于流体力学中。与拉格朗日描述追踪每个物体粒子的方法不同，欧拉描述关注点是空间中的一个固定点，并考察在这个固定点上流体性质（如密度、速度、温度等）是如何随着时间变化的。流体流动经过这个固定点可能会导致这个固定点的物理性质发生一些变化（如一个温度较高的流体粒子流经这个固定点，后面紧跟着一个温度较低的流体粒子流过固定点，那么这个固定点的温度会降低，但是并没有任何一个流体粒子的温度发生了变化）。 用天气测量举个简单的例子：拉格朗日描述方法就是你乘坐在一个随风而飘的热气球上，测量周围空气的压力、密度和浑浊度等天气指标；而欧拉描述方法就是你固定在地面上，测量流过的空气的天气指标。 欧拉描述法似乎看起来带来了一些不必要的复杂度，但是目前大多数的流体模拟器都是基于欧拉描述法，这是因为欧拉描述法相比于拉格朗日描述法有一些不可比拟的优点：欧拉描述法能够更加方便地计算一些物理量的空间导数（例如压力梯度和粘度）；而如果用粒子方法的话（即拉格朗日描述法），那么计算物理量相对于空间位置的变化是比较难的。 把拉格朗日描述法和欧拉描述法联系起来的关键点就是物质导数。首先从拉格朗日描述法出发，假设有一群粒子，每个粒子都有各自的位置和速度。记为通用的物理量（如密度、速度和温度等），每个粒子有其对应的值。方程描述在时间点而位置为的粒子对应的物理量值。则一个粒子的物理量随时间的变化率是多少？这是一个拉格朗日描述角度下的问题，我们取对时间的导数（注意用到了求导链式法则，以及和）： 这就是物质导数。把式代入式我们就得到了流体动量方程。物质导数针对的是流体质点（在这里就是流体粒子）而不是空间的固定点。式写完整一点就是： 对于给定的速度场， 流体的物理性质如何在这个速度场下变化的计算我们称之为对流（advection）。一个最简单的对流方程，就是其物理量的物质导数为，如下所示： 公式的意义即在拉格朗日视角观察下，每个流体粒子的物理量保持不变。 4、不可压缩性关于流体的压缩性在此不做过多的物理细节描述，只需知道一点：通常情况下流体的体积变化非常小（除开一些极端的情况，而且这些极端情况我们日常生活中较少出现）。可压缩流体的模拟涉及到非常复杂的情况，往往需要昂贵的计算资源开销，为此在计算机流体模拟中我们通常把所有的流体当作是不可压缩的，即它们的体积不会发生变化。 任取流体的一部分，设其体积为而其边界闭合曲面为，我们可以通过围绕边界曲面对流体速度在曲面法线方向上的分量进行积分来衡量这块部分流体的体积变化速率： 对于不可压缩的流体，其体积保持为某个常量，故其体积变化速率为： 由高斯散度定理，我们可以把式转换为体积分： 式应该对任意的成立，意即无论取何值，积分值均为。这种情况下只有令积分函数值取方可成立，即对积分无论取何值结果均为。所以有： 这就是方程中的不可压缩条件。满足不可压缩条件的速度场被称为是无散度的，即在该速度场下流体体积既不膨胀也不坍缩，而是保持在一个常量。模拟不可压缩流体的关键部分就是使得流体的速度场保持无散度的状态，这也是流体内部压力的来源。 为了把压力与速度场的散度联系起来，我们在动量方程两边同时取散度： 对于上式第一项，我们转变一下求导次序： 如果满足流体不可压缩条件，那么式取值（因为无散度），然后我们调整一下式可得关于压力的方程： 5、丢弃粘度项在某些流体如蜂蜜、小水珠等的模拟中，粘滞力起着非常重要的作用。但是在大多数流体动画模拟中，粘滞力的影响微乎其微，为此秉持着方程组越简单越好的原则，我们常常丢弃粘度项。当然这也不可避免地带来一些误差，事实上，在计算流体力学中尽可能地减少丢弃粘度项带来的误差是一个非常大的挑战。下面的叙述都是基于丢弃粘度项的前提。 丢弃了粘度项的方程被称为欧拉方程，而这种理想的流体则是无粘度的。丢弃了粘度项的欧拉方程如下： 大多数的流体模拟的计算方程都是欧拉方程。 6、边界条件目前为止我们讨论的都是流体内部的情况，然而边界部分也是流体模拟非常关键的部分。在流体模拟中我们仅仅关注两种边界条件：固体墙（solid walls）、自由面（free surfaces）。 固体墙顾名思义就是流体与固体接触的边界，用速度来描述很简单：流体既不会流进固体内部也不会从固体内部流出，因此流体在固体墙法线方向上的分量为： 当然，上述是固体自身不移动的情况下。通常来说，流体速度在法线方向上的分量与固体的移动速度在法线方向上的分量应该保持一致： 上述的两个公式都是仅对流体速度在法线方向上的分量做了限制，对于无粘度的流体，切线方向上的流体速度与固体的移动速度无必然的联系。 自由面是另外一个非常重要的边界条件，它通常就是与另外一种流体相接壤的边界部分。例如在模拟水花四溅时，水流表面不与固体接触的都是自由面（如与空气这种流体接触）。因空气密度远小于水导致空气对水体的仿真影响非常小，为了简化模拟，我们将空气所占的空间设为某个固定大气压的区域，设为是最方便的方案，此时自由面就是压强的水体表面。 在小规模的流体仿真中，自由面的表面张力占据着非常重要的地位。在微观分子层面下，表面张力的存在是因为不同的分子相互吸引产生的力。从几何的角度来解释就是，表面张力就是促使流体的表面积尽可能小的一种力。物理学上，两种不同的流体之间实际上存在着与表面平均曲率成正比的压力骤变： 公式中的记为压力之差。是表面张力系数，可以根据模拟的流体类型查找对应的张力系数（例如空气与水在室温下张力系数为）。而就是平均曲率，单位为。又因为我们常常设空气的压力为，因此水与空气交界的自由面的压力为： 三、N-S方程的分步求解有了对以上对方程的理论支撑，接下来我们就要如何用计算机来对该组偏微分方程进行离散化求解。为了程序的松耦合性以及使计算尽可能地高效、简单，在流体模型领域，我们将流体方程分成几个独立的步骤，然后按顺序先后推进。对于不可压缩的无粘度流体方程（即前面的欧拉方程和，我们将其离散化成对流项（advection）如公式、体积力项（body force）如公式、压力/不可压缩项如公式： 需要注意的是，在对流项公式中我们用了一个通用量的符号是因为我们不仅仅要对流体的速度进行对流，还需要对其他物理量进行对流。我们记对流项公式的对流计算算法为，即对于给定的时间步长和速度场，对物理量q进行对流。 对于体积力项，我们采用简单的前向欧拉法即可：。 对于压力/不可压缩项，我们用一个称为的算法，通过计算出正确的压力以确保速度场的无散度性质。欧拉方案不会着重研究具体粒子间的作用力，因而不会正向去求解，它是利用流体不可压缩的特性，将速度场投影到散度为的空间上，间接地解算了压力项。这种思想相当于，已知一个中间量，对这个中间量的唯一一个操作（如正向求解压力）不可行，但是直到最终量符号的一个性质（散度为），于是只要将投影到符合散度为的特性平面上，即可间接地还原正向求解压力的操作，得到最终的速度场。 对流项的输入速度场要确保为无散度的状态，投影项确保了流体体积保持不变，因而投影项输出的速度场必然是无散度的。所以我们只要确保投影项输出的速度场作为对流项的输入即可，这时我们的分步求解流体方程的优势就体现出来了，其伪代码如下所示。 算法1 Fluid Simulation(, ): 1: 初始化速度场,使得无散度 2: 对于每个时间步 3: 决定一个合理的时间步长 4: 对流项计算 5: 体积力项计算 6: 无散度投影 1、时间步长在流体模拟算法中，确定适当的时间步长是算法的第一步。因为计算流体模拟的最后结果是呈现在屏幕上的，所以的选取与屏幕的刷新率有重要的关系。若选取的有，那么必须做一个截断使。此外，流体模拟的三个步骤即对流项、体积力项、无散度投影项对时间步长的要求不尽相同，要选择一个满足所有要求的最小时间步长能确保计算的收敛性。此外，一方面为了流体模拟的真实性，我们可能需要选取一个足够小的时间步长来复现流体的高质量细节。另一方面，有时高性能的需求又使得我们不能选取太小的时间步长去渲染一帧。假设一帧至少要进行三个时间步的模拟，那么应该至少设成帧间隔时间的三分之一。 2、网格结构欧拉法的整个流程都是基于网格的，所以合理的网格结构是算法高效的关键点。和提出了一种经典的（marker and cell）网格结构，许多不可压缩流体模拟的算法都在这个网格结构上呈现出了良好的效率。网格是一种交叉排列的网格，不同类型的物理量被存储于网格的不同位置。以二维的网格为例，如图3-1左图所示，流体粒子的压力数据存储于网格的中心点，而速度则沿着笛卡尔坐标被分成了两部分。水平方向的成分被存储在了网格单元竖直边的中心处，例如网格单元和之间的水平速度记为。垂直方向的成分则被存储在了网格单元水平面的中心上。这样的存储方案十分有利于估算流体流进/流出某个网格单元的量。 图3-1 MAC网格,左图二维,右图三维 扩展到三维的情况，网格同样是交错排列的结构网格，如图3-1右图所示。压力数值存储在立方体网格单元的中心，三个速度分量分别被记录在立方体网格单元的三个表面的中心点上。在数值计算时，这样的分配方式使得我们可以准确地采用中心差分法计算压力梯度和速度的散度，同时克服了中心差分法的一个普遍的缺点。一维的情况为例，在网格顶点位置上估算量场的导数，为了无偏（所谓无偏，就是不偏向左边或者右边）估计网格顶点处的，一种比较自然的方式就是采用一阶中心差分法： 公式是无偏的，且精确度为。而前向欧拉差分法偏向右边且精确度只有： 然而，公式存在着一个非常严重的问题：网格点的估算导数完全忽略了的值。数学上，只有常数函数的一阶导数为零。但是公式遇到了锯齿函数如时，它错误地将该类函数的导数估算为，这种问题被称为零空间问题（null-space problem）。 交叉错排的网格完美地克服了中心差分法的零空间问题，同时也保持了它的无偏二阶精度。在网格上运用中心差分法，网格点处的估算导数公式如下所示： 网格确实给流体的压力计算和不可压缩性的处理带来了很大的便利，但与此同时也带来了一些其他方面的麻烦。如果我们要估算某个地方的速度向量，即便采样点恰好在网格点上我们也要做一些插值才能获取相应的速度向量。在网格点处，我们通常采用平均法，以二维为例： 最后，在实现中下标索引一般没有浮点数之说，前面直接采用的记法是为了便于叙述。一般约定如下： 因而对于分辨率的网格，压力数值存储在的数组中，速度的成分存储在数组中，速度的成分存储在数组中，速度的成分存储在数组中。 四、对流算法求解如下所示的对流方程是流体模拟的关键一步： 我们把这个对流数值计算的算法记为： 公式中的各个符号含义： ：在网格上的离散化的速度场； ：时间步长； ：当前的物理量场（如流体密度、速度、燃烧物浓度等）； ：经过对流后得到的新的量场。 在这里要特别注意，输入对流算法的速度场必须是无散度的，否则模拟结果会出现一些奇怪的失真现象。 1、半拉格朗日对流算法（Semi-Lagrangian Advection）一维情况下，对流方程写成偏微分的形式如下： 分别采用前向欧拉差分法计算对时间的偏导和中心差分法计算对空间的偏导，我们有： 转成以为计算目标的显式公式，得： 公式看起来没什么问题，但是却存在非常严重的漏洞。首先，前向欧拉法被证明是无条件不稳定的空间离散方法：无论取多么小Δ𝑡，随着时间步的推进，累积误差终将发散。即使使用更稳定的时间积分方法来取代前向欧拉方法，解决了时间上的PDE（Partial Differential Equation，偏微分方程）计算，空间上的PDE计算还是会带来重大的麻烦。标准中心差分方法不可避免地会出现的零空间问题，具有高频震荡性质的速度场对空间的导数被错误地计算为或几乎为，低离速度分量被分离出来，从而导致模拟效果中出现许多奇怪的高频摆动和震荡。 针对这些问题，研究者们提出了一个解然不同的、更加简单和更具物理直观意义的半拉格朗日法。之所以叫半拉格朗日法，是因为这种方法是以拉格朗日视角去解决欧拉视角的对流方程（“半”字的由来）。假设我们的目标是求解网格点的在第个时间步时关于物理量的新值，记为。在拉格朗日的视角下，我们可以寻找在第时间步之前，是空间中的哪一个点上的流体粒子在速度场的作用下“流向”了，我们记这个粒子在第个时间步时的网格位置为，则第个时间步时的即为第个时间步时的。如下图4-1为半拉格朗日对流法的示意图。 图4-1 半拉格朗日对流法 半拉格朗日对流法的第一步就是要找出，为此我们根据做反向的追踪。粒子位置对时间的导数就是速度场： 经过一个时间步长之后，粒子由移动到。为了得到，最简单的方法就是采用前向欧拉法进行倒推： 然而前向欧拉法只有一阶的精度，若在不改变的情况下提高精度，我们可以采用高阶的龙格库塔法（Runge-Kutta method）。采用二阶的龙格库塔法如下所示： 倒推得到之前的网格位置一般不会恰好在网格顶点上，为此我们需要做些插值。三维模拟通常采用三线性插值，而二维的则采用双线性插值。 2、边界情况若我们倒推得到的仍然在流体的内部，那么做插值是完全没问题的。但若在流体的边界之外呢？这种情况的出现的原因通常有两个：一个是确确实实在流体的外部且即将流入流体内部，另一个是由前向欧拉法或龙格库塔法的数值计算方法带来的误差导致。 在一种情况下，我们应该知道当流体流入时其携带的物理量，此时我们将这个外部流入的物理量作为返回值即可。例如，第个时间步时的外部流体以速度和温度在第个时间步时注入流体内部的位置，那么的值就为。 在第二种由误差导致的情况下，一个适当的策略就是根据边界上的最近点外推出所求得物理量。在模拟某些流体时，外推变得很简单。例如，在模拟烟雾时我们简单地假设烟雾流体外部即空气的速度风场为某个常数（可能为），这样边界上的速度场都取。但还有一些必须根据流体内部的已知量外推出未知量，这时情况就变得比较复杂了。具体如何外推将在后面介绍，目前我们只需要知道大概的步骤：首先寻找边界上的最近点，然后在最近点的领域内插值获取相应的物理量场。 3、时间步长大小对任何一种数值计算方法的主要的考虑点就是它是否稳定。幸运的是，半拉格朗日对流法已经被证明是一种无条件稳定的算法：无论取多大，它永远不会出现数值爆炸的现象。因为每一个新值的确定，都是通过对旧值得插值，无论是线性插值、双线性插值还是三线性插值，的大小都是处于插值点之间，不会得到比原来插值点更大或者更小的值，因而是有上下界的。这使得我们可以尽情地根据所需的模拟质量和模拟效率去调整时间步长。 但是在实践中，时间步长的大小也不能选得太过极端，否则会产生一些奇观的现象。Foster和Fekiw提出了一个对的限制：流体粒子在内的倒推轨迹最多经过某个常数个网格单元为宜，例如5个： 公式中，是速度场的最大值，我们可以简单地取 存储在网格中的最大速度值。一个更鲁棒的方法考虑了体积力（如重力、浮力等）对最大速度的影响： 将不等式的最大值带入公式，我们有： 取一个简单的速度上界（简化了公式），： 这样确保了始终为正，且避免公式的除错误。 关于时间步长的讨论离不开（以Courant、Friedrichs、Lewy三人的名字命名）条件。条件是一个简单而直观的判断计算是否收敛的必要条件。它的直观物理解释就是时间推进求解的速度必须大于物理扰动传播的速度，只有这样才能将物理上所有的扰动俘获到。满足条件意味着当和趋于取极限时，数值计算所求的解就会收敛到原微分方程的解。 对于半拉格朗日对流法，其满足条件当且仅当在极限情况下，追踪得到的粒子轨迹足够逼近真实的轨迹。足够逼近的意思是经过正确的网格插值能够得到正确的依赖域（即差分格式的依赖域包含了原微分方程的依赖域），追踪的轨迹就会收敛到正确真实的轨迹。 因而，对于采用标准的显式有限差分法的对流方程求解，为了保证收敛，我们要求的新值是由以当前网格点为中心、以（是一个小的整数常量）为半径的邻域范围内插值得到： 公式中的被称为数，因而不等式可以看成是公式取数为得到。 4、数值耗散对流算法在对流获取新的物理量场时会进行一些插值操作，插值不可避免地会平滑物理量场，这带来了一些数值耗散。一次两次的数值耗散不会由太大的影响，但是在流体模拟中我们会在每个时间步都进行对流运算，反反复复的平滑操作将数值耗散不断扩大，损失大量的流体细节。 以一维的对流项计算为例，流体速度为常量： 假设，即单个时间步长内粒子追踪轨迹长度小于单个网格单元的大小。我们的目标点是，则倒推得到的粒子位置就落在了上的，然后进行线性插值得到： 将公式整理一下，有： 公式实际上正好就是采用时间上的前向欧拉差分法和空间上的单向有限差分法的欧拉方案，把看成是关于的函数，对进行泰勒级数展开： 将公式代入公式，并做一些变量消去，可得： 在二阶截断误差的情况下，结合公式和公式，有： 右边就是对流方程计算时引入的额外类似粘度乘上系数的项。这也就是说，当我们采用简单的半拉格朗日法去求解无粘度的对流方程时，模拟的结果却看起来我们像时在模拟有粘度的流体。这就是数值耗散! 当然，当时，这个数值耗散系数也会趋于，所以取时间步无穷小时能够得到正确的模拟结果，但这需要耗费巨额的计算资源开销。我们通常模拟的流体大多数都是无粘度的，所以如何减少这个数值耗散是个至关重要的难题。 一个简单有效的修复数值耗散的方法就是采用更加锐利的插值方法，从而尽可能地减少由插值带来的数值耗散。在一维的情况时，我们采用三次插值（cubic interpolant）如下公式，而不是简单的一次线性插值： 扩展到二维或者三维就是双三次插值（bicubic interpolation）或三三次插值（tricubic interpolation）。以二维情况为例，我们可以先沿着轴做第一遍的三次插值如公式，然后再沿着轴做第二遍插值如公式： 当然也可以先沿着轴，然后再沿着轴做插值操作。","categories":[],"tags":[{"name":"Computer Graphics","slug":"Computer-Graphics","permalink":"http://yoursite.com/tags/Computer-Graphics/"},{"name":"Naiver-Stokes Equations","slug":"Naiver-Stokes-Equations","permalink":"http://yoursite.com/tags/Naiver-Stokes-Equations/"},{"name":"Fluid Simulation","slug":"Fluid-Simulation","permalink":"http://yoursite.com/tags/Fluid-Simulation/"},{"name":"Advection","slug":"Advection","permalink":"http://yoursite.com/tags/Advection/"}]}]}
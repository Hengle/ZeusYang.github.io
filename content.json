{"meta":{"title":"YangWC's Blog","subtitle":null,"description":"Personal blog website.","author":"WC Yang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-04-27T07:26:21.624Z","updated":"2019-04-27T07:26:21.624Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 Not Found **�ܱ�Ǹ�������ʵ�ҳ�治����** �����������ַ�����õ�ַ�ѱ�ɾ��"},{"title":"关于","date":"2019-04-27T10:20:23.860Z","updated":"2019-04-27T10:20:23.860Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"[](https://github.com/ZeusYang) 中山大学本科四年级 计算机科学与技术专业 准研究生，研究方向计算机图形学 现居广州大学城 关于本站 欢迎来到 YangWC 的博客！本站会记录自己的一些学习内容，如若有错，欢迎指正，感谢！ 关于主题 本站的主题风格是：Material X 有任何问题请留言。"},{"title":"所有标签","date":"2019-04-27T08:02:52.306Z","updated":"2019-04-27T08:02:52.306Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-04-27T08:54:04.778Z","updated":"2019-04-27T08:54:04.778Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"大佬的博客","date":"2019-04-27T10:52:08.692Z","updated":"2019-04-27T10:52:08.692Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":"名称： YangWC’s Blog 头像： https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.4//globalImage/avator.jpg 网址： https://yangwc.com"}],"posts":[{"title":"软渲染器Soft Renderer：光栅化篇","slug":"SoftRenderer-Rasterization","date":"2019-04-30T14:39:06.753Z","updated":"2019-05-01T01:42:59.566Z","comments":true,"path":"2019/04/30/SoftRenderer-Rasterization/","link":"","permalink":"http://yoursite.com/2019/04/30/SoftRenderer-Rasterization/","excerpt":"本章开始构建基于Qt平台软渲染器的初步框架，当然Qt相关的内容并不是软渲染器的重点，我只是借助Qt平台将渲染出来的像素矩阵用Qt的控件显示出来。光栅化是当今图形学渲染的一种方式，与之对应的是光线追踪渲染方式，本章我根据自己的理解着重讲述线框光栅化的Bresenham画线算法以及三角形填充光栅化的Edge-Walking算法。注意：初学者慎入。本篇相关的完整代码请看这里。","text":"本章开始构建基于Qt平台软渲染器的初步框架，当然Qt相关的内容并不是软渲染器的重点，我只是借助Qt平台将渲染出来的像素矩阵用Qt的控件显示出来。光栅化是当今图形学渲染的一种方式，与之对应的是光线追踪渲染方式，本章我根据自己的理解着重讲述线框光栅化的Bresenham画线算法以及三角形填充光栅化的Edge-Walking算法。注意：初学者慎入。本篇相关的完整代码请看这里。 渲染管线框架 光栅化算法 渲染管线框架 渲染管线的搭建主要包含像素显示、网格数据封装、渲染循环、帧率fps计算、帧缓冲、着色器、渲染逻辑、光栅化等等，其中光栅化作为重点对象抽出来放在后面。当然我们不会一下子就完成渲染管线的基本功能，我们现在是要搭建一个框架，大部分的内容不用写入或者仅仅是做简单的处理，这样后面完善软渲染器的时候只需在相应的位置填写相应的代码逻辑即可。本章目标就是搭建一个渲染管线，用光栅化算法画三角形。当然，如果仅仅是画一个三角形，当然不用这么麻烦，但是我的目标是实现三维的软渲染器，深入理解三维渲染的整个流程，得从基础一步一步慢慢来。 像素显示的画布 渲染器最终渲染出来的是一个像素矩阵，我们要把这个像素矩阵显示出来。显示的方法有很多，因人而异，这里我采用自己最熟悉的QtQtQt来实现。显示的窗口继承一个普通的QWidgetQWidgetQWidget父类，然后我们通过重写它的paintEventpaintEventpaintEvent函数，将渲染出来的像素画到QWidgetQWidgetQWidget上。但是采用QPainterQPainterQPainter直接画上去的方式效率非常低，我通过查询资料得知，若想要快速地绘制给定的像素矩阵，可以利用QImageQImageQImage来实现。话不多说，上代码： 123456789101112131415class Window : public QWidget&#123; Q_OBJECTpublic: explicit Window(QWidget *parent = nullptr); ~Window();private: void paintEvent(QPaintEvent *) override;private: Ui::Window *ui; QImage *canvas;&#125;; 接收到一帧的像素之后，在重绘事件里面利用QImageQImageQImage绘制给定的像素数组（记得调用updateupdateupdate触发重绘事件）。由于篇幅原因，我不会讲太多细节方面的东西，代码也不会全部放出来，那样没意义。想看完整源代码的朋友直接去本人的github上看。 12345678910111213141516void Window::receiveFrame(unsigned char *image)&#123; if(canvas) delete canvas; canvas = new QImage(image, width(), height(), QImage::Format_RGBA8888); update();&#125;void Window::paintEvent(QPaintEvent *event)&#123; if(canvas) &#123; QPainter painter(this); painter.drawImage(0, 0, *canvas); &#125; QWidget::paintEvent(event);&#125; 帧缓冲类 帧缓冲通常包含基本的颜色缓冲附件、深度缓冲附件等，这里我们暂且只实现颜色缓冲附件（四通道，格式为RGBARGBARGBA，各占一个字节），深度缓冲附件后面再加上。渲染管线最终的渲染结果是写入帧缓冲的，我们采用一个一维的单字节数组作为帧缓冲的颜色缓冲。帧缓冲的最基本的功能就是清楚缓冲区、写入像素： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class FrameBuffer&#123;private: int m_width, m_height, m_channel; std::vector&lt;unsigned char&gt; m_colorBuffer;public: FrameBuffer(int width, int height); ~FrameBuffer() = default; int getWidth()&#123;return m_width;&#125; int getHeight()&#123;return m_height;&#125; unsigned char *getColorBuffer() &#123;return m_colorBuffer.data();&#125; void clearColorBuffer(const Vector4D &amp;color); void drawPixel(unsigned int x, unsigned int y, const Vector4D &amp;color);&#125;;FrameBuffer::FrameBuffer(int width, int height) :m_channel(4), m_width(width), m_height(height)&#123; m_colorBuffer.resize(m_width*m_height*m_channel, 255);&#125;void FrameBuffer::clearColorBuffer(const Vector4D &amp;color)&#123; // fill the color buffer. unsigned char red = static_cast&lt;unsigned char&gt;(255*color.x); unsigned char green = static_cast&lt;unsigned char&gt;(255*color.y); unsigned char blue = static_cast&lt;unsigned char&gt;(255*color.z); unsigned char alpha = static_cast&lt;unsigned char&gt;(255*color.w); for(int row = 0;row &lt; m_height;++ row) &#123; for(int col = 0;col &lt; m_width;++ col) &#123; m_colorBuffer[row*m_width*m_channel+col*m_channel + 0] = red; m_colorBuffer[row*m_width*m_channel+col*m_channel + 1] = green; m_colorBuffer[row*m_width*m_channel+col*m_channel + 2] = blue; m_colorBuffer[row*m_width*m_channel+col*m_channel + 3] = alpha; &#125; &#125;&#125;void FrameBuffer::drawPixel(unsigned int x, unsigned int y, const Vector4D &amp;color)&#123; if(x &lt; 0 || x &gt;= m_width || y &lt; 0 || y &gt;= m_height) return; unsigned char red = static_cast&lt;unsigned char&gt;(255*color.x); unsigned char green = static_cast&lt;unsigned char&gt;(255*color.y); unsigned char blue = static_cast&lt;unsigned char&gt;(255*color.z); unsigned char alpha = static_cast&lt;unsigned char&gt;(255*color.w); unsigned int index = y*m_width*m_channel + x*m_channel; m_colorBuffer[index + 0] = red; m_colorBuffer[index + 1] = green; m_colorBuffer[index + 2] = blue; m_colorBuffer[index + 3] = alpha;&#125; 网格顶点数据 三维的渲染程序中的顶点数据通常包含顶点位置、顶点颜色、纹理坐标、顶点法线，然后在此基础上利用一组给定顺序的顶点数据表示一个网格，渲染时网格的数据将被送入管线进行处理。为此，有必要对顶点数据做一定的封装。 1234567891011121314class Vertex&#123;public: Vector4D position; Vector4D color; Vector2D texcoord; Vector3D normal; Vertex() = default; Vertex(Vector4D _pos, Vector4D _color, Vector2D _tex, Vector3D _normal) :position(_pos),color(_color),texcoord(_tex),normal(_normal) &#123;&#125; Vertex(const Vertex &amp;rhs) :position(rhs.position),color(rhs.color),texcoord(rhs.texcoord),normal(rhs.normal)&#123;&#125;&#125;; 顶点数据经过顶点着色器的处理之后，会被送到下一个渲染管线的阶段处理。顶点着色器的顶点数据输出与输入有些差异，为此我们也定义一个类表示为顶点着色器的输出，这对于构建渲染管线尤为重要。 12345678910111213141516171819class VertexOut&#123;public: Vector4D posTrans; //世界变换后的坐标 Vector4D posH; //投影变换后的坐标 Vector2D texcoord; //纹理坐标 Vector3D normal; //法线 Vector4D color; //颜色 double oneDivZ; //1/z用于深度测试 VertexOut() = default; VertexOut(Vector4D _posT, Vector4D _posH, Vector2D _tex, Vector3D _normal, Vector4D _color, double _oneDivZ) :posTrans(_posT),posH(_posH),texcoord(_tex), normal(_normal),color(_color),oneDivZ(_oneDivZ) &#123;&#125; VertexOut(const VertexOut&amp; rhs) :posTrans(rhs.posTrans), posH(rhs.posH), texcoord(rhs.texcoord), normal(rhs.normal), color(rhs.color), oneDivZ(rhs.oneDivZ) &#123;&#125;&#125;; 然后就是关于网格的表示，为了节省空间（特别是对于很大的模型），我们直接采用索引来组织网格。若想详细了解OpenGL的顶点索引概念请看这里。一个网格有两个数组，分别是VertexVertexVertex数组和IndexIndexIndex数组。下面的代码中，有一个asTriangleasTriangleasTriangle方法，这是一个三角形网格，调用这个方法之后网格存储的就是一个三角形，用于后面的光栅化调试，光栅化的基本单元就是三角形。通常情况，所有的网格模型都可以用一定数量的三角形构成，因而我们实现的软渲染器的基本图元就是三角形。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Mesh&#123;public: std::vector&lt;Vertex&gt; vertices; std::vector&lt;unsigned int&gt; indices; Mesh() = default; ~Mesh() = default; Mesh(const Mesh&amp; mesh) :vertices(mesh.vertices), indices(mesh.indices)&#123;&#125; Mesh&amp; operator=(const Mesh&amp; mesh) &#123; if (&amp;mesh == this) return *this; vertices = mesh.vertices; indices = mesh.indices; return *this; &#125; void setVertices(Vertex* _vs, int count) &#123; vertices.resize(count); new(&amp;vertices[0])std::vector&lt;Vertex&gt;(_vs, _vs + count); &#125; void setIndices(int* _es, int count) &#123; indices.resize(count); new(&amp;indices)std::vector&lt;unsigned int&gt;(_es, _es + count); &#125; void asBox(double width, double height, double depth); void asTriangle(const Vector3D p1, const Vector3D p2, const Vector3D p3);&#125;;void Mesh::asTriangle(Vector3D p1, Vector3D p2, Vector3D p3)&#123; vertices.resize(3); indices.resize(3); vertices[0].position = p1; vertices[0].normal = Vector3D(0.f, 0.f, 1.f); vertices[0].color = Vector4D(1.f, 0.f, 0.f, 1.f); vertices[0].texcoord = Vector2D(0.f, 0.f); vertices[1].position = p2; vertices[1].normal = Vector3D(0.f, 0.f, 1.f); vertices[1].color = Vector4D(0.f, 1.f, 0.f, 1.f); vertices[1].texcoord = Vector2D(1.f, 0.f); vertices[2].position = p3; vertices[2].normal = Vector3D(0.f, 0.f, 1.f); vertices[2].color = Vector4D(0.f, 0.f, 1.f, 1.f); vertices[2].texcoord = Vector2D(0.5f, 1.f); indices[0] = 0; indices[1] = 1; indices[2] = 2;&#125; 简单的着色器 着色器方面时软渲染中较为高级的内容，目前我们只是搭建一个框架，因而着色器不需要什么复杂的操作，只需简单地传递数据就行了。博主实现的软渲染器只包含必不可少的顶点着色器和片元着色器，目前的顶点着色器将顶点原封不动地输出，片元着色器也是如此，这样我们后面要实现光照效果的时候直接在着色器里写上就行了。为了更加有条理，我们设计一个着色器的虚类，这样实现不同效果的着色器时我们直接继承这个虚类即可。 123456789101112class BaseShader&#123;public: BaseShader() = default; virtual ~BaseShader() = default; virtual VertexOut vertexShader(const Vertex &amp;in) = 0; virtual Vector4D fragmentShader(const VertexOut &amp;in) = 0; virtual void setModelMatrix(const Matrix4x4 &amp;world) = 0; virtual void setViewMatrix(const Matrix4x4 &amp;view) = 0; virtual void setProjectMatrix(const Matrix4x4 &amp;project) = 0;&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243class SimpleShader : public BaseShader&#123;public: SimpleShader() = default; virtual ~SimpleShader() = default; virtual VertexOut vertexShader(const Vertex &amp;in); virtual Vector4D fragmentShader(const VertexOut &amp;in); virtual void setModelMatrix(const Matrix4x4 &amp;world); virtual void setViewMatrix(const Matrix4x4 &amp;view); virtual void setProjectMatrix(const Matrix4x4 &amp;project);&#125;;VertexOut SimpleShader::vertexShader(const Vertex &amp;in)&#123; VertexOut result; result.posTrans = in.position; result.posH = in.position; result.color = in.color; result.normal = in.normal; result.oneDivZ = 1.0; result.texcoord = in.texcoord; return result;&#125;Vector4D SimpleShader::fragmentShader(const VertexOut &amp;in)&#123; Vector4D litColor; litColor = in.color; return litColor;&#125;void SimpleShader::setModelMatrix(const Matrix4x4 &amp;world)&#123;&#125;void SimpleShader::setViewMatrix(const Matrix4x4 &amp;view)&#123;&#125;void SimpleShader::setProjectMatrix(const Matrix4x4 &amp;project)&#123;&#125; 可以看到SimpleShaderSimpleShaderSimpleShader仅仅是将顶点数据直接输出，不进行任何处理。 搭建基本的渲染管线 目前我们已经有了一些渲染管线的基本组件，现在就需要把这些组件串起来。首先是渲染循环的问题，QtQtQt有它自己的事件循环，而且主线程的事件循环要尽量避免大量的运算（否则UI控件会陷入未响应），因此将渲染循环放到子线程里是一个不错的渲染，这样也可以避免我们的软渲染逻辑与QtQtQt的接口耦合得太高。 渲染线程 QtQtQt提供了QThreadQThreadQThread类构建线程，我采用的方式为：渲染循环类继承QObjectQObjectQObject，然后调用moveToThreadmoveToThreadmoveToThread番方法挂到子线程上运行，最后将线程的启动信号与looplooploop渲染循环关联即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class RenderLoop : public QObject&#123; Q_OBJECTpublic: explicit RenderLoop(int w, int h, QObject *parent = nullptr); ~RenderLoop(); void stopIt() &#123;stoped = true;&#125; void setFpsZero()&#123;fps = 0;&#125; int getFps()&#123;return fps;&#125;signals: void frameOut(unsigned char *image);public slots: void loop();private: bool stoped; int fps; int width, height, channel;&#125;;RenderLoop::RenderLoop(int w, int h, QObject *parent) : QObject(parent), width(w), height(h), channel(4)&#123; fps = 0; stoped = false;&#125;RenderLoop::~RenderLoop()&#123;&#125;void RenderLoop::loop()&#123; // pipeline initialization ...... // fps counting. fps = 0; while(!stoped) &#123; // render logic ...... ++ fps; &#125;&#125; 然后在主窗口中创建RenderLoopRenderLoopRenderLoop对象，挂到QThreadQThreadQThread上启动。此外还有一点要注意的是在子线程中最好不用使用QTimerQTimerQTimer类，因此我在主窗口中创建QTimerQTimerQTimer类，设定为每秒触发，触发时主线程读取子线程的fpsfpsfps，这样就达到了显示帧率的目的了。 12345678910111213141516171819202122232425262728293031在Window类声明处：private: QTimer *timer; QThread *loopThread; RenderLoop *loop;在Window类构造函数处： loop = new RenderLoop(width(), height(), nullptr); loopThread = new QThread(this); // fps counting. timer = new QTimer(); connect(timer,&amp;QTimer::timeout,this,&amp;Window::fpsTimeOut); // render thread. loop-&gt;moveToThread(loopThread); connect(loopThread,&amp;QThread::finished,loop, &amp;RenderLoop::deleteLater); connect(loopThread,&amp;QThread::started,loop,&amp;RenderLoop::loop); connect(loop,&amp;RenderLoop::frameOut,this,&amp;Window::receiveFrame); // begin the thread. loopThread-&gt;start(); timer-&gt;start(1000);Window的其他函数：void Window::fpsTimeOut()&#123; int fps = loop-&gt;getFps(); loop-&gt;setFpsZero(); this-&gt;setWindowTitle(QString(\" fps: %1\").arg(fps));&#125; 渲染流程 回顾一下OpenGLOpenGLOpenGL的渲染流程（这里只考虑一般的情况，即不包含几何着色器、细分着色器等），首先外部处理网格，将网格顶点数据和网格顶点索引送入渲染管线，设置基本图元（如三角形）、渲染方式（如线框模式）。渲染管线的第一阶段为顶点着色器阶段（在这之前还有个缓冲清理阶段），顶点着色器对网格数据逐顶点处理（包含坐标空间变换、投影变换等等），随之输出。然后渲染管线对输出的顶点数据进行裁剪，送入光栅化部件，计算几何图元覆盖的像素点，其中进行了大量的线性插值操作。接着片元着色器获取光栅化后的像素，对每个像素做颜色计算等，然后输出颜色数据、深度数据，最后根据这些缓冲数据做深度测试。 所以一个最基本的渲染管线应该有如下几个步骤： 初始化（如缓冲区创建）→\\to→输入顶点缓冲、索引缓冲→\\to→清除缓冲区→\\to→设置着色器、渲染方式→\\to→绘制→\\to→交换双缓冲→\\to→输出。根据这些步骤，创建PipelinePipelinePipeline类如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class Pipeline&#123;private: int m_width, m_height; // width and height of viewport. BaseShader *m_shader; // shaders including vertex shader and fragment shader. FrameBuffer *m_frontBuffer; FrameBuffer *m_backBuffer; Matrix4x4 viewPortMatrix; // viewport transformation matrix. std::vector&lt;Vertex&gt; m_vertices; // vertex buffer. std::vector&lt;unsigned int&gt; m_indices;// index buffer.public: Pipeline(int width, int height); ~Pipeline(); void initialize(); void clearBuffer(const Vector4D &amp;color, bool depth = false); void setVertexBuffer(const std::vector&lt;Vertex&gt; &amp;vertices)&#123;m_vertices = vertices;&#125; void setIndexBuffer(const std::vector&lt;unsigned int&gt; &amp;indices)&#123;m_indices = indices;&#125; void setShaderMode(ShadingMode mode); void drawIndex(RenderMode mode); void swapBuffer(); unsigned char *output()&#123;return m_frontBuffer-&gt;getColorBuffer();&#125;&#125;;Pipeline::Pipeline(int width, int height) :m_width(width),m_height(height) ,m_shader(nullptr),m_frontBuffer(nullptr) ,m_backBuffer(nullptr)&#123;&#125;Pipeline::~Pipeline()&#123; if(m_shader)delete m_shader; if(m_frontBuffer)delete m_frontBuffer; if(m_backBuffer)delete m_backBuffer; m_shader = nullptr; m_frontBuffer = nullptr; m_backBuffer = nullptr;&#125;void Pipeline::initialize()&#123; if(m_frontBuffer) delete m_frontBuffer; if(m_backBuffer) delete m_backBuffer; if(m_shader) delete m_shader; viewPortMatrix.setViewPort(0,0,m_width,m_height); m_frontBuffer = new FrameBuffer(m_width, m_height); m_backBuffer = new FrameBuffer(m_width, m_height); m_shader = new SimpleShader();&#125;void Pipeline::drawIndex(RenderMode mode)&#123; 输入顶点着色器; 光栅化; 输入片元着色器; 写入缓冲区;&#125;void Pipeline::clearBuffer(const Vector4D &amp;color, bool depth)&#123; (void)depth; m_backBuffer-&gt;clearColorBuffer(color);&#125;void Pipeline::setShaderMode(ShadingMode mode)&#123; if(m_shader)delete m_shader; if(mode == ShadingMode::simple) m_shader = new SimpleShader(); else if(mode == ShadingMode::phong) ;&#125;void Pipeline::swapBuffer()&#123; FrameBuffer *tmp = m_frontBuffer; m_frontBuffer = m_backBuffer; m_backBuffer = tmp;&#125; 注意到我创建了帧缓冲，分别是m_frontBufferm\\_frontBufferm_frontBuffer和m_backBufferm\\_backBufferm_backBuffer，前者存储着当前显示的像素，后者缓冲区用于写入像素。这就是著名的双缓冲原理，可以避免画面的闪烁、撕裂等现象。除此之外，还有一个值得特别说明的就是视口变换矩阵viewPortMatrixviewPortMatrixviewPortMatrix，这个一般很少见到，因为被内嵌在了渲染管线里面了。经过投影变换、透视除法操作之后，顶点数据都在标准化设备空间中，即xxx轴、yyy轴、zzz轴取值范围为[−1,1][-1,1][−1,1]。但是屏幕的像素坐标范围并非如此，通常屏幕的xxx轴坐标范围为[0,width][0,width][0,width]，yyy轴坐标范围为[0,height][0,height][0,height]，屏幕像素坐标原点在左上角，xxx轴正向朝右，yyy轴正向朝下，所以我们还要把标准化设备坐标顶点数据变换到屏幕的坐标范围中，这就是视口变换（zzz轴一般保持不变）。视口变换矩阵的构造并没有难度，因为这仅仅是简单的线性映射，因此不再赘述。视口变换矩阵如下所示： (1)viewPortMatrix=[w200sx+w20−h20sy+h200100001]viewPortMatrix= \\left[ \\begin{matrix} \\frac{w}{2}&amp;0&amp;0&amp;s_x+\\frac{w}{2}\\\\ 0&amp;-\\frac{h}{2}&amp;0&amp;s_y+\\frac{h}{2}\\\\ 0&amp;0&amp;1&amp;0\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] \\tag {1} viewPortMatrix=⎣⎢⎢⎡​2w​000​0−2h​00​0010​sx​+2w​sy​+2h​01​⎦⎥⎥⎤​(1) 其中(sx,sy)(s_x,s_y)(sx​,sy​)是视口左上角的坐标，(w,h)(w,h)(w,h)为屏幕的宽度和高度。 12345678void Matrix4x4::setViewPort(int left, int top, int width, int height)&#123; loadIdentity(); entries[0] = static_cast&lt;float&gt;(width)/2.0f; entries[5] = -static_cast&lt;float&gt;(height)/2.0f; entries[12] = static_cast&lt;float&gt;(left)+static_cast&lt;float&gt;(width)/2.0f; entries[13] = static_cast&lt;float&gt;(top)+static_cast&lt;float&gt;(height)/2.0f;&#125; PipelinePipelinePipeline还有个非常重要的函数drawIndexdrawIndexdrawIndex，它是渲染管线的核心部分，涉及到了图元装配、顶点着色器调度、光栅化、片元着色器调度、写入帧缓冲这几个重要的步骤。我们实现的软渲染器几何图元默认为三角形，所以图元装配就是每三个顶点装成一个图元。 123456789101112131415161718192021222324252627282930313233343536373839void Pipeline::drawIndex(RenderMode mode)&#123; if(m_indices.empty())return; for(unsigned int i = 0;i &lt; m_indices.size()/3;++ i) &#123; //! vertices assembly to triangle primitive Vertex p1,p2,p3; &#123; p1 = m_vertices[3*i+0]; p2 = m_vertices[3*i+1]; p3 = m_vertices[3*i+2]; &#125; //! vertex shader stage. VertexOut v1,v2,v3; &#123; v1 = m_shader-&gt;vertexShader(p1); v2 = m_shader-&gt;vertexShader(p2); v3 = m_shader-&gt;vertexShader(p3); &#125; //! rasterization and fragment shader stage. &#123; v1.posH = viewPortMatrix * v1.posH; v2.posH = viewPortMatrix * v2.posH; v3.posH = viewPortMatrix * v3.posH; if(mode == RenderMode::wire) &#123; // bresenham rasterization &#125; else if(mode == RenderMode::fill) &#123; // edge walking rasterization &#125; &#125; &#125;&#125; 有了以上的PipelinePipelinePipeline函数，我们的渲染循环逻辑的一般形式如下： 1234567891011while(!stoped)&#123; pipeline-&gt;clearBuffer(Vector4D(0.502f,0.698f,0.800f,1.0f)); pipeline-&gt;drawIndex(RenderMode::fill); pipeline-&gt;swapBuffer(); emit frameOut(pipeline-&gt;output()); ++ fps;&#125; 光栅化算法 顶点着色器处理的还是一个个离散的几何顶点，在顶点着色器之后我们还需要进行光栅化操作，将几何覆盖的屏幕像素计算出来，送入片元着色器计算每个点的像素数据。光栅化一般有两种模式：一种是线框模式，即只描绘几何的边；二是填充模式，即将几何的面片全部填充完。Bresenham算法是经典的描线算法，它采用迭代的形式将所需的算术操作降低到最少。除此之外还有DDA描线算法，效率上不如Bresenham算法，所以我没有实现。 Bresenham描线算法 我们要描绘的是从(x0,y0)(x_0,y_0)(x0​,y0​)到(x1,y1)(x_1,y_1)(x1​,y1​)的一条直线线段。一些数学符号标记如下： Δx=x1−x0&gt;0, Δy=y1−y0&gt;0, m=ΔyΔx\\Delta x= x_1-x_0&gt;0,\\ \\Delta y=y_1-y_0&gt;0,\\ m=\\frac{\\Delta y}{\\Delta x} Δx=x1​−x0​&gt;0, Δy=y1​−y0​&gt;0, m=ΔxΔy​ 其中mmm即直线线段的斜率，为了便于讨论，我们假设∣m∣≤1|m|\\leq 1∣m∣≤1，其他情况很容易推广。 在如上的情况下，Bresenham算法从x=x0x=x_0x=x0​开始，每次将xxx坐标值加一，然后推算相应的yyy坐标值。记第iii次迭代获得的点为(xi,yi)(x_i,y_i)(xi​,yi​)。那么第i+1i+1i+1次迭代时获取的点就在(x‾i+1,y‾i)(\\overline x_i+1,\\overline y_i)(xi​+1,y​i​)和(x‾i+1,y‾i+1)(\\overline x_i+1,\\overline y_i+1)(xi​+1,y​i​+1)这两个中选取。那如何判断应该选哪个呢？即选择这两个点之一的判断标准是什么？直观上，我们应该选取距离的直线线段在该yyy轴上的交点最近的点，如下图1所示。 图1 判别标准 直线的一般表达式为y=mx+By=mx+By=mx+B，mmm为直线的斜率，那么(xi+1,yi+1)(x_{i+1},y_{i+1})(xi+1​,yi+1​)表示为如下（注意yi+1y_{i+1}yi+1​表示的是直线在xi+1x_{i+1}xi+1​上真正的yyy值）： (2)xi+1=xi+1yi+1=mxi+1+B=m(xi+1)+Bx_{i+1}=x_i+1\\\\ y_{i+1}=mx_{i+1}+B=m(x_i+1)+B \\tag {2} xi+1​=xi​+1yi+1​=mxi+1​+B=m(xi​+1)+B(2) 图2 交点到右边的点、右上的点的距离 故dupperd_{upper}dupper​和dlowerd_{lower}dlower​的取值如下： (3)dupper=y‾i+1−y‾i+1=y‾i+1−mx‾i+1−Bdlower=yi+1−y‾i=mxi+1+B−y‾id_{upper}=\\overline y_i+1-\\overline y_{i+1}=\\overline y_i+1-m\\overline x_{i+1}-B\\\\ d_{lower}=y_{i+1}-\\overline y_i=mx_{i+1}+B-\\overline y_i \\tag {3} dupper​=y​i​+1−y​i+1​=y​i​+1−mxi+1​−Bdlower​=yi+1​−y​i​=mxi+1​+B−y​i​(3) 显然，如果dlower−dupper&gt;0d_{lower}-d_{upper}&gt;0dlower​−dupper​&gt;0，则应该取右上方的点；如果dlower−dupper&lt;0d_{lower}-d_{upper}&lt;0dlower​−dupper​&lt;0，则应该取右边的点。而dlower−dupper=0d_{lower}-d_{upper}=0dlower​−dupper​=0可任取这两个点。因此，我们的判断标准就是dlower−dupper&gt;0d_{lower}-d_{upper}&gt;0dlower​−dupper​&gt;0的符号。 (4)dlower−dupper=m(xi+1)+B−y‾i−(y‾i+1−m(xi+1)−B)=2m(xi+1)−2y‾i+2B−1d_{lower}-d_{upper}=m(x_i+1)+B-\\overline y_i-(\\overline y_i+1-m(x_i+1)-B)\\\\ =2m(x_i+1)-2\\overline y_i+2B-1 \\tag {4} dlower​−dupper​=m(xi​+1)+B−y​i​−(y​i​+1−m(xi​+1)−B)=2m(xi​+1)−2y​i​+2B−1(4) 式(4)(4)(4)中的mmm是直线的斜率，因此将式(4)(4)(4)作为判断标准需要做非常昂贵的浮点数除法运算。为了消去除法，注意到m=ΔyΔxm=\\frac{\\Delta y}{\\Delta x}m=ΔxΔy​，两边同时乘上Δx&gt;0\\Delta x&gt;0Δx&gt;0，正负符号不变。 (5)pi=Δx⋅(dlower−dupper)=2Δy⋅(xi+1)−2Δx⋅y‾i+(2B−1)Δx=2Δy⋅xi−2Δx⋅y‾i+c其中,c=(2B−1)Δx+2Δyp_i=\\Delta x\\cdot (d_{lower}-d_{upper}) =2\\Delta y\\cdot(x_i+1)-2\\Delta x\\cdot \\overline y_i+(2B-1)\\Delta x\\\\ =2\\Delta y\\cdot x_i-2\\Delta x\\cdot\\overline y_i+c\\\\ 其中,c=(2B-1)\\Delta x+2\\Delta y \\tag {5} pi​=Δx⋅(dlower​−dupper​)=2Δy⋅(xi​+1)−2Δx⋅y​i​+(2B−1)Δx=2Δy⋅xi​−2Δx⋅y​i​+c其中,c=(2B−1)Δx+2Δy(5) 所以可以用pip_ipi​的符号作为选取的标准。但是，式(5)(5)(5)的计算能够进一步简化，考虑pip_ipi​和pi+1p_{i+1}pi+1​（注意我们根据pip_ipi​的符号来选取y‾i+1\\overline y_{i+1}y​i+1​）： (6)pi+1−pi=(2Δy⋅xi+1−2Δx⋅y‾i+1+c)−(2Δy⋅xi−2Δx⋅y‾i+c)=2Δy−2Δx(y‾i+1−y‾i)p_{i+1}-p_{i} = (2\\Delta y\\cdot x_{i+1}-2\\Delta x\\cdot\\overline y_{i+1}+c) - (2\\Delta y\\cdot x_i-2\\Delta x\\cdot\\overline y_i+c) \\\\= 2\\Delta y-2\\Delta x(\\overline y_{i+1}-\\overline y_i) \\tag {6} pi+1​−pi​=(2Δy⋅xi+1​−2Δx⋅y​i+1​+c)−(2Δy⋅xi​−2Δx⋅y​i​+c)=2Δy−2Δx(y​i+1​−y​i​)(6) 若pi≤0p_i\\leq 0pi​≤0，那么选择右边的点，此时y‾i+1=y‾i\\overline y_{i+1}=\\overline y_iy​i+1​=y​i​，那么有： (7)pi+1=pi+2Δyp_{i+1}=p_i+2\\Delta y \\tag {7} pi+1​=pi​+2Δy(7) 若pi&gt;0p_i&gt;0pi​&gt;0，那么选择右上角的点，此时y‾i+1=y‾i+1\\overline y_{i+1}=\\overline y_i+1y​i+1​=y​i​+1，那么有： (8)pi+1=pi+2Δy−2Δxp_{i+1}=p_i+2\\Delta y-2\\Delta x \\tag {8} pi+1​=pi​+2Δy−2Δx(8) 所以我们可以根据pip_ipi​的符号快速计算出pi+1p_{i+1}pi+1​的符号，如此迭代下去： Bresenham Algorithm: draw(x0,y0);draw (x_0, y_0);draw(x0​,y0​); Calculate Δx\\Delta xΔx,Δy\\Delta yΔy,2Δy2\\Delta y2Δy,2Δy−2Δx2\\Delta y-2\\Delta x2Δy−2Δx,p0=2Δy−Δxp_0=2\\Delta y-\\Delta xp0​=2Δy−Δx; for xxx from x0x_0x0​ to x1x_1x1​: if pi≤0p_i\\leq 0pi​≤0 draw (xi+1,y‾i+1)=(xi+1,y‾i)(x_{i+1},\\overline y_{i+1})=(x_i+1,\\overline y_i)(xi+1​,y​i+1​)=(xi​+1,y​i​) ; compute pi+1=pi+2Δyp_{i+1}=p_i+2\\Delta ypi+1​=pi​+2Δy; if pi&gt;0p_i &gt; 0pi​&gt;0 draw (xi+1,y‾i+1)=(xi+1,y‾i+1)(x_{i+1},\\overline y_{i+1})=(x_i+1,\\overline y_i+1)(xi+1​,y​i+1​)=(xi​+1,y​i​+1) ; compute pi+1=pi+2Δy−2Δxp_{i+1}=p_i+2\\Delta y-2\\Delta xpi+1​=pi​+2Δy−2Δx; x+=1;x += 1;x+=1; 上面我们讨论的都是∣m∣&lt;1|m|&lt;1∣m∣&lt;1的情况，那∣m∣&gt;1|m|&gt;1∣m∣&gt;1的情况呢？其实这是对称的，这时把xxx看成yyy，把yyy看成xxx即可。另外，当Δx&lt;0\\Delta x &lt;0Δx&lt;0时，我们的xxx不是递增111，而是递减111，具体实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465void Pipeline::bresenhamLineRasterization(const VertexOut &amp;from, const VertexOut &amp;to)&#123; int dx = to.posH.x - from.posH.x; int dy = to.posH.y - from.posH.y; int stepX = 1, stepY = 1; // judge the sign if(dx &lt; 0) &#123; stepX = -1; dx = -dx; &#125; if(dy &lt; 0) &#123; stepY = -1; dy = -dy; &#125; int d2x = 2*dx, d2y = 2*dy; int d2y_minus_d2x = d2y - d2x; int sx = from.posH.x; int sy = from.posH.y; VertexOut tmp; // slope &lt; 1. if(dy &lt;= dx) &#123; int flag = d2y - dx; for(int i = 0;i &lt;= dx;++ i) &#123; // linear interpolation tmp = lerp(from, to, static_cast&lt;double&gt;(i)/dx); // fragment shader m_backBuffer-&gt;drawPixel(sx,sy,m_shader-&gt;fragmentShader(tmp)); sx += stepX; if(flag &lt;= 0) flag += d2y; else &#123; sy += stepY; flag += d2y_minus_d2x; &#125; &#125; &#125; // slope &gt; 1. else &#123; int flag = d2x - dy; for(int i = 0;i &lt;= dy;++ i) &#123; // linear interpolation tmp = lerp(from, to, static_cast&lt;double&gt;(i)/dy); // fragment shader m_backBuffer-&gt;drawPixel(sx,sy,m_shader-&gt;fragmentShader(tmp)); sy += stepY; if(flag &lt;= 0) flag += d2x; else &#123; sx += stepX; flag -= d2y_minus_d2x; &#125; &#125; &#125;&#125; Edge-Walking三角形填充算法 三角形光栅化填充对输入给定的三个三角形顶点，计算这个三角区域覆盖的所有像素。三角形填充的光栅化算法有很多种，这里仅实现了Edge-Walking算法，此外还有Edge-Equation算法。关于Edge-Walking算法的前世今生我不再赘述了，这个算法的思路比较简单，但是实现起来比较麻烦一点。 话不多少，直接上伪代码（懒得自己写了伪代码了）： 大致的思想就是从上往下（或从下往上）扫描，获取每对XLX_LXL​、XRX_RXR​，然后在[XL,XR][X_L,X_R][XL​,XR​]范围内从左到右扫描。显然就是双重循环。一般，我们的三角形光栅化对象有如下四种情况： 图3 四类三角形 先来看平底三角形的情况，如下图4所示。显然，平底三角形很容易地实现从下往上扫面，竖直方向上仅需考虑左右两条边。当然这里有个问题，就是如何确定XLX_LXL​和XRX_RXR​？如果直接采用算法伪代码中的利用dx/dydx/dydx/dy迭代获取XXX值，因为XXX值是整数，而dx/dydx/dydx/dy是浮点数，当dx/dy&lt;1dx/dy&lt;1dx/dy&lt;1时，把dx/dydx/dydx/dy加到XXX上面计算机对整数类型坐标自动向下取整，结果相当于没加。（即便是浮点数类型，最终也要取整，因为屏幕空间的像素坐标必须是整数） 图4 平底三角形 一种解决方案就是线性插值，算法从下往上扫描时，y−=1y-=1y−=1，我们根据当前的yyy值来获取xxx值： XL=(1.0f−y1−yy1−y0)∗x1+y1−yy1−y0∗x0Xy=(1.0f−y2−yy2−y0)∗x2+y2−yy2−y0∗x0X_L = (1.0f-\\frac{y1-y}{y1-y0})*x1+\\frac{y1-y}{y1-y0}*x0 \\\\ X_y = (1.0f-\\frac{y2-y}{y2-y0})*x2+\\frac{y2-y}{y2-y0}*x0 XL​=(1.0f−y1−y0y1−y​)∗x1+y1−y0y1−y​∗x0Xy​=(1.0f−y2−y0y2−y​)∗x2+y2−y0y2−y​∗x0 平顶的三角形光栅化亦类似，不再赘述。那么除了平底和平顶的情况之外，我们该如何处理其余的情况？一个技巧就是将其他情况的三角形分割乘一个平底三角形、一个平顶三角形，如下图所示： 图5 三角形分割 这样我们通过调用平底三角形光栅化方法、平顶三角形光栅化方法即可实现一般情况的三角形光栅化： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114void Pipeline::scanLinePerRow(const VertexOut &amp;left, const VertexOut &amp;right)&#123; VertexOut current; int length = right.posH.x - left.posH.x + 1; for(int i = 0;i &lt;= length;++i) &#123; // linear interpolation double weight = static_cast&lt;double&gt;(i)/length; current = lerp(left, right, weight); current.posH.x = left.posH.x + i; current.posH.y = left.posH.y; // fragment shader m_backBuffer-&gt;drawPixel(current.posH.x, current.posH.y, m_shader-&gt;fragmentShader(current)); &#125;&#125;void Pipeline::rasterTopTriangle(VertexOut &amp;v1, VertexOut &amp;v2, VertexOut &amp;v3)&#123; VertexOut left = v2; VertexOut right = v3; VertexOut dest = v1; VertexOut tmp, newleft, newright; if(left.posH.x &gt; right.posH.x) &#123; tmp = left; left = right; right = tmp; &#125; int dy = left.posH.y - dest.posH.y + 1; for(int i = 0;i &lt; dy;++i) &#123; double weight = 0; if(dy != 0) weight = static_cast&lt;double&gt;(i)/dy; newleft = lerp(left, dest, weight); newright = lerp(right, dest, weight); newleft.posH.y = newright.posH.y = left.posH.y - i; scanLinePerRow(newleft, newright); &#125;&#125;void Pipeline::rasterBottomTriangle(VertexOut &amp;v1, VertexOut &amp;v2, VertexOut &amp;v3)&#123; VertexOut left = v1; VertexOut right = v2; VertexOut dest = v3; VertexOut tmp, newleft, newright; if(left.posH.x &gt; right.posH.x) &#123; tmp = left; left = right; right = tmp; &#125; int dy = dest.posH.y - left.posH.y + 1; for(int i = 0;i &lt; dy;++i) &#123; double weight = 0; if(dy != 0) weight = static_cast&lt;double&gt;(i)/dy; newleft = lerp(left, dest, weight); newright = lerp(right, dest, weight); newleft.posH.y = newright.posH.y = left.posH.y + i; scanLinePerRow(newleft, newright); &#125;&#125;void Pipeline::edgeWalkingFillRasterization(const VertexOut &amp;v1, const VertexOut &amp;v2, const VertexOut &amp;v3)&#123; // split the triangle into two part VertexOut tmp; VertexOut target[3] = &#123;v1, v2,v3&#125;; if(target[0].posH.y &gt; target[1].posH.y) &#123; tmp = target[0]; target[0] = target[1]; target[1] = tmp; &#125; if(target[0].posH.y &gt; target[2].posH.y) &#123; tmp = target[0]; target[0] = target[2]; target[2] = tmp; &#125; if(target[1].posH.y &gt; target[2].posH.y) &#123; tmp = target[1]; target[1] = target[2]; target[2] = tmp; &#125; // bottom triangle if(equal(target[0].posH.y,target[1].posH.y)) &#123; rasterBottomTriangle(target[0],target[1],target[2]); &#125; // top triangle else if(equal(target[1].posH.y,target[2].posH.y)) &#123; rasterTopTriangle(target[0], target[1], target[2]); &#125; // split it. else &#123; double weight = static_cast&lt;double&gt;(target[1].posH.y-target[0].posH.y)/(target[2].posH.y-target[0].posH.y); VertexOut newPoint = lerp(target[0],target[2],weight); newPoint.posH.y = target[1].posH.y; rasterTopTriangle(target[0], newPoint, target[1]); rasterBottomTriangle(newPoint,target[1],target[2]); &#125;&#125; 程序结果 最终，不借用任何图形接口通过自己实现的光栅化算法画出了三角形： 参考资料 [1][1][1] https://blog.csdn.net/cppyin/article/details/6232453 [2][2][2] https://blog.csdn.net/y1196645376/article/details/78937614 [3][3][3] https://blog.csdn.net/y1196645376/article/details/78907914","categories":[{"name":"Computer Graphics","slug":"Computer-Graphics","permalink":"http://yoursite.com/categories/Computer-Graphics/"},{"name":"Soft Renderer","slug":"Soft-Renderer","permalink":"http://yoursite.com/categories/Soft-Renderer/"}],"tags":[{"name":"Computer Graphics","slug":"Computer-Graphics","permalink":"http://yoursite.com/tags/Computer-Graphics/"},{"name":"Soft Renderer","slug":"Soft-Renderer","permalink":"http://yoursite.com/tags/Soft-Renderer/"},{"name":"Rasterization","slug":"Rasterization","permalink":"http://yoursite.com/tags/Rasterization/"}]},{"title":"软渲染器Soft Renderer：3D数学篇","slug":"SoftRenderer-Math","date":"2019-04-29T09:22:32.082Z","updated":"2019-04-29T10:57:16.883Z","comments":true,"path":"2019/04/29/SoftRenderer-Math/","link":"","permalink":"http://yoursite.com/2019/04/29/SoftRenderer-Math/","excerpt":"本章开始博主将手动搭建一个渲染管线，深入理解3D渲染的整个流程。线性代数中的向量和矩阵是计算机图形学的常客，深入理解和掌握对于图形渲染有着非常重要的意义，本节主要是关于3D数学库的内容。","text":"本章开始博主将手动搭建一个渲染管线，深入理解3D渲染的整个流程。线性代数中的向量和矩阵是计算机图形学的常客，深入理解和掌握对于图形渲染有着非常重要的意义，本节主要是关于3D数学库的内容。 向量 矩阵 向量 nnn维向量本质就是一个nnn元组，从几何意义上来说，向量是有大小和方向的有向线段。向量的大小就是向量的长度（模）向量有非负的长度，而向量的方向描述了空间中向量的指向。向量的相关内容高中就已涉及，因此不再赘述。若想要重新深入了解相关内容，可以查看这个地址。 图形渲染中通常使用的向量为222到444维，如下分别是222维、333维、444维向量类的常用方法，主要是运算操作符重载以及点乘、叉乘、模、标准化、线性插值等基本操作。向量的内容简单，没什么要特别说明的。 2D向量类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Vector2D&#123;public: float x,y; // constructors Vector2D():x(0.0f), y(0.0f) &#123;&#125; Vector2D(float newX, float newY):x(newX), y(newY)&#123;&#125; Vector2D(const float * rhs):x(*rhs), y((*rhs)+1) &#123;&#125; Vector2D(const Vector2D &amp; rhs):x(rhs.x), y(rhs.y)&#123;&#125; ~Vector2D() = default; // setter,getter void set(float newX, float newY)&#123;x=newX;y=newY; &#125; void setX(float newX) &#123;x = newX;&#125; void setY(float newY) &#123;y = newY;&#125; float getX() const &#123;return x;&#125; float getY() const &#123;return y;&#125; // normalization void normalize(); Vector2D getNormalize()const; // length float getLength() const &#123; return static_cast&lt;float&gt;(sqrt(x*x + y*y));&#125; float getSquaredLength()const&#123;return static_cast&lt;float&gt;(x*x + y*y);&#125; // overloaded operators Vector2D operator+(const Vector2D &amp;rhs) const &#123;return Vector2D(x + rhs.x, y + rhs.y);&#125; Vector2D operator-(const Vector2D &amp;rhs) const &#123;return Vector2D(x - rhs.x, y - rhs.y);&#125; Vector2D operator*(const float rhs) const &#123;return Vector2D(x*rhs, y*rhs);&#125; Vector2D operator/(const float rhs) const &#123;return (rhs==0) ? Vector2D(0.0f, 0.0f) : Vector2D(x / rhs, y / rhs);&#125; bool operator==(const Vector2D &amp;rhs) const &#123;return (equal(x,rhs.x) &amp;&amp; equal(y,rhs.y));&#125; bool operator!=(const Vector2D &amp;rhs) const &#123;return !((*this)==rhs);&#125; void operator+=(const Vector2D &amp;rhs)&#123;x+=rhs.x; y+=rhs.y;&#125; void operator-=(const Vector2D &amp;rhs)&#123;x-=rhs.x; y-=rhs.y;&#125; void operator*=(const float rhs)&#123;x*=rhs;y*=rhs;&#125; void operator/=(const float rhs)&#123;if(!equal(rhs, 0.0))&#123;x/=rhs;y/=rhs;&#125;&#125; Vector2D operator-() const &#123;return Vector2D(-x, -y);&#125; Vector2D operator+() const &#123;return *this;&#125; // interpolation Vector2D lerp(const Vector2D &amp;v2,const float factor)const &#123;return (*this)*(1.0f - factor) + v2*factor;&#125; Vector2D quadraticInterpolate(const Vector2D &amp; v2, const Vector2D &amp; v3, const float factor) const &#123;return (*this)*(1.0f-factor)*(1.0f-factor) + v2*2.0f*factor*(1.0f-factor) + v3*factor*factor;&#125;&#125;; 3D向量类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Vector3D&#123;public: float x,y,z; // constructors Vector3D():x(0.0f), y(0.0f), z(0.0f)&#123;&#125; Vector3D(float newX, float newY, float newZ):x(newX), y(newY), z(newZ)&#123;&#125; Vector3D(const float * rhs):x(*rhs), y(*(rhs+1)), z(*(rhs+2))&#123;&#125; Vector3D(const Vector3D &amp;rhs):x(rhs.x), y(rhs.y), z(rhs.z)&#123;&#125; ~Vector3D() = default; // setter,getter void set(float newX, float newY, float newZ)&#123;x=newX;y=newY;z=newZ;&#125; void setX(float newX) &#123;x = newX;&#125; void setY(float newY) &#123;y = newY;&#125; void setZ(float newZ) &#123;z = newZ;&#125; float getX() const &#123;return x;&#125; float getY() const &#123;return y;&#125; float getZ() const &#123;return z;&#125; // normalization void normalize(); Vector3D getNormalized() const; // length caculation float getLength() const &#123;return static_cast&lt;float&gt;(sqrt(x*x+y*y+z*z));&#125; float getSquaredLength() const &#123;return x*x+y*y+z*z;&#125; // product float dotProduct(const Vector3D &amp;rhs) const &#123;return x*rhs.x + y*rhs.y + z*rhs.z;&#125; Vector3D crossProduct(const Vector3D &amp;rhs) const &#123;return Vector3D(y*rhs.z - z*rhs.y, z*rhs.x - x*rhs.z, x*rhs.y - y*rhs.x);&#125; // linear interpolation Vector3D lerp(const Vector3D &amp;v2, float factor) const &#123;return (*this)*(1.0f-factor) + v2*factor;&#125; Vector3D QuadraticInterpolate(const Vector3D &amp;v2, const Vector3D &amp;v3, float factor) const &#123;return (*this)*(1.0f-factor)*(1.0f-factor) + v2*2.0f*factor*(1.0f-factor) + v3*factor*factor;&#125; // overloaded operators Vector3D operator+(const Vector3D &amp;rhs) const &#123;return Vector3D(x + rhs.x, y + rhs.y, z + rhs.z);&#125; Vector3D operator-(const Vector3D &amp;rhs) const &#123;return Vector3D(x - rhs.x, y - rhs.y, z - rhs.z);&#125; Vector3D operator*(const float rhs) const &#123;return Vector3D(x*rhs, y*rhs, z*rhs);&#125; Vector3D operator/(const float rhs) const &#123;return (equal(rhs,0.0f))?Vector3D(0.0f, 0.0f, 0.0f):Vector3D(x/rhs, y/rhs, z/rhs);&#125; bool operator==(const Vector3D &amp;rhs) const &#123;return (equal(x,rhs.x) &amp;&amp; equal(y,rhs.y) &amp;&amp; equal(z,rhs.z));&#125; bool operator!=(const Vector3D &amp;rhs) const &#123;return !((*this)==rhs);&#125; void operator+=(const Vector3D &amp;rhs) &#123;x+=rhs.x;y+=rhs.y;z+=rhs.z;&#125; void operator-=(const Vector3D &amp; rhs) &#123;x-=rhs.x;y-=rhs.y;z-=rhs.z;&#125; void operator*=(const float rhs)&#123;x*=rhs;y*=rhs;z*=rhs;&#125; void operator/=(const float rhs)&#123;if(!equal(rhs,0.0f))&#123;x/=rhs; y/=rhs; z/=rhs;&#125;&#125; Vector3D operator-() const &#123;return Vector3D(-x, -y, -z);&#125; Vector3D operator+() const &#123;return *this;&#125;&#125;; 4D向量类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Vector4D&#123;public: float x,y,z,w; // constructors Vector4D():x(0.0f), y(0.0f), z(0.0f), w(0.0f)&#123;&#125; Vector4D(float newX, float newY, float newZ, float newW):x(newX), y(newY), z(newZ), w(newW)&#123;&#125; Vector4D(const float * rhs):x(*rhs), y(*(rhs+1)), z(*(rhs+2)), w(*(rhs+3))&#123;&#125; Vector4D(const Vector4D &amp;rhs):x(rhs.x), y(rhs.y), z(rhs.z), w(rhs.w)&#123;&#125; Vector4D(const Vector3D &amp; rhs): x(rhs.x), y(rhs.y), z(rhs.z), w(1.0f)&#123;&#125; ~Vector4D() = default; // setter,getter void set(float newX, float newY, float newZ, float newW)&#123;x=newX;y=newY;z=newZ;w=newW;&#125; void setX(float newX) &#123;x = newX;&#125; void setY(float newY) &#123;y = newY;&#125; void setZ(float newZ) &#123;z = newZ;&#125; void setW(float newW) &#123;w = newW;&#125; float getX() const &#123;return x;&#125; float getY() const &#123;return y;&#125; float getZ() const &#123;return z;&#125; float getW() const &#123;return w;&#125; // product float dotProduct(const Vector4D &amp;rhs) const &#123;return x*rhs.x + y*rhs.y + z*rhs.z + w*rhs.w;&#125; // linear interpolation Vector4D lerp(const Vector4D &amp;v2, float factor) const &#123;return (*this)*(1.0f-factor) + v2*factor;&#125; Vector4D QuadraticInterpolate(const Vector4D &amp;v2, const Vector4D &amp;v3, float factor) const &#123;return (*this)*(1.0f-factor)*(1.0f-factor)+v2*2.0f*factor*(1.0f-factor)+v3*factor*factor;&#125; // overloaded operators Vector4D operator+(const Vector4D &amp;rhs) const &#123;return Vector4D(x+rhs.x, y+rhs.y, z+rhs.z, w+rhs.w);&#125; Vector4D operator-(const Vector4D &amp;rhs) const &#123;return Vector4D(x-rhs.x, y-rhs.y, z-rhs.z, w-rhs.w);&#125; Vector4D operator*(const float rhs) const &#123;return Vector4D(x*rhs, y*rhs, z*rhs, w*rhs);&#125; Vector4D operator/(const float rhs) const &#123;return (equal(rhs,0.0f))?Vector4D(0.0f, 0.0f, 0.0f, 0.0f):Vector4D(x/rhs, y/rhs, z/rhs, w/rhs);&#125; bool operator==(const Vector4D &amp;rhs) const &#123;return (equal(x,rhs.x)&amp;&amp;equal(y,rhs.y)&amp;&amp;equal(z,rhs.z)&amp;&amp;equal(w,rhs.w));&#125; bool operator!=(const Vector4D &amp;rhs) const &#123;return !((*this)==rhs);&#125; void operator+=(const Vector4D &amp;rhs) &#123;x+=rhs.x;y+=rhs.y;z+=rhs.z;w+=rhs.w;&#125; void operator-=(const Vector4D &amp; rhs) &#123;x-=rhs.x;y-=rhs.y;z-=rhs.z;w-=rhs.w;&#125; void operator*=(const float rhs)&#123;x*=rhs;y*=rhs;z*=rhs;w*=rhs;&#125; void operator/=(const float rhs)&#123;if(!equal(rhs,0.0f))&#123;x/=rhs; y/=rhs; z/=rhs; w/=rhs;&#125;&#125; Vector4D operator-() const &#123;return Vector4D(-x, -y, -z, -w);&#125; Vector4D operator+() const &#123;return *this;&#125;&#125;; 矩阵 矩阵本质就是向量的进一步扩展的，一个n×mn\\times mn×m的矩阵可看成nnn个mmm维行向量组成或者mmm个nnn维列向量组成，关于矩阵的基本概念、操作请看这里。通常我们采用方阵来描述线性变换。所谓线性变换，即变换之后保留了直线而不被弯曲，平行线依然平行，原点没有变化，但其他的几何性质如长度、角度、面积和体积可能被变换改变了。直观来说，线性变换可能“拉伸”坐标系，但不会“弯曲”或“卷折”坐标系。 矩阵在计算机中有行主序存储、列主序存储两种方式，行主序存储即按照顺序逐行存储，列主序存储则按照顺序逐列存储。图形学渲染中我们通常采用的是列主序的方式，**以下的讨论都是列主序的矩阵存储方式。**那么矩阵是如何变换向量的？ 向量在几何上能被解释成一系列与轴平行的位移，一般来说，任意向量v⃗\\vec vv都能写成如下的形式： (1)v⃗=[xyz]=[x00]+[0y0]+[00z]=x[100]+y[010]+z[001]\\vec v=\\left[\\begin{matrix}x\\\\y\\\\z\\end{matrix}\\right]=\\left[\\begin{matrix}x\\\\0\\\\0\\end{matrix}\\right]+\\left[\\begin{matrix}0\\\\y\\\\0\\end{matrix}\\right]+\\left[\\begin{matrix}0\\\\0\\\\z\\end{matrix}\\right]=x\\left[\\begin{matrix}1\\\\0\\\\0\\end{matrix}\\right]+y\\left[\\begin{matrix}0\\\\1\\\\0\\end{matrix}\\right]+z\\left[\\begin{matrix}0\\\\0\\\\1\\end{matrix}\\right] \\tag {1} v=⎣⎡​xyz​⎦⎤​=⎣⎡​x00​⎦⎤​+⎣⎡​0y0​⎦⎤​+⎣⎡​00z​⎦⎤​=x⎣⎡​100​⎦⎤​+y⎣⎡​010​⎦⎤​+z⎣⎡​001​⎦⎤​(1) 公式(1)(1)(1)右边的单位向量就是xxx、yyy、zzz轴方向的向量，向量的每个坐标都表明了平行于相应坐标轴的有向位移。我们记p⃗\\vec pp​、q⃗\\vec qq​、r⃗\\vec rr分别为公式(1)(1)(1)中右边的xxx、yyy、zzz轴的单位列向量，则有： (2)v⃗=xp⃗+yq⃗+zr⃗=[p⃗q⃗r⃗][xyz]\\vec v=x\\vec p+y\\vec q+z\\vec r=\\left[\\begin{matrix}\\vec p &amp;\\vec q&amp;\\vec r\\end{matrix}\\right]\\left[\\begin{matrix}x \\\\y\\\\z\\end{matrix}\\right] \\tag {2} v=xp​+yq​+zr=[p​​q​​r​]⎣⎡​xyz​⎦⎤​(2) 向量v⃗\\vec vv就变成了向量p⃗\\vec pp​、q⃗\\vec qq​、r⃗\\vec rr的线性表示，向量p⃗\\vec pp​、q⃗\\vec qq​、r⃗\\vec rr称作基向量。以上仅仅讨论的是笛卡尔坐标系，但更通用的情况是，一个333维坐标系能用任意333个线性无关的基向量表示，以列向量p⃗\\vec pp​、q⃗\\vec qq​、r⃗\\vec rr构建3×33\\times 33×3的矩阵MMM： (3)M=[p⃗q⃗r⃗]=[pxqxrxpyqyrypzqzrz]M=\\left[\\begin{matrix}\\vec p &amp;\\vec q&amp;\\vec r\\end{matrix}\\right]=\\left[\\begin{matrix}p_x &amp;q_x&amp;r_x\\\\p_y &amp;q_y&amp;r_y\\\\p_z &amp;q_z&amp;r_z\\end{matrix}\\right] \\tag {3} M=[p​​q​​r​]=⎣⎡​px​py​pz​​qx​qy​qz​​rx​ry​rz​​⎦⎤​(3) 结合公式(2)(2)(2)和公式(3)(3)(3)，即有： (4)v⃗=M[xyz]\\vec v=M\\left[\\begin{matrix}x \\\\y\\\\z\\end{matrix}\\right] \\tag{4} v=M⎣⎡​xyz​⎦⎤​(4) 坐标系变换矩阵的每一列（如果是行主序，就是每一行）都是该坐标系的基向量，一个点vvv右乘该矩阵就相当于执行了一次坐标系转换。求解线性变换矩阵的关键就是根据当前的坐标系求解变换之后的坐标系的基向量，然后将基向量填入向量位置！ 一个矩阵类通常有如下方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Matrix4x4&#123;public: float entries[16]; // constructors Matrix4x4()&#123;loadIdentity();&#125; Matrix4x4(float e0, float e1, float e2, float e3, float e4, float e5, float e6, float e7, float e8, float e9, float e10,float e11, float e12,float e13,float e14,float e15); Matrix4x4(const float *rhs); Matrix4x4(const Matrix4x4 &amp;rhs); ~Matrix4x4() = default; // setter,getter void setEntry(int position, float value); float getEntry(int position) const; Vector4D getRow(int position) const; Vector4D getColumn(int position) const; void loadIdentity(); void loadZero(); // overloaded operators Matrix4x4 operator+(const Matrix4x4 &amp; rhs) const; Matrix4x4 operator-(const Matrix4x4 &amp; rhs) const; Matrix4x4 operator*(const Matrix4x4 &amp; rhs) const; Matrix4x4 operator*(const float rhs) const; Matrix4x4 operator/(const float rhs) const; bool operator==(const Matrix4x4 &amp; rhs) const; bool operator!=(const Matrix4x4 &amp; rhs) const; void operator+=(const Matrix4x4 &amp; rhs); void operator-=(const Matrix4x4 &amp; rhs); void operator*=(const Matrix4x4 &amp; rhs); void operator*=(const float rhs); void operator/=(const float rhs); Matrix4x4 operator-() const; Matrix4x4 operator+() const &#123;return (*this);&#125; Vector4D operator*(const Vector4D rhs) const; // inverse, transpose void inverted(); Matrix4x4 getInverse() const; void transpose(); Matrix4x4 getTranspose() const; void invertTranspose(); Matrix4x4 getInverseTranspose() const; // operation on space void setTranslation(const Vector3D &amp; translation); void setScale(const Vector3D &amp; scaleFactor); void setRotationAxis(const double angle, const Vector3D &amp; axis); void setRotationX(const double angle); void setRotationY(const double angle); void setRotationZ(const double angle); void setRotationEuler(const double angleX, const double angleY, const double angleZ); void setPerspective(float fovy, float aspect, float near, float far); void setPerspective(float left, float right, float bottom, float top, float near, float far); void setOrtho(float left, float right, float bottom, float top, float near, float far);&#125;; 线性变换、仿射变换 满足F(a+b)=F(a)+F(b)F(a+b)=F(a)+F(b)F(a+b)=F(a)+F(b)和F(ka)=kF(a)F(ka)=kF(a)F(ka)=kF(a)的映射F(a)F(a)F(a)就是线性的。对于映射F(a)=MaF(a)=MaF(a)=Ma，当MMM为任意方阵时，也可以说明FFF映射是一个线性变换。在计算机图形学中，缩放、旋转的变换操作都是线性的，但是平移不是线性变换。 具有v′=Mv′+bv&#x27;=Mv&#x27;+bv′=Mv′+b形式的变换都是仿射变换。平移作为最常用的变换之一，然而却不是线性变换；所以为了包括平移变换提出了仿射变换。仿射变换是指线性变换后接着平移。因此，仿射变换的集合是线性变换的超集，任何线性变换都是仿射变换，但不是所有的仿射变换都是线性变换。为了统一用矩阵表示低维度的仿射变换，我们可以通过高维度的线性变换来完成，为此引入了444维齐次坐标。（当然引入第444维www还有其他的用途，如当w=0w=0w=0时，可解释为无穷远的“点”，其意义是描述方向），关于齐次坐标的更多内容请查看这里。 从而，对于高维度来说只是经历了一次切变+投影变换就可以实现低维度的平移（更多内容查看这里），在3D3D3D渲染中，我们采用4×44\\times 44×4的矩阵做相应的变换。关于平移和缩放不再赘述： 123456789101112131415void Matrix4x4::setTranslation(const Vector3D &amp;translation)&#123; loadIdentity(); entries[12] = translation.x; entries[13] = translation.y; entries[14] = translation.z;&#125;void Matrix4x4::setScale(const Vector3D &amp;scaleFactor)&#123; loadIdentity(); entries[0] = scaleFactor.x; entries[5] = scaleFactor.y; entries[10] = scaleFactor.z;&#125; 绕任意轴旋转 在3D中，绕坐标轴旋转，而不是绕点旋转，此时首先需要定义的是何为旋转正方向： 左手坐标系中定义此方向的规则为左手法则。首先，要明确旋转轴指向哪个方向。当然，旋转轴在理论上是无限延伸的，但我们还是要认为它有正端点和负端点。与笛卡尔坐标轴定义坐标系相同，左手法则是这样的:伸出左手，大拇指向上，其余手指弯曲。大拇指指向旋转轴的正方向，此时，四指弯曲的方向就是旋转的正方向。右手坐标系则根据右手法则利用右手判断旋转正方向，本文讨论的是常见的右手坐标系。 在旋转变换中，一个常见的特殊情况就是绕xxx轴、绕yyy轴、绕zzz轴旋转，这类的旋转矩阵求解比较简单，只需牢牢记住列主序矩阵的列向量就是变换后的坐标系的基向量即可快速推导出相应的旋转矩阵： (5)Rx(θ)=[1000cosθ−sinθ0sinθcosθ]Ry(θ)=[cosθ0sinθ010−sinθ0cosθ]Rz(θ)=[cosθ−sinθ0sinθcosθ0001]R_x(\\theta)=\\left[ \\begin{matrix} 1&amp;0&amp;0\\\\ 0&amp;cos\\theta&amp;-sin\\theta\\\\ 0&amp;sin\\theta&amp;cos\\theta \\end{matrix}\\right] \\\\ R_y(\\theta)=\\left[\\begin{matrix}cos\\theta&amp;0&amp;sin\\theta\\\\0&amp;1&amp;0\\\\-sin\\theta&amp;0&amp;cos\\theta \\end{matrix}\\right]\\\\ R_z(\\theta)=\\left[\\begin{matrix}cos\\theta&amp;-sin\\theta&amp;0\\\\ sin\\theta&amp;cos\\theta&amp;0\\\\0&amp;0&amp;1\\end{matrix}\\right] \\tag {5} Rx​(θ)=⎣⎡​100​0cosθsinθ​0−sinθcosθ​⎦⎤​Ry​(θ)=⎣⎡​cosθ0−sinθ​010​sinθ0cosθ​⎦⎤​Rz​(θ)=⎣⎡​cosθsinθ0​−sinθcosθ0​001​⎦⎤​(5) 1234567891011121314151617181920212223242526void Matrix4x4::setRotationX(const double angle)&#123; loadIdentity(); entries[5] = static_cast&lt;float&gt;(cos(M_PI*angle/180)); entries[6] = static_cast&lt;float&gt;(sin(M_PI*angle/180)); entries[9] = -entries[6]; entries[10] = entries[5];&#125;void Matrix4x4::setRotationY(const double angle)&#123; loadIdentity(); entries[0] = static_cast&lt;float&gt;(cos(M_PI*angle/180)); entries[2] = -static_cast&lt;float&gt;(sin(M_PI*angle/180)); entries[8] = -entries[2]; entries[10] = entries[0];&#125;void Matrix4x4::setRotationZ(const double angle)&#123; loadIdentity(); entries[0] = static_cast&lt;float&gt;(cos(M_PI*angle/180)); entries[1] = static_cast&lt;float&gt;(sin(M_PI*angle/180)); entries[4] = -entries[1]; entries[5] = entries[0];&#125; 但是更一般的情况是绕任意轴进行旋转，构建这样的矩阵稍微有点麻烦，我们接下来就做一些绕任意轴旋转的矩阵构建推到。在这里我们不考虑平移，因而围绕旋转的轴一定是通过原点的。如下图1所示，将v⃗\\vec vv旋转到v⃗′\\vec v &#x27;v′，任意轴用单位向量n⃗\\vec nn表示，绕n⃗\\vec nn旋转θ\\thetaθ角度的矩阵记为R(n⃗,θ)R(\\vec n, \\theta)R(n,θ)，v⃗′\\vec v&#x27;v′是向量绕轴n⃗\\vec nn旋转后的向量，即v⃗′=R(n⃗,θ)v⃗\\vec v&#x27;=R(\\vec n,\\theta)\\vec vv′=R(n,θ)v。 图1 绕任意轴旋转 **我们的目标就是用v⃗\\vec vv、n⃗\\vec nn和θ\\thetaθ来表示v⃗′\\vec v&#x27;v′，从而构造出R(n⃗,θ)R(\\vec n, \\theta)R(n,θ)。**首先将v⃗\\vec vv分解成平行于n⃗\\vec nn的向量v⃗∣∣\\vec v_{||}v∣∣​和垂直于n⃗\\vec nn的分量v⃗⊥\\vec v_{⊥}v⊥​，而v⃗⊥′\\vec v&#x27;_{⊥}v⊥′​是垂直于n⃗\\vec nn的分向量。注意，n⃗\\vec nn是单位向量，但v⃗\\vec vv不是单位向量，可得v⃗\\vec vv在n⃗\\vec nn方向的投影向量v⃗∣∣\\vec v_{||}v∣∣​为： (6)v⃗∣∣=(v⃗⋅n⃗)n⃗\\vec v_{||}=(\\vec v\\cdot\\vec n)\\vec n \\tag {6} v∣∣​=(v⋅n)n(6) 从而根据v⃗∣∣\\vec v_{||}v∣∣​和v⃗\\vec vv可知v⃗⊥\\vec v_{⊥}v⊥​和www，www是垂直于n⃗\\vec nn和v⃗⊥\\vec v_{⊥}v⊥​的向量： (7)v⃗⊥=v⃗−v⃗∣∣\\vec v_{⊥}=\\vec v-\\vec v_{||} \\tag {7} v⊥​=v−v∣∣​(7) (8)w=n⃗×v⃗⊥=n⃗×(v⃗−v⃗∣∣)=n⃗×v⃗−n⃗×v⃗∣∣=n⃗×v⃗−0=n⃗×v⃗w=\\vec n \\times \\vec v_{⊥} = \\vec n\\times (\\vec v-\\vec v_{||})\\\\ =\\vec n\\times\\vec v-\\vec n\\times\\vec v_{||}=\\vec n\\times\\vec v-0=\\vec n\\times \\vec v \\tag{8} w=n×v⊥​=n×(v−v∣∣​)=n×v−n×v∣∣​=n×v−0=n×v(8) w⃗\\vec ww和v⃗⊥\\vec v_{⊥}v⊥​相互垂直，w⃗\\vec ww、v⃗⊥\\vec v_{⊥}v⊥​和v⃗⊥′\\vec v&#x27;_{⊥}v⊥′​在同一个平面上，v⃗⊥′\\vec v&#x27;_{⊥}v⊥′​和v⃗⊥\\vec v_{⊥}v⊥​的夹角为θ\\thetaθ，从而v⃗⊥′\\vec v&#x27;_{⊥}v⊥′​可由w⃗\\vec ww和v⃗⊥\\vec v_{⊥}v⊥​线性表示为： (9)v⃗⊥′=cosθv⃗⊥+sinθw⃗=cosθ(v⃗−(v⃗⋅n⃗)n⃗)+sinθ(n⃗×v⃗)\\vec v&#x27;_{⊥}=cos\\theta\\vec v_{⊥}+sin\\theta\\vec w\\\\ =cos\\theta(\\vec v-(\\vec v\\cdot\\vec n)\\vec n)+sin\\theta(\\vec n\\times\\vec v)\\tag {9} v⊥′​=cosθv⊥​+sinθw=cosθ(v−(v⋅n)n)+sinθ(n×v)(9) 最后，根据公式(6)(6)(6)和公式(9)(9)(9)我们已知v⃗∣∣\\vec v_{||}v∣∣​和v⃗⊥′\\vec v&#x27;_{⊥}v⊥′​，从而可以得出v⃗′\\vec v&#x27;v′： (10)v⃗′=v⃗∣∣+v⃗⊥′=cosθ(v⃗−(v⃗⋅n⃗)n⃗)+sinθ(n⃗×v⃗)+(v⃗⋅n⃗)n⃗\\vec v&#x27;=\\vec v_{||}+\\vec v&#x27;_{⊥}\\\\ =cos\\theta(\\vec v-(\\vec v\\cdot\\vec n)\\vec n)+sin\\theta(\\vec n\\times\\vec v)+(\\vec v\\cdot\\vec n)\\vec n \\tag {10} v′=v∣∣​+v⊥′​=cosθ(v−(v⋅n)n)+sinθ(n×v)+(v⋅n)n(10) 由公式(10)(10)(10)可知，我们已经用v⃗\\vec vv、n⃗\\vec nn和θ\\thetaθ表示v⃗′\\vec v&#x27;v′，那如何根据上述的公式(10)(10)(10)构建旋转矩阵R(n⃗,θ)R(\\vec n, \\theta)R(n,θ)？还是那个思路：列主序变换矩阵的列向量就是变换后的坐标系的基向量。我们只需求出笛卡尔坐标系的x⃗\\vec xx、y⃗\\vec yy​、z⃗\\vec zz三个轴方向上的基向量按照公式(10)(10)(10)旋转之后的基向量x⃗′\\vec x&#x27;x′、y⃗′\\vec y&#x27;y​′、z⃗′\\vec z&#x27;z′，然后填入矩阵R(n⃗,θ)R(\\vec n, \\theta)R(n,θ)即可，以x⃗=[1 0 0]T\\vec x=[1\\ \\ 0 \\ \\ 0]^Tx=[1 0 0]T为例： (11)x⃗′=cosθ(x⃗−(x⃗⋅n⃗)n⃗)+sinθ(n⃗×x⃗)+(x⃗⋅n⃗)n⃗=[nx2(1−cosθ)+cosθnxny(1−cosθ)+nzsinθnxnz(1−cosθ)−nysinθ)]\\vec x&#x27;=cos\\theta(\\vec x-(\\vec x\\cdot\\vec n)\\vec n)+sin\\theta(\\vec n\\times\\vec x)+(\\vec x\\cdot\\vec n)\\vec n =\\left[\\begin{matrix} n^2_x(1-cos\\theta)+cos\\theta \\\\n_xn_y(1-cos\\theta)+n_zsin\\theta \\\\n_xn_z(1-cos\\theta)-n_ysin\\theta) \\end{matrix}\\right] \\tag {11} x′=cosθ(x−(x⋅n)n)+sinθ(n×x)+(x⋅n)n=⎣⎡​nx2​(1−cosθ)+cosθnx​ny​(1−cosθ)+nz​sinθnx​nz​(1−cosθ)−ny​sinθ)​⎦⎤​(11) y⃗=[0 1 0]T\\vec y=[0\\ \\ 1\\ \\ 0]^Ty​=[0 1 0]T和z⃗=[0 0 1]T\\vec z=[0\\ \\ 0\\ \\ 1]^Tz=[0 0 1]T同理： (12)y⃗′=[nxny(1−cosθ)−nzsinθny2(1−cosθ)+cosθnynz(1−cosθ)+nxsinθ]\\vec y&#x27; =\\left[\\begin{matrix} n_xn_y(1-cos\\theta)-n_zsin\\theta \\\\n^2_y(1-cos\\theta)+cos\\theta \\\\n_yn_z(1-cos\\theta)+n_xsin\\theta \\end{matrix}\\right] \\tag {12} y​′=⎣⎡​nx​ny​(1−cosθ)−nz​sinθny2​(1−cosθ)+cosθny​nz​(1−cosθ)+nx​sinθ​⎦⎤​(12) (13)z⃗′=[nxnz(1−cosθ)+nysinθnynz(1−cosθ)−nxsinθnz2(1−cosθ)+cosθ]\\vec z&#x27; =\\left[\\begin{matrix} n_xn_z(1-cos\\theta)+n_ysin\\theta \\\\n_yn_z(1-cos\\theta)-n_xsin\\theta \\\\n^2_z(1-cos\\theta)+cos\\theta \\end{matrix}\\right] \\tag {13} z′=⎣⎡​nx​nz​(1−cosθ)+ny​sinθny​nz​(1−cosθ)−nx​sinθnz2​(1−cosθ)+cosθ​⎦⎤​(13) 将x⃗′\\vec x&#x27;x′、y⃗′\\vec y&#x27;y​′、z⃗′\\vec z&#x27;z′合并到R(n⃗,θ)R(\\vec n, \\theta)R(n,θ)中： (14)R(n⃗,θ)=[x⃗′y⃗′z⃗′]=[nx2(1−cosθ)+cosθnxny(1−cosθ)−nzsinθnxnz(1−cosθ)+nysinθnxny(1−cosθ)+nzsinθny2(1−cosθ)+cosθnynz(1−cosθ)−nxsinθnxnz(1−cosθ)−nysinθ)nynz(1−cosθ)+nxsinθnz2(1−cosθ)+cosθ]R(\\vec n, \\theta) =\\left[\\begin{matrix} \\vec x&#x27;&amp;\\vec y&#x27;&amp;\\vec z&#x27; \\end{matrix}\\right] \\\\=\\begin{bmatrix} {n_x}^2(1-cos\\theta)+cos\\theta&amp;n_xn_y(1-cos\\theta)-n_zsin\\theta&amp;n_xn_z(1-cos\\theta)+n_ysin\\theta \\\\n_xn_y(1-cos\\theta)+n_zsin\\theta&amp;n^2_y(1-cos\\theta)+cos\\theta&amp;n_yn_z(1-cos\\theta)-n_xsin\\theta \\\\n_xn_z(1-cos\\theta)-n_ysin\\theta)&amp;n_yn_z(1-cos\\theta)+n_xsin\\theta&amp;n^2_z(1-cos\\theta)+cos\\theta \\end{bmatrix} \\tag {14} R(n,θ)=[x′​y​′​z′​]=⎣⎡​nx​2(1−cosθ)+cosθnx​ny​(1−cosθ)+nz​sinθnx​nz​(1−cosθ)−ny​sinθ)​nx​ny​(1−cosθ)−nz​sinθny2​(1−cosθ)+cosθny​nz​(1−cosθ)+nx​sinθ​nx​nz​(1−cosθ)+ny​sinθny​nz​(1−cosθ)−nx​sinθnz2​(1−cosθ)+cosθ​⎦⎤​(14) 12345678910111213141516171819202122void Matrix4x4::setRotationAxis(const double angle, const Vector3D &amp;axis)&#123; Vector3D u = axis.getNormalized(); float sinAngle = static_cast&lt;float&gt;(sin(M_PI*angle/180)); float cosAngle = static_cast&lt;float&gt;(cos(M_PI*angle/180)); float oneMinusCosAngle = 1.0f - cosAngle; loadIdentity(); entries[0] = (u.x)*(u.x) + cosAngle*(1-(u.x)*(u.x)); entries[4] = (u.x)*(u.y)*(oneMinusCosAngle) - sinAngle*u.z; entries[8] = (u.x)*(u.z)*(oneMinusCosAngle) + sinAngle*u.y; entries[1] = (u.x)*(u.y)*(oneMinusCosAngle) + sinAngle*u.z; entries[5] = (u.y)*(u.y) + cosAngle*(1-(u.y)*(u.y)); entries[9] = (u.y)*(u.z)*(oneMinusCosAngle) - sinAngle*u.x; entries[2] = (u.x)*(u.z)*(oneMinusCosAngle) - sinAngle*u.y; entries[6] = (u.y)*(u.z)*(oneMinusCosAngle) + sinAngle*u.x; entries[10] = (u.z)*(u.z) + cosAngle*(1-(u.z)*(u.z));&#125; 透视投影、正交投影 3D3D3D空间中的物体最终都要通过投影显示到2D2D2D的屏幕上，这一过程就是投影变换。投影变换矩阵将视图空间中的顶点数据变换到裁剪空间，裁剪空间中的顶点最后通过透视除法被变换到标准化设备坐标（NDCNDCNDC）。通常由两类投影：透视投影、正交投影。 透视投影矩阵 关于透视投影矩阵的前世今生我不过多说，直接上透视投影矩阵的推导过程。一个视锥体我们目前用六个参数表示：leftleftleft，rightrightright，bottombottombottom，toptoptop，nearnearnear，farfarfar，简写为lll、rrr、bbb、ttt、nnn和fff，即视锥体的六个面。**我们的目标就是将视图空间中在视锥体内的点变换到标准化设备坐标中的立方体内。**即xxx轴方向从[l,r][l,r][l,r]映射到[−1,1][-1,1][−1,1]，yyy轴方向从[b,t][b,t][b,t]映射到[−1,1][-1,1][−1,1]，zzz轴方向从[−n,−f][-n,-f][−n,−f]映射到[−1,1][-1,1][−1,1]。 可能你会觉得奇怪，zzz轴方向为什么是从[−n,−f][-n,-f][−n,−f]映射到[−1,1][-1,1][−1,1]？这是因为摄像机空间的坐标系是右手坐标系，在视图空间中摄像机是朝向视图坐标系的zzz轴的负方向，如下图左边所示，+Y+Y+Y、+Z+Z+Z、+X+X+X标准摄像机坐标系的三个轴，而摄像机的观察视锥体是朝向−Z-Z−Z方向的。而NDCNDCNDC又是左手坐标系，朝向+Z+Z+Z方向，所以我们要取负。 图2 透视投影视锥和标准化设备坐标 图3 从-Y方向看去的视锥横截面 图4 从-X方向看去的视锥横截面 在视锥体中的顶点(xe,ye,ze)(x_e,y_e,z_e)(xe​,ye​,ze​)被投影到视锥体的近平面，近平面上的点我们记为(xp,yp,−n)(x_p,y_p,-n)(xp​,yp​,−n)。如图3和图4所示，根据三角形相似的原理，我们有： (15)xpxe=−nze → xp=−n⋅xeze=n⋅xe−ze\\frac{x_p}{x_e}=\\frac{-n}{z_e}\\ \\rightarrow\\ x_p=\\frac{-n\\cdot x_e}{z_e}=\\frac{n\\cdot x_e}{-z_e} \\tag {15} xe​xp​​=ze​−n​ → xp​=ze​−n⋅xe​​=−ze​n⋅xe​​(15) (16)ypye=−nye → yp=−n⋅yeze=n⋅ye−ze\\frac{y_p}{y_e}=\\frac{-n}{y_e}\\ \\rightarrow\\ y_p=\\frac{-n\\cdot y_e}{z_e}=\\frac{n\\cdot y_e}{-z_e} \\tag {16} ye​yp​​=ye​−n​ → yp​=ze​−n⋅ye​​=−ze​n⋅ye​​(16) 注意到公式(15)(15)(15)和(16)(16)(16)中分母都是一个−ze-z_e−ze​，这与我们将裁剪空间中的顶点做透视除法相对应，透视投影然后做透视除法如下公式(17)(17)(17)、(18)(18)(18)所示： (17)(xclipyclipzclipwclip)=Mprojection⋅(xeyeyeyezeyeweye)\\left( \\begin{matrix} x_{clip}\\\\ y_{clip}\\\\ z_{clip}\\\\ w_{clip} \\end{matrix} \\right) =M_{projection}\\cdot \\left( \\begin{matrix} x_{eye}\\\\ y_{eye}\\\\ z_{eye}\\\\ w_{eye} \\end{matrix} \\right) \\tag {17} ⎝⎜⎜⎛​xclip​yclip​zclip​wclip​​⎠⎟⎟⎞​=Mprojection​⋅⎝⎜⎜⎛​xeye​yeye​zeye​weye​​⎠⎟⎟⎞​(17) (18)(xndcyndczndc)=(xclip/wclipyclip/wclipzclip/wclip)\\left( \\begin{matrix} x_{ndc}\\\\ y_{ndc}\\\\ z_{ndc} \\end{matrix} \\right) = \\left( \\begin{matrix} x_{clip}/w_{clip}\\\\ y_{clip}/w_{clip}\\\\ z_{clip}/w_{clip} \\end{matrix} \\right) \\tag {18} ⎝⎛​xndc​yndc​zndc​​⎠⎞​=⎝⎛​xclip​/wclip​yclip​/wclip​zclip​/wclip​​⎠⎞​(18) 为了便于构建矩阵（xex_exe​和yey_eye​均与−ze-z_e−ze​相除，不好构建矩阵），我们令裁剪空间中的wclipw_{clip}wclip​为−ze-z_e−ze​，将除以−ze-z_e−ze​的这一步挪到了透视除法去做。故目前的透视矩阵就变为： (19)(xcyczcwc)=(............00−10)(xeyezewe)\\left( \\begin{matrix} x_{c}\\\\ y_{c}\\\\ z_{c}\\\\ w_{c} \\end{matrix} \\right) = \\left( \\begin{matrix} .&amp;.&amp;.&amp;.\\\\ .&amp;.&amp;.&amp;.\\\\ .&amp;.&amp;.&amp;.\\\\ 0&amp;0&amp;-1&amp;0 \\end{matrix} \\right) \\left( \\begin{matrix} x_{e}\\\\ y_{e}\\\\ z_{e}\\\\ w_{e} \\end{matrix} \\right) \\tag {19} ⎝⎜⎜⎛​xc​yc​zc​wc​​⎠⎟⎟⎞​=⎝⎜⎜⎛​...0​...0​...−1​...0​⎠⎟⎟⎞​⎝⎜⎜⎛​xe​ye​ze​we​​⎠⎟⎟⎞​(19) 其中&quot;...&quot;均表示未知。得到在近平面的xpx_pxp​和ypy_pyp​之后，我们还要将xpx_pxp​映射到[−1,1][-1,1][−1,1]范围，同理ypy_pyp​也是。以xpx_pxp​为例，我们知道其值域为[l,r][l,r][l,r]。为了将xpx_pxp​其映射到[−1,1][-1,1][−1,1]，我们首先将其映射到[0,1][0,1][0,1]，不难得到如下式子： (20)xp−lr−l∈[0,1]\\frac{x_p-l}{r-l}\\in[0,1] \\tag {20} r−lxp​−l​∈[0,1](20) 式(20)(20)(20)乘上一个222再减去111就映射到了[−1,1][-1,1][−1,1]，映射之后记为xnx_nxn​： (21)xn=2xp−lr−l−1=2xpr−l−r+lr−l∈[−1,1]x_n=2\\frac{x_p-l}{r-l}-1=\\frac{2x_p}{r-l}-\\frac{r+l}{r-l}\\in[-1,1] \\tag {21} xn​=2r−lxp​−l​−1=r−l2xp​​−r−lr+l​∈[−1,1](21) 同理ypy_pyp​到yny_nyn​的映射： (22)yn=2ypr−l−t+bt−b∈[−1,1]y_n=\\frac{2y_p}{r-l}-\\frac{t+b}{t-b}\\in[-1,1] \\tag {22} yn​=r−l2yp​​−t−bt+b​∈[−1,1](22) 然后将公式(15)(15)(15)中的xpx_pxp​带入公式(21)(21)(21)，将公式(16)(16)(16)中的ypy_pyp​带入公式(22)(22)(22)，以xpx_pxp​为例： (23)xn=2xpr−l−r+lr−l=2n⋅xe−zer−l−r+lr−l=2n⋅xe(r−l)(−ze)−r+lr−l=2nr−l⋅xe−ze−r+lr−l=2nr−l⋅xe−ze+r+lr−l⋅ze−ze=(2nr−l⋅xe+r+lr−l⋅ze)⎵xc/−zex_n=\\frac{2x_p}{r-l}-\\frac{r+l}{r-l} =\\frac{2\\frac{n\\cdot x_e}{-z_e}}{r-l}-\\frac{r+l}{r-l}\\\\ =\\frac{2n\\cdot x_e}{(r-l)(-z_e)}-\\frac{r+l}{r-l} =\\frac{\\frac{2n}{r-l}\\cdot x_e}{-z_e}-\\frac{r+l}{r-l}\\\\ =\\frac{\\frac{2n}{r-l}\\cdot x_e}{-z_e}+\\frac{\\frac{r+l}{r-l}\\cdot z_e}{-z_e} =\\underbrace{(\\frac{2n}{r-l}\\cdot x_e+\\frac{r+l}{r-l}\\cdot z_e)}_{x_c}/-z_e \\tag {23} xn​=r−l2xp​​−r−lr+l​=r−l2−ze​n⋅xe​​​−r−lr+l​=(r−l)(−ze​)2n⋅xe​​−r−lr+l​=−ze​r−l2n​⋅xe​​−r−lr+l​=−ze​r−l2n​⋅xe​​+−ze​r−lr+l​⋅ze​​=xc​(r−l2n​⋅xe​+r−lr+l​⋅ze​)​​/−ze​(23) 其中xcx_cxc​即公式(19)(19)(19)中的裁剪空间中的xxx轴坐标值。ypy_pyp​同理可得ycy_cyc​: (24)yn=(2nt−b⋅ye+t+bt−b⋅ze)⎵yc/−zey_n =\\underbrace{(\\frac{2n}{t-b}\\cdot y_e+\\frac{t+b}{t-b}\\cdot z_e)}_{y_c}/-z_e \\tag {24} yn​=yc​(t−b2n​⋅ye​+t−bt+b​⋅ze​)​​/−ze​(24) 现在我们已经知道了xcx_cxc​和ycy_cyc​分辨关于xex_exe​、yey_eye​以及zez_eze​的表达形式，我们可以填充式(19)(19)(19)中的投影矩阵第一行与第二行： (25)(xcyczcwc)=(2nr−l0r+lr−l002nt−bt+bt−b000AB00−10)(xeyezewe)\\left( \\begin{matrix} x_{c}\\\\ y_{c}\\\\ z_{c}\\\\ w_{c} \\end{matrix} \\right) = \\left( \\begin{matrix} \\frac{2n}{r-l}&amp;0&amp;\\frac{r+l}{r-l}&amp;0\\\\ 0&amp;\\frac{2n}{t-b}&amp;\\frac{t+b}{t-b}&amp;0\\\\ 0&amp;0&amp;A&amp;B\\\\ 0&amp;0&amp;-1&amp;0 \\end{matrix} \\right) \\left( \\begin{matrix} x_{e}\\\\ y_{e}\\\\ z_{e}\\\\ w_{e} \\end{matrix} \\right) \\tag {25} ⎝⎜⎜⎛​xc​yc​zc​wc​​⎠⎟⎟⎞​=⎝⎜⎜⎛​r−l2n​000​0t−b2n​00​r−lr+l​t−bt+b​A−1​00B0​⎠⎟⎟⎞​⎝⎜⎜⎛​xe​ye​ze​we​​⎠⎟⎟⎞​(25) 现在我们还剩下投影矩阵的第三行还不知道。因为我们知道zzz的投影与xex_exe​和yey_eye​无关，只与zez_eze​、wew_ewe​有关，故可以假设投影矩阵的第三行如上式(25)(25)(25)所示，AAA和BBB就是我们假设的要求解的未知表达式。此外，在视图空间中的wew_ewe​是等于111的，wcw_cwc​即前面提到的−ze-z_e−ze​，从而有： (26)zn=zc/wc=Aze+Bwe−ze=Aze+B−zez_n=z_c/w_c=\\frac{Az_e+Bw_e}{-z_e}=\\frac{Az_e+B}{-z_e} \\tag {26} zn​=zc​/wc​=−ze​Aze​+Bwe​​=−ze​Aze​+B​(26) 为了求出公式(26)(26)(26)中的AAA和BBB，我们取两个极端的例子：在−n-n−n处的zzz值被映射到−1-1−1，在−f-f−f处的zzz值被映射到111，将(zn,ze)=(−1,−n)(z_n,z_e)=(-1,-n)(zn​,ze​)=(−1,−n)和(zn,ze)=(1,−f)(z_n,z_e)=(1,-f)(zn​,ze​)=(1,−f)带入式(26)(26)(26)中，可得方程组： (27){−An+Bn=−1−Af+Bf=1 → {−An+B=−n−Af+B=f\\begin{cases} \\frac{-An+B}{n}=-1\\\\ \\frac{-Af+B}{f}=1\\\\ \\end{cases}\\ \\rightarrow\\ \\begin{cases} {-An+B}=-n\\\\ {-Af+B}=f\\\\ \\end{cases} \\tag {27} {n−An+B​=−1f−Af+B​=1​ → {−An+B=−n−Af+B=f​(27) 求解方程(27)(27)(27)，可得AAA与BBB如下所示： (28)A=−f+nf−nB=−2fnf−nA=-\\frac{f+n}{f-n}\\\\ B=-\\frac{2fn}{f-n} \\tag {28} A=−f−nf+n​B=−f−n2fn​(28) 将公式(28)(28)(28)带入公式(26)(26)(26)中： (29)zn=(−f+nf−nze−2fnf−n)⎵zc/−zez_n=\\underbrace{(-\\frac{f+n}{f-n}z_e-\\frac{2fn}{f-n})}_{z_c}/{-z_e} \\tag {29} zn​=zc​(−f−nf+n​ze​−f−n2fn​)​​/−ze​(29) 我们最终得到了zcz_czc​关于zez_eze​的表达式，将AAA与BBB填入式(25)(25)(25)的投影矩阵即可，MprojectionM_{projection}Mprojection​就是我们一直在寻求的透视投影矩阵： (30)Mprojection=(2nr−l0r+lr−l002nt−bt+bt−b000−f+nf−n−2fnf−n00−10)M_{projection}= \\left( \\begin{matrix} \\frac{2n}{r-l}&amp;0&amp;\\frac{r+l}{r-l}&amp;0\\\\ 0&amp;\\frac{2n}{t-b}&amp;\\frac{t+b}{t-b}&amp;0\\\\ 0&amp;0&amp;-\\frac{f+n}{f-n}&amp;-\\frac{2fn}{f-n}\\\\ 0&amp;0&amp;-1&amp;0 \\end{matrix} \\right) \\tag {30} Mprojection​=⎝⎜⎜⎛​r−l2n​000​0t−b2n​00​r−lr+l​t−bt+b​−f−nf+n​−1​00−f−n2fn​0​⎠⎟⎟⎞​(30) 公式(30)(30)(30)中的透视投影矩阵只是一个通用的形式，在视图空间中的视锥体通常都是关于xxx轴和yyy轴对称的，从而有r=−lr=-lr=−l、t=−bt=-bt=−b，将式(30)(30)(30)简化成如下形式： (31)Mprojection=(2nr−l00002nt−b0000−f+nf−n−2fnf−n00−10)M_{projection}= \\left( \\begin{matrix} \\frac{2n}{r-l}&amp;0&amp;0&amp;0\\\\ 0&amp;\\frac{2n}{t-b}&amp;0&amp;0\\\\ 0&amp;0&amp;-\\frac{f+n}{f-n}&amp;-\\frac{2fn}{f-n}\\\\ 0&amp;0&amp;-1&amp;0 \\end{matrix} \\right) \\tag {31} Mprojection​=⎝⎜⎜⎛​r−l2n​000​0t−b2n​00​00−f−nf+n​−1​00−f−n2fn​0​⎠⎟⎟⎞​(31) 但是通常我们传入构建透视矩阵函数的参数是fovyfovyfovy（yyy轴方向的视域角）、aspectaspectaspect（屏幕的宽高比）、nearnearnear（近平面）以及farfarfar（远平面），如何根据这些参数构造式(31)(31)(31)的透视投影矩阵呢？注意到r−l=widthr-l=widthr−l=width即近平面宽度，t−b=heightt-b=heightt−b=height即近平面的高度，我们可以根据fovyfovyfovy和aspectaspectaspect得出widthwidthwidth和heightheightheight，具体细节不再赘述： r−l=width=2∗near∗aspect∗tan(fovy/2)t−b=height=2∗near∗tan(fovy/2)r-l=width=2*near*aspect*tan(fovy/2)\\\\ t-b=height=2*near*tan(fovy/2) r−l=width=2∗near∗aspect∗tan(fovy/2)t−b=height=2∗near∗tan(fovy/2) (32)Mprojection=(1aspect∗tan(fovy/2)00001tan(fovy/2)0000−f+nf−n−2fnf−n00−10)M_{projection}= \\left( \\begin{matrix} \\frac{1}{aspect*tan(fovy/2)}&amp;0&amp;0&amp;0\\\\ 0&amp;\\frac{1}{tan(fovy/2)}&amp;0&amp;0\\\\ 0&amp;0&amp;-\\frac{f+n}{f-n}&amp;-\\frac{2fn}{f-n}\\\\ 0&amp;0&amp;-1&amp;0 \\end{matrix} \\right) \\tag {32} Mprojection​=⎝⎜⎜⎜⎛​aspect∗tan(fovy/2)1​000​0tan(fovy/2)1​00​00−f−nf+n​−1​00−f−n2fn​0​⎠⎟⎟⎟⎞​(32) 123456789101112void Matrix4x4::setPerspective(float fovy, float aspect, float near, float far)&#123; loadZero(); // convert fov from degrees to radians float rFovy = fovy*M_PI/180; const float tanHalfFovy = tanf(static_cast&lt;float&gt;(rFovy*0.5f)); entries[0] = 1.0f/(aspect*tanHalfFovy); entries[5] = 1.0f/(tanHalfFovy); entries[10] = -(far+near)/(far-near); entries[11] = -1.0f; entries[14] = (-2.0f*near*far)/(far-near);&#125; 正交投影矩阵 理解了透视投影矩阵的构造之后，正交投影就简单太多了，正交投影只需做简单的线性映射就行了。只需将xxx轴方向从[l,r][l,r][l,r]映射到[−1,1][-1,1][−1,1]，yyy轴方向从[b,t][b,t][b,t]映射到[−1,1][-1,1][−1,1]，zzz轴方向从[−n,−f][-n,-f][−n,−f]映射到[−1,1][-1,1][−1,1]，而这个映射的过程很简单，正如前面公式(20)(20)(20)和(21)(21)(21)那样，先映射到[0,1][0,1][0,1]，再映射到[0,2][0,2][0,2]，最后映射到[−1,1][-1,1][−1,1]，这个过程我也不细说了，直接上结果： (33)Mprojection=(2r−l00−r+lr−l02t−b0−t+bt−b00−2f−n−f+nf−n0001)M_{projection}= \\left( \\begin{matrix} \\frac{2}{r-l}&amp;0&amp;0&amp;-\\frac{r+l}{r-l}\\\\ 0&amp;\\frac{2}{t-b}&amp;0&amp;-\\frac{t+b}{t-b}\\\\ 0&amp;0&amp;\\frac{-2}{f-n}&amp;-\\frac{f+n}{f-n}\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right) \\tag {33} Mprojection​=⎝⎜⎜⎛​r−l2​000​0t−b2​00​00f−n−2​0​−r−lr+l​−t−bt+b​−f−nf+n​1​⎠⎟⎟⎞​(33) 然后又因为视锥体关于xxx轴、yyy轴对称，简化的正交投影矩阵就为： (33)Mprojection=(2r−l00002t−b0000−2f−n−f+nf−n0001)M_{projection}= \\left( \\begin{matrix} \\frac{2}{r-l}&amp;0&amp;0&amp;0\\\\ 0&amp;\\frac{2}{t-b}&amp;0&amp;0\\\\ 0&amp;0&amp;\\frac{-2}{f-n}&amp;-\\frac{f+n}{f-n}\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right) \\tag {33} Mprojection​=⎝⎜⎜⎛​r−l2​000​0t−b2​00​00f−n−2​0​00−f−nf+n​1​⎠⎟⎟⎞​(33) 12345678910void Matrix4x4::setOrtho(float left, float right, float bottom, float top, float near, float far)&#123; loadIdentity(); entries[0] = 2.0f/(right-left); entries[5] = 2.0f/(top-bottom); entries[10] = -2.0f/(far-near); entries[12] = -(right+left)/(right-left); entries[13] = -(top+bottom)/(top-bottom); entries[14] = -(far+near)/(far-near);&#125; lookAt函数构造视图矩阵 视图矩阵的工作目标是将世界坐标系中的所有物体的顶点的坐标从世界坐标系转换到摄像机坐标系。这是因为摄像机坐标系的原点不一定与世界坐标系重合，同时由于自身的旋转，坐标轴也一定不与世界坐标系的坐标轴平行。为完成工作任务，需要分为两步走：首先整体平移，将摄像机平移至世界坐标系原点，然后将顶点从世界坐标系变换至摄像机坐标系。 lookAt函数的输入参数分别为：eyeeyeeye摄像机的位置，targettargettarget摄像机目标点，upupup世界空间的上向量,。首先我们要根据这些参数确定摄像机坐标系的三个轴向量，其中需要非常注意的就是变换到视图空间中时摄像机是朝向视图空间的−Z-Z−Z方向的，所以求视图空间中的ZZZ轴时是摄像机的位置减去目标点的位置： Z=normalize(eye−target)X=normalize(cross(up,Z))Y=normalize(cross(Z,X))Z = normalize(eye - target)\\\\ X = normalize(cross(up, Z))\\\\ Y = normalize(cross(Z,X)) Z=normalize(eye−target)X=normalize(cross(up,Z))Y=normalize(cross(Z,X)) 通过以上的方式我们就求出了视图空间的三条轴向量，再加上摄像机的位置我们就可以求出将世界坐标变换到与视图坐标重合的矩阵了，记为M=T⋅RM=T\\cdot RM=T⋅R，其中TTT是平移到摄像机位置eyeeyeeye的变换矩阵，RRR是旋转到摄像机坐标轴方向的旋转矩阵： (34)M=T⋅R=[100eyex010eyex001eyex0001]⋅[XxYxZx0XyYyZy0XzYzZz00001]M=T\\cdot R= \\left[ \\begin{matrix} 1&amp;0&amp;0&amp;eye_x\\\\ 0&amp;1&amp;0&amp;eye_x\\\\ 0&amp;0&amp;1&amp;eye_x\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] \\cdot \\left[ \\begin{matrix} X_x&amp;Y_x&amp;Z_x&amp;0\\\\ X_y&amp;Y_y&amp;Z_y&amp;0\\\\ X_z&amp;Y_z&amp;Z_z&amp;0\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] \\tag {34} M=T⋅R=⎣⎢⎢⎡​1000​0100​0010​eyex​eyex​eyex​1​⎦⎥⎥⎤​⋅⎣⎢⎢⎡​Xx​Xy​Xz​0​Yx​Yy​Yz​0​Zx​Zy​Zz​0​0001​⎦⎥⎥⎤​(34) 然而公式(34)(34)(34)并不是我们要求的视图矩阵，上式中的矩阵MMM仅仅是将世界坐标轴变换到摄像机坐标轴。摄像机只是一个虚拟的物品，我们不能将上述的矩阵MMM作用于摄像机，因为摄像机根本不存在！我们视图矩阵最终作用的世界空间中的物体，这就涉及到了一个相对运动的概念！ 当我们向前移动摄像机的时候，可以看成是摄像机不动，而物体朝着与摄像机朝向相反的方向移动。当我们向右旋转摄像机时，相当于摄像机不动而物体朝着摄像机的左边移动。摄像机的构造得益于相对于运动的理论，计算机图形学中的虚拟3D3D3D摄像机实际上是通过物体的移动来实现的，所以我们要构造的视图矩阵是公式(34)(34)(34)中的逆矩阵。 (35)viewMatrix=M−1=(T⋅R)−1=R−1⋅T−1=[XxYxZx0XyYyZy0XzYzZz00001]−1⋅[100eyex010eyex001eyex0001]−1viewMatrix = M^{-1}=(T\\cdot R)^{-1}=R^{-1}\\cdot T^{-1} = \\left[ \\begin{matrix} X_x&amp;Y_x&amp;Z_x&amp;0\\\\ X_y&amp;Y_y&amp;Z_y&amp;0\\\\ X_z&amp;Y_z&amp;Z_z&amp;0\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right]^{-1} \\cdot \\left[ \\begin{matrix} 1&amp;0&amp;0&amp;eye_x\\\\ 0&amp;1&amp;0&amp;eye_x\\\\ 0&amp;0&amp;1&amp;eye_x\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right]^{-1} \\tag {35} viewMatrix=M−1=(T⋅R)−1=R−1⋅T−1=⎣⎢⎢⎡​Xx​Xy​Xz​0​Yx​Yy​Yz​0​Zx​Zy​Zz​0​0001​⎦⎥⎥⎤​−1⋅⎣⎢⎢⎡​1000​0100​0010​eyex​eyex​eyex​1​⎦⎥⎥⎤​−1(35) 由上式可知，构造视图矩阵涉及到RRR和TTT的求逆，其中的平移矩阵TTT的求逆则是直接取平移量的相反数即可： (36)T−1=[100eyex010eyex001eyex0001]−1=[100−eyex010−eyex001−eyex0001]T^{-1}= \\left[ \\begin{matrix} 1&amp;0&amp;0&amp;eye_x\\\\ 0&amp;1&amp;0&amp;eye_x\\\\ 0&amp;0&amp;1&amp;eye_x\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right]^{-1} = \\left[ \\begin{matrix} 1&amp;0&amp;0&amp;-eye_x\\\\ 0&amp;1&amp;0&amp;-eye_x\\\\ 0&amp;0&amp;1&amp;-eye_x\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] \\tag {36} T−1=⎣⎢⎢⎡​1000​0100​0010​eyex​eyex​eyex​1​⎦⎥⎥⎤​−1=⎣⎢⎢⎡​1000​0100​0010​−eyex​−eyex​−eyex​1​⎦⎥⎥⎤​(36) 至于旋转矩阵RRR，我们知道旋转矩阵都是正交矩阵，正交矩阵的一个特点就是它的逆等于它的转置： (37)R−1=[XxYxZx0XyYyZy0XzYzZz00001]−1=[XxXyXz0YxYyYz0ZxZyZz00001]R^{-1}= \\left[ \\begin{matrix} X_x&amp;Y_x&amp;Z_x&amp;0\\\\ X_y&amp;Y_y&amp;Z_y&amp;0\\\\ X_z&amp;Y_z&amp;Z_z&amp;0\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right]^{-1} = \\left[ \\begin{matrix} X_x&amp;X_y&amp;X_z&amp;0\\\\ Y_x&amp;Y_y&amp;Y_z&amp;0\\\\ Z_x&amp;Z_y&amp;Z_z&amp;0\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] \\tag {37} R−1=⎣⎢⎢⎡​Xx​Xy​Xz​0​Yx​Yy​Yz​0​Zx​Zy​Zz​0​0001​⎦⎥⎥⎤​−1=⎣⎢⎢⎡​Xx​Yx​Zx​0​Xy​Yy​Zy​0​Xz​Yz​Zz​0​0001​⎦⎥⎥⎤​(37) 最后，我们得到视图矩阵： (38)viewMatrix=R−1⋅T−1=[XxXyXz0YxYyYz0ZxZyZz00001]⋅[100−eyex010−eyex001−eyex0001]=[XxXyXz−(X⃗⋅eye⃗)YxYyYz−(Y⃗⋅eye⃗)ZxZyZz−(Z⃗⋅eye⃗)0001]viewMatrix=R^{-1}\\cdot T^{-1}= \\left[ \\begin{matrix} X_x&amp;X_y&amp;X_z&amp;0\\\\ Y_x&amp;Y_y&amp;Y_z&amp;0\\\\ Z_x&amp;Z_y&amp;Z_z&amp;0\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] \\cdot \\left[ \\begin{matrix} 1&amp;0&amp;0&amp;-eye_x\\\\ 0&amp;1&amp;0&amp;-eye_x\\\\ 0&amp;0&amp;1&amp;-eye_x\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] \\\\= \\left[ \\begin{matrix} X_x&amp;X_y&amp;X_z&amp;-(\\vec X\\cdot \\vec {eye})\\\\ Y_x&amp;Y_y&amp;Y_z&amp;-(\\vec Y\\cdot \\vec {eye})\\\\ Z_x&amp;Z_y&amp;Z_z&amp;-(\\vec Z\\cdot \\vec {eye})\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] \\tag {38} viewMatrix=R−1⋅T−1=⎣⎢⎢⎡​Xx​Yx​Zx​0​Xy​Yy​Zy​0​Xz​Yz​Zz​0​0001​⎦⎥⎥⎤​⋅⎣⎢⎢⎡​1000​0100​0010​−eyex​−eyex​−eyex​1​⎦⎥⎥⎤​=⎣⎢⎢⎡​Xx​Yx​Zx​0​Xy​Yy​Zy​0​Xz​Yz​Zz​0​−(X⋅eye​)−(Y⋅eye​)−(Z⋅eye​)1​⎦⎥⎥⎤​(38) 1234567891011121314151617181920212223242526void Matrix4x4::setLookAt(Vector3D cameraPos, Vector3D target, Vector3D worldUp)&#123; Vector3D zAxis = cameraPos - target; zAxis.normalize(); Vector3D xAxis = worldUp.crossProduct(zAxis); xAxis.normalize(); Vector3D yAxis = zAxis.crossProduct(xAxis); yAxis.normalize(); loadIdentity(); entries[0] = xAxis.x; entries[4] = xAxis.y; entries[8] = xAxis.z; entries[1] = yAxis.x; entries[5] = yAxis.y; entries[9] = yAxis.z; entries[2] = zAxis.x; entries[6] = zAxis.y; entries[10] = zAxis.z; entries[12] = -(xAxis.dotProduct(cameraPos)); entries[13] = -(yAxis.dotProduct(cameraPos)); entries[14] = -(zAxis.dotProduct(cameraPos));&#125; 参考资料 [1][1][1] http://www.songho.ca/opengl/gl_projectionmatrix.html [2][2][2] https://blog.csdn.net/zsq306650083/article/details/8773996 [3][3][3] https://blog.csdn.net/y1196645376/article/details/78463248 [4][4][4] https://www.cnblogs.com/J1ac/p/9340622.html [5][5][5] [https://learnopengl-cn.github.io/01 Getting started/08 Coordinate Systems/](https://learnopengl-cn.github.io/01 Getting started/08 Coordinate Systems/)","categories":[{"name":"Computer Graphics","slug":"Computer-Graphics","permalink":"http://yoursite.com/categories/Computer-Graphics/"},{"name":"Soft Renderer","slug":"Soft-Renderer","permalink":"http://yoursite.com/categories/Soft-Renderer/"}],"tags":[{"name":"Computer Graphics","slug":"Computer-Graphics","permalink":"http://yoursite.com/tags/Computer-Graphics/"},{"name":"Soft Renderer","slug":"Soft-Renderer","permalink":"http://yoursite.com/tags/Soft-Renderer/"},{"name":"3D Math","slug":"3D-Math","permalink":"http://yoursite.com/tags/3D-Math/"}]},{"title":"L-系统构建三维分形树","slug":"LSystem","date":"2019-04-25T12:42:49.161Z","updated":"2019-04-27T09:12:06.981Z","comments":true,"path":"2019/04/25/LSystem/","link":"","permalink":"http://yoursite.com/2019/04/25/LSystem/","excerpt":"本次我将带来L系统构建分形树的实现。树一直都是虚拟室外景观中非常重要的一部分。目前模拟树的方法有很多，其中最为廉价的就是公告牌了，用一个2D的平面去仿造三维立体的效果，在以前显卡还不强力的时候这是个不错的选择，即使是现在也有用武之地。还有通过三维建模工具建立的三维模型，这些三维模型非常逼真，但是有个非常大的缺点，就是顶点多了很多，所以需要进一步的处理，如LOD算法来降低显卡的负担。实际上也可以和公告牌结合起来，例如远处就没有必要用模型去渲染了，直接用公告牌，如此折中也不错。还有一种方法就是通过程序来构建树的结构，在这里我将介绍通过L-系统语法规则进行植物建模。采用的图形API为OpenGL3.3+，可编程管线。","text":"本次我将带来L系统构建分形树的实现。树一直都是虚拟室外景观中非常重要的一部分。目前模拟树的方法有很多，其中最为廉价的就是公告牌了，用一个2D的平面去仿造三维立体的效果，在以前显卡还不强力的时候这是个不错的选择，即使是现在也有用武之地。还有通过三维建模工具建立的三维模型，这些三维模型非常逼真，但是有个非常大的缺点，就是顶点多了很多，所以需要进一步的处理，如LOD算法来降低显卡的负担。实际上也可以和公告牌结合起来，例如远处就没有必要用模型去渲染了，直接用公告牌，如此折中也不错。还有一种方法就是通过程序来构建树的结构，在这里我将介绍通过L-系统语法规则进行植物建模。采用的图形API为OpenGL3.3+，可编程管线。 前言 L-系统原理介绍 L-系统建模实践 实现效果演示 前言 本次我将带来L系统构建分形树的实现。树一直都是虚拟室外景观中非常重要的一部分。目前模拟树的方法有很多，其中最为廉价的就是公告牌了，用一个2D的平面去仿造三维立体的效果，在以前显卡还不强力的时候这是个不错的选择，即使是现在也有用武之地。还有通过三维建模工具建立的三维模型，这些三维模型非常逼真，但是有个非常大的缺点，就是顶点多了很多，所以需要进一步的处理，如LOD算法来降低显卡的负担。实际上也可以和公告牌结合起来，例如远处就没有必要用模型去渲染了，直接用公告牌，如此折中也不错。还有一种方法就是通过程序来构建树的结构，在这里我将介绍通过L-系统语法规则进行植物建模。采用的图形API为OpenGL3.3+，可编程管线。 L-系统原理介绍 L-系统的定义 Lindenmayer 系统（简称为L-系统），是由生物学家Aristid Lindenmayer于1968年引进的一种字符串迭代重写机制，被认为是植物生长的数学理论。其核心概念是重写，也成为迭代重写。一般情况下，重写是通过应用一个重写规则或产生式的集合，对简单的初始目标中的部分（可以是一部分也可以是多个部分）进行连续置换来定义复杂目标的技术。在L-系统中，产生式是并行地、同时替换所给字符串中的所有字符，这种区别反映了L-系统的生物学动机。如下图所示，是利用迭代重写规则生成的雪花曲线。 开始由初始图形和生成规则，生成规则是由一条定向的折线形成的、边长为r的N次等边图形，我们称之为规则模型，这样每一步都利用规则模型替换前一个图形的每一条直线边，使得置换的生成规则与被置换的区间具有相同的端点。迭代四次后生成的图形类似雪花图形。这里说得有点抽象，下面就具体举个粒子。 L-系统的形式化语言是基于字符表示。假设初始字符串为A，生成规则（或产生式规则）为： $$A -&gt; aB$$$$B -&gt; bA$$ 则经过一次推导，第一个生成规则符合第一个条件，则由aB代替A，其结果为aB。第二次推导，根据第二个生成规则，字符B由bA代替，其余的没有生成规则的字符不变，也就是复制过来，其结果为abA，以此类推，abA产生abaB，继续下去依次得到ababA、ababaB等等。这个迭代重写机制不难理解。 ###L-系统的几何解释 经过语法规则迭代重写得到的仅仅是一串字符串，我们还需要对这些字符进行解析。Prusinkiewicz提出解析L-系统的海龟解释方法。海龟解释的基本思想如下：平面上海龟的当前状态由一个三原数组(x,y,a)来定义，其中笛卡儿坐标(x,y)表示海龟的位置，角度a为海龟的前进方向，可以解释为海龟面对的方向。给出步长d和角度的增量sita，海龟根据以下符号所代表的命令做出反应。 F：海龟向前移动一个步长d，海龟的位置变为(x1,y1,a)，其中，x1 = x + dcos(a)，y1 = y + dsin(a)，在点(x,y)和(x1,y1)之间画一条线段。 f：向前移动一个步长d，不画线段。 +：向左转角度sita，海龟的下一个状态为(x1,y1,a+sita)，角的正方向为逆时针方向。 -：向右转角度sita，海龟的下一个状态为(x1,y1,a-sita)。 [：将海龟的当前状态压如堆栈。 ]：从堆栈中弹出当前海龟的状态。 假设有字符串：F[-F[-F -F]FF -F - FF]FF -F -FF 另海龟的初始方向角为90度，旋转角增量为90度，前进步长为d（单个方格的长度），则海龟的爬行路径如图所示： 这只是个简单的例子，而且是二维平面上的。现在我们把它扩展到三维空间，海龟在空间的当前位置是由三个向量[x,y,z]表示的，他们分别表示海龟前进的方向、向左的方向和向上的方向，三个方向向量是相互垂直的单位向量。海龟的旋转可由以下方程完成： [x1,y1,z1]=[x,y,z]∗R[x1,y1,z1] = [x,y,z]*R [x1,y1,z1]=[x,y,z]∗R 其中R是一个3×3的矩阵，当旋转角为alpha的时候，绕向量x、y、z的旋转矩阵表示如下： 海龟在空间中旋转的方向如图所示: +：向左旋转角度sita，使用旋转矩阵Rz(sita)； -：向右旋转角度sita，使用旋转矩阵Rz(-sita)； &amp;：向下旋转角度sita，使用旋转矩阵Ry(sita)； ^：向上旋转角度sita，使用旋转矩阵Ry(-sita)； \\：向左滚动角度sita，使用旋转矩阵Rx(sita)； /：向右滚动角度sita，使用旋转矩阵Rx(-sita)； 其中Rx(sita)、Ry(sita)、Rz(sita)分别表示绕x、y、z轴旋转sita角度。通过以上的方式控制海龟的旋转方向，就可以利用L-系统绘制三维空间上的图形。 好了，经过上面的长篇大论，相信都已经对L-系统有了一个清晰的认识，接下来我们就进行实践。 L-系统建模实践 随机L-系统 为了构建更加真实的植物，现在引入随机L-系统。相比确定性L-系统，随机L-系统加入了一个随机的概率，这个概率表现在产生式上。举个简单的粒子：$$w:F$$$$F-&gt;F[+F]F[-F]F、F[+F]F、F[-F]F$$这就是一个简单随机L-系统实例，注意到F的替换规则有三个，分别是F[+F]F[-F]F、F[+F]F和F[-F]F，那么替换的时候选哪个？这个时候就是靠概率来决定了，令三个产生式被选中的概率都是三分之一，替换的时候根据概率选取用哪个来进行替换。这样产生的植物局部是随机的，但是整体上维持了该种植物的一般性特征。 语法解析器 现在我们来构建一个语法解析器。这个语法解析器根据初始字符串、需要迭代的层级、产生式进行字符串的平行重写迭代。两个for循环就搞定了，外层循环是迭代的层级，内聪循环则是对当前的字符串进行替换。废话不多少，核心代码如下： 1234567891011121314151617181920212223242526272829303132333435363738void Grammar::Iteration(int level)&#123;//字符串迭代重写，level为迭代次数 srand(time(NULL)); result = start; for(int i = 0;i &lt; level;i ++)&#123; string tmpstr = \"\"; for(int j = 0;j &lt; result.size();j ++)&#123; tmpstr += search(result[j]); &#125; result = tmpstr; &#125;&#125;string Grammar::search(char target)&#123; int index = find(target); if(index == -1)&#123; //在产生式中没有它的替换规则，那么直接就是复制它自身 string ret; ret.push_back(target); return ret; &#125; //generations里面存储了产生式，用pair&lt;char,vector&lt;string&gt; &gt;的数据结构 int num = generations[index].second.size(); int index = rand()%num;//在多个产生式中等概率选取一个 return generations[index].second[index];&#125;int Grammar::find(char target)&#123; for(int i = 0;i &lt; generations.size();i ++)&#123; if(generations[i].first == target) return i; &#125; return -1;//未找到替换产生式&#125; 字符串几何解释器 现在我们就一个具体实例实践： 起始字符串： {S} 产生式： S -&gt; F[^X][*%X][&amp;%X] X -&gt; F[^%D][&amp;D][/D][∗D][*%D]、F[&amp;%D][*D][∗D][/D][^%D] D -&gt; F[^X][*%FX][&amp;%X] 迭代层级： 8层 经过以上的规则和层级，我们就会得到一大串一大串的字符，这些字符都存储了植物的分形信息。由于太过冗长，我就不贴出来了。得到后的字符串还仅仅是字符串，接下来我就对这串字符串进行几何解释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100struct State&#123; glm::vec3 pos; glm::vec3 dir; float length; float radius; int level;&#125;;void LSystemTree::generateFractal()&#123; //trunks存储树干，包含了树干的起点和终点 trunks.clear(); //leafs存树树叶的位置 leafs.clear(); //curState记录当前的状态，包括位置和方向，还有长度和半径 //长度和半径用于树干的构造 curState.pos = glm::vec3(0,0,0); curState.dir = glm::vec3(0,1,0); curState.length = length; curState.level = 1; curState.radius = radius; //状态栈 std::stack&lt;State&gt;stacks; for(int i = 0;i &lt; grammar.getResult().size();i ++)&#123; //从字符串中选取一个字符串进行操作 char ch = grammar.getResult()[i]; Trunk tmp; switch(ch)&#123; //遇到字符F，则前进一段距离，获得一段树干 case 'F':&#123; tmp.start = curState.pos; curState.pos += curState.dir*(float)curState.length; tmp.end = curState.pos; tmp.radius = curState.radius; tmp.level = curState.level; trunks.push_back(tmp); break; &#125; //遇到$字符，则绕Y轴旋转dy角度，dy = 30.0f case '$':&#123; curState.dir = Geometry::RotateY(curState.dir,dy); break; &#125; //遇到%字符，绕Y轴旋转-dy角度，dy = 30.0f case '%':&#123; curState.dir = Geometry::RotateY(curState.dir,-dy); break; &#125; //遇到^字符，绕X轴旋转dx角度，dx = 35.0f case '^':&#123; curState.dir = Geometry::RotateX(curState.dir,dx); break; &#125; //遇到&amp;字符，绕X轴旋转-dx角度，dx = 35.0f case '&amp;':&#123; curState.dir = Geometry::RotateX(curState.dir,-dx); break; &#125; //遇到*字符，绕Z轴旋转dz角度，dz = 35.0f case '*':&#123; curState.dir = Geometry::RotateZ(curState.dir,dz); break; &#125; //遇到/字符，绕Z轴旋转dz角度，dz = 35.0f case '/':&#123; curState.dir = Geometry::RotateZ(curState.dir,-dz); break; &#125; //遇到[字符，将当前状态压入栈中保存，然后将当前状体中的长度和半径以一个比例 //消减，其实是进入了子枝干，长度和半径需要消减 //这里lengthFactor = 0.75，radiusFactor = 0.72。 case '[':&#123; stacks.push(curState); curState.length *= lengthFactor; curState.radius *= radiusFactor; curState.level += 1; break; &#125; //遇到]字符，将栈顶状态释放 case ']':&#123; //若当前层级是最高层，说明当前已经走到了叶子，将其记录到leafs中 if(curState.level == grammar.getLevel())&#123; Trunk tm = trunks[trunks.size()-1]; Leaf rs; rs.dir = tm.end - tm.start; rs.pos = tm.end; leafs.push_back(rs); &#125; curState = stacks.top(); stacks.pop(); break; &#125; default: break; &#125; &#125;&#125; 经过以上的几何解释过程，我们就得到了两个信息，trunks和leafs，这两个vector分别存储了树干和树叶。每个树干包含起点和终点，以及长度和半径信息。树叶中主要是位置以及方向向量。有了这些信息，我们下一步就是进行构造植物模型。 分形树的构建 在上一步中我们已经得到了树干和树叶的信息，那该怎么通过OpenGL画出来呢？最简单的就是树干直接用线，设定一定的线宽。但是这种方法太过粗糙，线宽的设定也有上限，最多只能为10，在调试阶段或许还有用。比较好的方法就是通过圆柱来表示树干，这个圆柱不需要要太过精细。但是现在我们遇到两个问题。第一，现代OpenGL太底层了，没有提供画圆柱API，这需要我们自己去弄，不难；第二，如何在空间中的任意两点之间画一个圆柱，这个可以先在原点画一个圆柱，然后求出旋转和平移矩阵，将其平移到目标位置。 根据圆的方程可以构建圆柱如下，我们在原点处向着z轴的正方向构建，所以圆柱起点为(0,0,0)，而终点为(0,0,len)，len为圆柱的长度。同时圆柱和不需要太过精细，5片矩形实际上够了。 123456789101112131415161718192021222324void CylinderMesh(float len,float radius,vector&lt;glm::vec3&gt;&amp;vertice) &#123; unsigned int slice = 6; float delta = 360.0f/(float)(slice-1.0); for(unsigned int x = 0;x &lt; slice-1;x ++)&#123; float angle = delta*x; float rc1 = radius*cos(glm::radians(angle)); float rs1 = radius*sin(glm::radians(angle)); float rc2 = radius*cos(glm::radians(angle+delta)); float rs2 = radius*sin(glm::radians(angle+delta)); glm::vec3 point1 = glm::vec3(rc1,rs1,len); glm::vec3 point2 = glm::vec3(rc1,rs1,0.0); glm::vec3 point3 = glm::vec3(rc2,rs2,len); glm::vec3 point4 = glm::vec3(rc2,rs2,0.0); vertice.push_back(point1); vertice.push_back(point2); vertice.push_back(point3); vertice.push_back(point3); vertice.push_back(point2); vertice.push_back(point4); &#125;&#125; 现在我们需要求出旋转平移矩阵，将原点处的圆柱平移到目标位置。废话少说， 12345678910111213141516171819glm::mat4 GetTranMat(glm::vec3 start,glm::vec3 end,glm::mat4 &amp;nmats)&#123; glm::mat4 trans(1.0f); //求出平移矩阵，这个简单，就是目标位置的起始点 trans = glm::translate(trans,start); glm::vec3 z = glm::vec3(0,0,-1); glm::vec3 p = start - end; //叉乘获取一个垂直于z轴和目标向量的向量，实际上就是旋转轴！ glm::vec3 t = glm::cross(z,p); float Pi = 3.1415926; //点乘，然后单位化，然后通过acos获取他们的夹角！ float angle = acos(glm::dot(z,p)/glm::length(p)); glm::mat4 rotas(1.0f); //根据旋转轴旋转angle角度 rotas = glm::rotate(rotas,angle,t); nmats = rotas; //顺序是先旋转后平移 return trans*rotas;&#125; 通过以上的计算就求出了旋转平移矩阵，那么多的树干，只需要求一个圆柱的网格顶点，然后计算出相应的缩放矩阵和旋转平移矩阵就能获取目标网格顶点了！ 实现效果演示 加上纹理映射和光照阴影，效果如下： 其中的粒子效果是前介绍过的了。比较大颗的树是迭代了7层，小颗的则是迭代了4层。 参考资料：《基于L-系统的虚拟植物形态建模方法研究》李纪永 参考博客：http://blog.csdn.net/Mahabharata_/article/details/66967837?locationNum=10&amp;fps=1","categories":[{"name":"Computer Graphics","slug":"Computer-Graphics","permalink":"http://yoursite.com/categories/Computer-Graphics/"}],"tags":[{"name":"Computer Graphic","slug":"Computer-Graphic","permalink":"http://yoursite.com/tags/Computer-Graphic/"},{"name":"L-System","slug":"L-System","permalink":"http://yoursite.com/tags/L-System/"},{"name":"Tree modeling","slug":"Tree-modeling","permalink":"http://yoursite.com/tags/Tree-modeling/"}]},{"title":"粒子群优化算法、差分进化算法","slug":"PSO","date":"2019-04-25T12:39:31.550Z","updated":"2019-04-27T08:51:30.748Z","comments":true,"path":"2019/04/25/PSO/","link":"","permalink":"http://yoursite.com/2019/04/25/PSO/","excerpt":"本次带来粒子群优化算法和差分进化算法，解决单目标连续优化问题。算法的benchmark全部来自http://www.ntu.edu.sg/home/epnsugan/index_files/CEC2018/CEC2018.htm 。这上面有30个测试函数，每个函数基本上有2维、10维、20维、30维、50维、100维的版本，提供了一个c语言的function文件，包含了全部benchmark函数，测试可直接调用。","text":"本次带来粒子群优化算法和差分进化算法，解决单目标连续优化问题。算法的benchmark全部来自http://www.ntu.edu.sg/home/epnsugan/index_files/CEC2018/CEC2018.htm 。这上面有30个测试函数，每个函数基本上有2维、10维、20维、30维、50维、100维的版本，提供了一个c语言的function文件，包含了全部benchmark函数，测试可直接调用。 前言 算法理论 算法实践 可视化 前言 本次带来粒子群优化算法和差分进化算法，解决单目标连续优化问题。算法的benchmark全部来自http://www.ntu.edu.sg/home/epnsugan/index_files/CEC2018/CEC2018.htm。这上面有30个测试函数，每个函数基本上有2维、10维、20维、30维、50维、100维的版本，提供了一个c语言的function文件，包含了全部benchmark函数，测试可直接调用。这也是本人的一项课程的课程作业，如有错误，欢迎指出，共同学习！谢谢。 整个项目源码可在github下载: https://github.com/ZeusYang/AILearning/tree/master/SingleObjectiveOpt 算法理论 粒子群优化算法 简介 粒子群优化算法( Particle Swarm Optimization，PSO）是进化计算的一个分支，是一种模拟自然界的生物活动的随机搜索算法。PSO模拟了自然界鸟群捕食和鱼群捕食的过程。通过群体中的协作寻找到问题的全局最优解。它是1995年由美国学者Eberhart和Kennedy提出的，现在已经广泛应用于各种工程领域的优化问题之中。 PSO从鸟群觅食模型中得到启示并用于解决优化问题。PSO中，每个优化问题的解都是搜索空间中的一只鸟。我们称之为“粒子”。所有的粒子都有一个由被优化的函数决定的适应值(fitness value)，每个粒子还有一个速度决定他们飞翔的方向和距离。然后粒子们就追随当前的最优粒子在解空间中搜索。 算法流程及伪代码 PSO 初始化为一群随机粒子(随机解)。然后通过迭代找到最优解。在每一次迭代中，粒子通过跟踪两个&quot;极值&quot;来更新自己。第一个就是粒子本身所找到的最优解，这个解叫做个体极值pBest。另一个极值是整个种群目前找到的最优解，这个极值是全局极值gBest。另外也可以不用整个种群而只是用其中一部分作为粒子的邻居，那么在所有邻居中的极值就是局部极值。 更新公式及其参数说明 每个粒子个体的速度和位置更新的公式如下： v[]和present[]为个体的速度数组和位置数组，每个粒子都有它相应的速度和位置，速度的维度和变量的维度保持一致。w为惯性权重，它控制着前一速度对当前速度的影响，用于平衡算法的探索和开发能力。c1和c2是加速系数，它代表了粒子向自身极值pBest和全局极值gBest推进的加速权值。除了这些参数之外，还有种群规模N，也就是用多少个粒子实例去优化，它影响着算法的搜索能力和计算量。结束条件可以用一定的迭代次数替换，达到一定的迭代次数之后算法就会收敛，不再推进。 12v[] = w * v[] + c1 * rand() * (pbest[] - present[]) + c2 * rand() * (gbest[] - present[])present[] = present[] + v[] PSO对种群规模要求不高，一般取20-40就可以达到很好的求解效果，不过对于比较难的问题或者特定类别的问题，粒子数可以取到100或200。 惯性权重我这里取0.5，代表前一速度对当前速度有一半的贡献。 c1和c2通常都等于2.0，代表着对两个引导方向的同等重视 。 终止条件决定算法运行的结束，由具体的应用和问题本身确定。有几种做法： (1)将最大循环数设定为500，1000，5000，或者最大的函数评估次数，等等; (2)也可以使用算法求解得到一个可接受的解作为终止条件; (3)或者是当算法在很长一段迭代中没有得到任何改善，则可以终止算法. 差分进化算法 简介 差分进化算法（DE）是Rainer Storn 和Kenneth Price在1996 年为求解切比雪夫多项式而提出。DE是一种随机的并行直接搜索算法,它可对非线性不可微连续空间函数进行最小化,以其易用性、稳健性和强大的全局寻优能力在多个领域取得成功。 DE也是基于群体的启发式搜索算法，群中的每个个体对应一个解向量。差分进化算法的进化流程则与遗传算法非常类似，都包括变异、杂交和选择操作，但这些操作的具体定义与遗传算法有所不同。 算法流程及伪码 DE算法通过采用浮点矢量进行编码生成种群个体。 在DE算法寻优的过程中， 首先，从父代个体间选择两个个体进行向量做差生成差分矢量； 其次，选择另外一个个体与差分矢量求和生成实验个体； 然后，对父代个体与相应的实验个体进行交叉操作，生成新的子代个体； 最后在父代个体和子代个体之间进行选择操作，将符合要求的个体保存到下一代群体中去。 具体流程如下： (1)、确定差分进化算法控制参数，确定适应度函数。差分进化算法控制参数包括：种群大小NP、缩放因子F与杂交概率CR。 **(2)、**随机产生初始种群。 **(3)、**对初始种群进行评价，即计算初始种群中每个个体的适应度值。 **(4)、**判断是否达到终止条件或进化代数达到最大。若是，则终止进化，将得到最佳个体作为最优解输出；若否，继续。 **(5)、**进行变异和交叉操作，得到中间种群。 **(6)、**在原种群和中间种群中选择个体，得到新一代种群。 **(7)、**进化代数g=g+1，转步骤(4) 更新公式及其参数说明 差异演化算法主要涉及群体规模M 、缩放因子F以及交叉概率CR三个参数的设定。 M：一般介于5×n 与10×n 之间, 但不能少于4, 否则无法进行变异操作，n是维度; F ：一般在[ 0, 2 ]之间选择, 通常取0. 5; CR：一般在[ 0, 1 ]之间选择, 比较好的选择应在0. 3 左右, CR 大些收敛速度会加快, 但易发生早熟现象。 算法实践 粒子群优化算法 随机初始化每个粒子 123456789101112131415srand((unsigned)time(NULL)); int population = static_cast&lt;int&gt;(getParameters(tr(\"population\")));//种群大小 int dimension = static_cast&lt;int&gt;(getParameters(tr(\"dimension\")));//维度 int generation = static_cast&lt;int&gt;(getParameters(tr(\"generation\")));//迭代次数 double lowbounding = getParameters(tr(\"lowbounding\")); double upbounding = getParameters(tr(\"upbounding\")); group.clear(); group.resize(generation,std::vector&lt;std::vector&lt;double&gt; &gt;(population, std::vector&lt;double&gt;(dimension,0.0))); for (int i = 0; i &lt; population; i++) &#123; for (int j = 0; j &lt; dimension; j++) &#123; group[0][i][j] = lowbounding + (double)(rand() / (double)RAND_MAX) * (upbounding - lowbounding); &#125; &#125; 更新每个粒子的速度和位置 12345678910111213141516171819202122232425262728293031void PSOAlgorithm::update(int curGeneration)&#123;//更新速度和位置 int dimension = static_cast&lt;int&gt;(getParameters(tr(\"dimension\"))); int population = static_cast&lt;int&gt;(getParameters(tr(\"population\"))); double w = getParameters(tr(\"w\"));//惯性权重 double c1 = getParameters(tr(\"c1\"));//加速系数 double c2 = getParameters(tr(\"c2\"));//加速系数 double upbounding = getParameters(tr(\"upbounding\"));//上界 double lowbounding = getParameters(tr(\"lowbounding\"));//下界 for(auto i = 0;i &lt; population;++i)&#123; for(auto j = 0;j &lt; dimension;++j)&#123; double pre = velocity[i][j]; //更新速度 velocity[i][j] = w*pre + c1*(double)(rand()/(double)RAND_MAX)* (pBest[i][j] - group[curGeneration - 1][i][j]) + c2*(double)(rand()/(double)RAND_MAX)* (gBest[j] - group[curGeneration - 1][i][j]); if(velocity[i][j] &gt; 200)velocity[i][j] = 200; //位置更新 group[curGeneration][i][j] = group[curGeneration-1][i][j] + velocity[i][j]; //边界处理 if(group[curGeneration][i][j] &gt; upbounding) group[curGeneration][i][j] = upbounding; if(group[curGeneration][i][j] &lt; lowbounding) group[curGeneration][i][j] = lowbounding; &#125; &#125;&#125; 更新每个粒子的历史最优和全局最优、 12345678910111213141516void PSOAlgorithm::curAndgloBest(int curGeneration)&#123;//计算当前最优解和全局最优解 int population = static_cast&lt;int&gt;(getParameters(tr(\"population\"))); int dimension = static_cast&lt;int&gt;(getParameters(tr(\"dimension\"))); int func_num = static_cast&lt;int&gt;(getParameters(tr(\"function\")));//函数编号 for (auto i = 0; i &lt; population; ++i) &#123; double value = functions(group[curGeneration][i], func_num, dimension); if (value &lt; functions(pBest[i], func_num, dimension)) pBest[i] = group[curGeneration][i]; if (functions(pBest[i], func_num, dimension) &lt; functions(gBest, func_num, dimension))&#123; gBest = pBest[i]; bestValue.first = i; bestValue.second = functions(pBest[i], func_num, dimension); &#125; &#125;&#125; 算法核心 12345678910111213void PSOAlgorithm::process()&#123; curAndgloBest(0);//计算初始代最优解 int generation = static_cast&lt;int&gt;(getParameters(tr(\"generation\")));//迭代次数 for (auto current = 1; current &lt; generation; ++current) &#123; update(current); curAndgloBest(current); calcCurrentValue(pBest); if(generation &lt;= 100 || (generation &gt; 100 &amp;&amp; generation % 2 == 0)) emit frameUpdate(avgValue,currentValue,minY,maxY,current,generation,bestValue); &#125; emit processFinished(getResult(gBest));&#125; 粒子群优化算法 随机产生初始种群 123456789101112131415srand((unsigned)time(NULL)); int population = static_cast&lt;int&gt;(getParameters(tr(\"population\")));//种群大小 int dimension = static_cast&lt;int&gt;(getParameters(tr(\"dimension\")));//维度 int generation = static_cast&lt;int&gt;(getParameters(tr(\"generation\")));//迭代次数 double lowbounding = getParameters(tr(\"lowbounding\")); double upbounding = getParameters(tr(\"upbounding\")); group.clear(); group.resize(generation,std::vector&lt;std::vector&lt;double&gt; &gt;(population, std::vector&lt;double&gt;(dimension,0.0))); for (int i = 0; i &lt; population; i++) &#123; for (int j = 0; j &lt; dimension; j++) &#123; group[0][i][j] = lowbounding + (double)(rand() / (double)RAND_MAX) * (upbounding - lowbounding); &#125; &#125; 核心算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071void DEAlgorithm::process()&#123; int population = static_cast&lt;int&gt;(getParameters(tr(\"population\")));//种群大小 int dimension = static_cast&lt;int&gt;(getParameters(tr(\"dimension\")));//维度 int generation = static_cast&lt;int&gt;(getParameters(tr(\"generation\")));//迭代次数 double lowbounding = getParameters(tr(\"lowbounding\")); double upbounding = getParameters(tr(\"upbounding\")); double DE_F = getParameters(tr(\"F\"));//缩放因子 double DE_CR = getParameters(tr(\"CR\"));//交叉概率 int func_num = static_cast&lt;int&gt;(getParameters(tr(\"function\")));//函数编号 double bestSolution = 100000000;//目前全局最优解 //开始迭代 for(auto t=1;t&lt;generation;t++)&#123; //变异 for(int i=0;i&lt;population;i++)&#123; //随机选三个向量 std::vector&lt;bool&gt; selected(population,false); selected[i] = true; int pick[3]; for(auto k=0;k&lt;3;k++)&#123; pick[k] = rand() % population; while(selected[pick[k]])pick[k] = rand() % population; selected[pick[k]] = true; &#125; for(auto j=0;j&lt;dimension;j++)&#123; //变异操作公式 group[t][i][j] = group[t-1][pick[0]][j] + DE_F * (group[t-1][pick[1]][j] - group[t-1][pick[2]][j]); //边界处理 if(group[t][i][j]&lt;lowbounding) group[t][i][j] = lowbounding; else if(group[t][i][j]&gt;upbounding) group[t][i][j] = upbounding; &#125; &#125; //交叉 for(auto i=0;i&lt;population;i++)&#123; for(auto j=0;j&lt;dimension;j++)&#123; if(((rand() % 100) / 100.0) &lt;= DE_CR || j == (rand() % dimension)) group[t][i][j] = group[t][i][j]; else group[t][i][j] = group[t-1][i][j]; &#125; &#125; //选择替换，贪心策略 for(auto i=0;i&lt;population;i++)&#123; if(functions(group[t][i],func_num,dimension) &lt;= functions(group[t-1][i],func_num,dimension))&#123; group[t][i] = group[t][i]; bestSolution = bestSolution &lt; functions(group[t][i],func_num,dimension) ? bestSolution : functions(group[t][i],func_num,dimension); if(bestSolution &lt; functions(group[t][i],func_num,dimension))&#123; bestValue.first = i; bestValue.second = bestSolution; solution = group[t][i]; &#125; &#125; else&#123; group[t][i] = group[t-1][i]; &#125; &#125; //计算当前种群的全部值 calcCurrentValue(group[t]); if(generation &gt; 300 &amp;&amp; generation % 2 == 0)&#123; emit frameUpdate(avgValue,currentValue,minY,maxY,t,generation,bestValue); &#125; else&#123; emit frameUpdate(avgValue,currentValue,minY,maxY,t,generation,bestValue); &#125; &#125; emit processFinished(getResult(solution));&#125; 以上只是算法的核心部分，更多的细节请看源码。 可视化 用Qt做了个可视化，可以调节参数，显示了种群个体的每个个体的适应值以及整个种群的适应值收敛曲线。 粒子群算法： 可以看到最后粒子都收敛了，在同一条直线上： 差分进化算法： 总的来说，差分进化算法略占优势，收敛的速度也比较快，粒子群算法比较没那么稳定. 整个项目源码可在github下载：https://github.com/ZeusYang/AILearning/tree/master/SingleObjectiveOpt","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"PSO","slug":"PSO","permalink":"http://yoursite.com/tags/PSO/"},{"name":"DE","slug":"DE","permalink":"http://yoursite.com/tags/DE/"},{"name":"AI","slug":"AI","permalink":"http://yoursite.com/tags/AI/"}]},{"title":"迷宫生成、寻路","slug":"maze","date":"2019-04-25T12:34:35.749Z","updated":"2019-04-27T08:51:25.006Z","comments":true,"path":"2019/04/25/maze/","link":"","permalink":"http://yoursite.com/2019/04/25/maze/","excerpt":"本次带来迷宫相关的算法，迷宫的算法涉及到不少经典的图论算法，在游戏中NPC这些算法被大量的运用，深入了解和学习这些算法是为开发游戏打下坚实的基础。除了纯算法以外，我还借用了OpenGL将这些算法的演算过程可视化出来，借用这些动画演算，可加深对算法的理解，枯燥的算法一下子有趣了起来呢！","text":"本次带来迷宫相关的算法，迷宫的算法涉及到不少经典的图论算法，在游戏中NPC这些算法被大量的运用，深入了解和学习这些算法是为开发游戏打下坚实的基础。除了纯算法以外，我还借用了OpenGL将这些算法的演算过程可视化出来，借用这些动画演算，可加深对算法的理解，枯燥的算法一下子有趣了起来呢！ 前言 数据结构准备 迷宫生成算法 迷宫寻路算法 前言 本次带来迷宫相关的算法，迷宫的算法涉及到不少经典的图论算法，在游戏中NPC这些算法被大量的运用，深入了解和学习这些算法是为开发游戏打下坚实的基础。除了纯算法以外，我还借用了OpenGL将这些算法的演算过程可视化出来，借用这些动画演算，可加深对算法的理解，枯燥的算法一下子有趣了起来！ 本工程全部源码及可执行程序可在github下载：https://github.com/ZeusYang/Breakout。其中的Maze目录就是本次迷宫的项目文件了，可执行程序exe在Maze/x64/Release下，编译的64位程序，可直接运行。 程序操作说明：1、2、3数字键是生成迷宫指令，分别是深度优先、随机Prim、四叉树分割迷宫生成算法，A/a、B/b、C/c字符键是迷宫寻路指令，分别是深度优先、广度优先、A星算法迷宫寻路。按下之后再按Enter即自动开始对应的操作。注意先生成迷宫再进行寻路，否则没有意义，因为一开始都是封闭墙。 数据结构准备 迷宫本质上是一个二维平面，我们用一个二维数组表示，然后数组中的每个元素都是一个迷宫单元。定义迷宫单元[x,y]，每个迷宫单元有上、下、左、右四面墙，初始时四面墙都存在。为了方面，我们定义下面的结构体： 12345678910111213141516enum Neighbor &#123; LEFT = 0, UP = 1, RIGHT = 2, DOWN = 3 &#125;;struct Cell &#123;//迷宫单元 int neighbors[4];//四个方向的邻居 int visited;//记录是否访问过了 //以下用于寻路算法 glm::ivec2 prev;//记录前驱 //用于A星算法的open表、closed表 bool inOpen, inClosed; //启发式函数fn = gn + hn //其中gn为起点到n的实际距离，hn为n到终点的哈密顿 int gn, hn; Cell() :visited(0),inOpen(false),inClosed(false) &#123; neighbors[LEFT] = neighbors[UP] = neighbors[RIGHT] = neighbors[DOWN] = 0; &#125;&#125;; 然后声明一个类–MazeAlgorithm，在这里我们将要实现六个算法，每个算法的数据结构如下： 12345678910111213141516const int row, col;//迷宫单元的行、列数static std::vector&lt;std::vector&lt;Cell&gt;&gt; cells;//迷宫单元矩阵//迷宫生成算法一数据结构:深度优先的栈std::stack&lt;glm::ivec2&gt; record;//迷宫生成算法二数据结构：随机Prim算法的链表std::list&lt;glm::ivec2&gt; prim;//迷宫生成算法三数据结构：四叉树广度优先的队列std::queue&lt;std::pair&lt;glm::ivec2, glm::ivec2&gt;&gt; recursive;//迷宫寻路算法一数据结构：深度优先的栈std::stack&lt;glm::ivec2&gt; path_dfs;//迷宫寻路算法一数据结构：广度优先的队列std::queue&lt;glm::ivec2&gt; path_bfs;//迷宫寻路算法一数据结构：A星算法的优先队列std::priority_queue&lt;Node,std::vector&lt;Node&gt;,Compare&gt; path_astar; 以上仅仅是一部分，具体的细节请看源码。 迷宫生成算法 这里我实现的迷宫生成算法有三个，分别是：深度优先、随机Prim、四叉树分割。 深度优先 就是表面上的意思，深度优先的方法生成迷宫，当然跟普通的深度优先搜索有点差别，它加入了随机性，先看伪代码： 12345678910将起点作为当前迷宫单元并标记为已访问 while 还存在未标记的迷宫单元 if 当前迷宫单元有未被访问过的的相邻的迷宫单元 then 随机选择一个未访问的相邻迷宫单元 将当前迷宫单元入栈 移除当前迷宫单元与相邻迷宫单元的墙 标记相邻迷宫单元并用它作为当前迷宫单元 else if 栈不空 栈顶的迷宫单元出栈 令其成为当前迷宫单元 算法的主要思想就是，每次在当前迷宫单元中寻找与其相邻的未访问过的迷宫单元，然后选择这些邻居其中的一个访问下去，直到所有的单元都被访问到。就是从起点开始随机走，走不通了就返回上一步，从下一个能走的地方再开始随机走。 那么如何实现呢，我们用一个栈来进行深度优先遍历，栈的元素是数组的下标。下面代码中的frame纯属用于演示动画，可去掉直接得结果，还有栈的初始化请在源代码中Generation_Init()函数查看。 123456789101112131415161718192021222324252627282930313233343536std::stack&lt;glm::ivec2&gt; record;...bool MazeAlgorithm::Generator_Dfs() &#123; frame = 5;//用于演示动画 while (!record.empty() &amp;&amp; frame--) &#123;//当队列或者frame不减到0时 cells[cur.x][cur.y].visited = 1;//标记当前的位置为访问过的了 bool hasNeigh = false;//是否有邻居未访问 std::vector&lt;std::pair&lt;glm::ivec2,int&gt;&gt; tmp; //记录未访问的邻居, tmp.second代表它是哪个邻居 glm::ivec2 loc; //寻找是否存在未访问的邻居 for (auto x = 0; x &lt; 4; ++x) &#123; loc = glm::ivec2(cur.x + to[x][0], cur.y + to[x][1]); if (CouldMove(loc) &amp;&amp; !cells[loc.x][loc.y].visited) &#123;//有未访问的邻居 tmp.push_back(&#123; loc,x &#125;);//加入tmp中，然后随机选择一个 hasNeigh = true; &#125; &#125; if (hasNeigh) &#123;//从未访问的邻居中随机选择一个 int got = rand() % tmp.size(); record.push(cur);//当前迷宫单元入栈 //拆掉cur和tmp[got]之间的墙 cells[cur.x][cur.y].neighbors[tmp[got].second] = 1; cells[tmp[got].first.x][tmp[got].first.y].neighbors[(tmp[got].second + 2) % 4] = 1; //令当前标记变为该邻居 cur = tmp[got].first; &#125; else &#123;//没找到一个未被访问的邻居，是时候回溯了 cur = record.top(); record.pop(); &#125; &#125; //栈尾空代表已经结束了 if (record.empty())return true; else return false;&#125; 然后用OpenGL做出的动画如下： 可以看到就是沿着一条路一直走下去，没路再回溯。这就是深度优先。 随机Prim 与深度优先不同，随机Prim算法是随机地在迷宫单元列表中随机选取一个迷宫单元，新加入列表和之前加入列表的迷宫单元有同等的概略被选中。**对于选中的迷宫单元，标记为被访问状态，并把它从列表中删除，然后依旧查看它的四面邻居的情况，从所有被访问过的邻居中随机选一个，打通这个邻居和当前迷宫单元之前的墙，对所有未被访问过的邻居我们将其放入列表中。**注意到我们有删除操作，但是又要求随机访问。这里我采用了链表，我想了下可以用另一种方法替代，但是对于规模不是非常巨大的来说是几乎没什么差别。废话不多说，伪代码如下： 1234567891011list = 迷宫单元的列表，这里是索引set = 暂存一个迷宫单元的被访问过的邻居将起点加入list中while list不空 从list中随机选一个元素cur 将cur从list中删除，标记cur的迷宫单元为被访问状态 对于cur的四个邻居 该邻居被访问过，加入set中 否则加入list中 if set非空 从中随机选一个，打通cur和被选中的迷宫单元之间的墙 随机Prim的等概率性使得所有的迷宫单元优先级几乎等同，因此其分支更多，生成的迷宫更复杂，难度更大。 1234567891011121314151617181920212223242526272829303132333435363738bool MazeAlgorithm::Generator_Prim() &#123; frame = 5;//frame同上 //prim为list while (!prim.empty() &amp;&amp; frame--) &#123; //随机从list中选一个 int choice = rand() % prim.size(); auto it = prim.begin(); std::advance(it, (choice == 0) ? 0 : choice); cur = *it; //标记为已访问过，然后从List删除 cells[cur.x][cur.y].visited = 1; prim.erase(it); //查看邻居的情况 std::vector&lt;std::pair&lt;glm::ivec2, int&gt;&gt; tmp; //记录未访问的邻居 //四个邻居 for (auto x = 0; x &lt; 4; ++x) &#123; glm::ivec2 loc = glm::ivec2(cur.x + to[x][0], cur.y + to[x][1]); if (CouldMove(loc)) &#123;//边界检查 //被访问过，加入tmp中，接下来要随机抽取这些 if (cells[loc.x][loc.y].visited == 1)tmp.push_back(std::pair&lt;glm::ivec2, int&gt;(loc, x)); else if (cells[loc.x][loc.y].visited == 0) &#123; //未被访问过，加入list中，并标记为2，代表他们在list中 prim.push_back(loc); cells[loc.x][loc.y].visited = 2; &#125; &#125; &#125; //有未被访问过的邻居 if (!tmp.empty()) &#123; //从中随机选一个，打通他们之间的墙 int got = rand() % tmp.size(); cells[cur.x][cur.y].neighbors[tmp[got].second] = 1; cells[tmp[got].first.x][tmp[got].first.y].neighbors[(tmp[got].second + 2) % 4] = 1; &#125; &#125; if (prim.empty())return true; else return false;&#125; 可以看到这种方法有点广度优先的影子，这是因为迷宫单元之间的优先级等同。此算法生成迷宫难度最大。 四叉树分割 在有些地方那个也叫递归分割，但实际上可以不用递归，它的本质上就是一颗四叉树。每一次在当前的迷宫范围内用十字分割成四个子空间，在十字四个方向中随机三个墙上挖洞，随机对每个子空间进行同样的操作，知道子空间不可再分。可以看到原理非常简单，但生成迷宫的效率却是最高的，然后此法生成的迷宫教为简单，直路较多。我们直接对迷宫单元数组进行操作，采用广度优先遍历四叉树的方法，每次划分四个子空间。伪代码如下： 12345678910111213141516queue = &#123;(r1,r2,c1,c2)|r1为最小行，r2为最大行，c1和c2同理，换成列&#125;将迷宫矩阵范围(0,rows,0,cols)放入queue中while queue不空 从queue取队头元素，出队 if r1 &lt; r2 且 c1 &lt; c2 then 在r1和r2之间选取随机数r 在c1和c2之间选取随机数c 用(r,c)对该范围进行分割 在(r,c)的四个方向上随机选三个，打通他们的墙 然后用(r,c)十字分割当前的范围，将四个子空间入队 else if r1 &lt; r2 此时子空间变成了一条竖线，我们只在行方向上进行操作和分割 然后两个子空间加入队列 else if c1 &lt; c2 此时子空间变成了一条横线，我们只在列方向上进行操作和分割 然后两个子空间加入队列 利用递归实现此算法非常简洁明了，但是我为了能够追踪演算过程采用了bfs方法实现，比较繁琐，如下，更多细节请查看源代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970bool MazeAlgorithm::Generator_Recursive() &#123; frame = 10; //recursive是queue，其中的元素为pair&lt;glm::ivec2,glm::ivec2&gt; //first为行范围，second为列范围 while (!recursive.empty() &amp;&amp; frame--) &#123; std::pair&lt;glm::ivec2, glm::ivec2&gt; head = recursive.front(); recursive.pop(); //head.first == head.second情况下变成了一条线，需要特殊处理 if (head.first.x &lt; head.first.y &amp;&amp; head.second.x &lt; head.second.y) &#123; glm::ivec2 center; //在[head.first,head.first)之间选择一个坐标，根据这个坐标进行分割 center.x = head.first.x + rand() % (head.first.y - head.first.x); center.y = head.second.x + rand() % (head.second.y - head.second.x); int subRow[2], subCol[2];//存储四个方向上的随机数 //在center四个方向上随机选取 subRow[0] = head.first.x + rand() % (center.x - head.first.x + 1); subRow[1] = center.x + 1 + rand() % (head.first.y - center.x); subCol[0] = head.second.x + rand() % (center.y - head.second.x + 1); subCol[1] = center.y + 1 + rand() % (head.second.y - center.y); //获取四个方向上的随机迷宫单元 glm::ivec2 meta[4]; meta[LEFT] = glm::ivec2(center.x, subCol[0]); meta[UP] = glm::ivec2(subRow[0], center.y); meta[RIGHT] = glm::ivec2(center.x, subCol[1]); meta[DOWN] = glm::ivec2(subRow[1], center.y); int notOpen = rand() % 4;//随机选一个迷宫单元不打通，剩下的三个都打通 for (auto x = 0; x &lt; 4; ++x) &#123; if (x != notOpen) &#123;//在这三个迷宫单元挖洞 //左、右打通它的下面，上、下打通它的右面 glm::ivec2 near = (x % 2 == 0) ? glm::ivec2(meta[x].x + 1, meta[x].y) : glm::ivec2(meta[x].x, meta[x].y + 1); //哪面墙 int which = (x % 2 == 0) ? DOWN : RIGHT; //打通meta[x]和near之间的墙 cells[meta[x].x][meta[x].y].neighbors[which] = 1; cells[near.x][near.y].neighbors[(which + 2) % 4] = 1; &#125; &#125; //然后再对当前的四个子空间进行同样处理，入队 recursive.push(std::pair&lt;glm::ivec2, glm::ivec2&gt;(&#123; glm::ivec2(head.first.x,center.x), glm::ivec2(head.second.x,center.y) &#125;)); recursive.push(std::pair&lt;glm::ivec2, glm::ivec2&gt;(&#123; glm::ivec2(head.first.x,center.x), glm::ivec2(center.y + 1,head.second.y) &#125;)); recursive.push(std::pair&lt;glm::ivec2, glm::ivec2&gt;(&#123; glm::ivec2(center.x + 1,head.first.y), glm::ivec2(head.second.x,center.y) &#125;)); recursive.push(std::pair&lt;glm::ivec2, glm::ivec2&gt;(&#123; glm::ivec2(center.x + 1,head.first.y), glm::ivec2(center.y + 1,head.second.y) &#125;)); &#125; else if (head.first.x &lt; head.first.y) &#123;//子空间变成了一条竖线，其他同上 int rm = head.first.x + rand() % (head.first.y - head.first.x); cells[rm][head.second.x].neighbors[DOWN] = 1; cells[rm + 1][head.second.x].neighbors[UP] = 1; recursive.push(std::pair&lt;glm::ivec2, glm::ivec2&gt;(&#123; glm::ivec2(head.first.x,rm), glm::ivec2(head.second.x,head.second.x) &#125;)); recursive.push(std::pair&lt;glm::ivec2, glm::ivec2&gt;(&#123; glm::ivec2(rm + 1,head.first.y), glm::ivec2(head.second.x,head.second.x) &#125;)); &#125; else if (head.second.x &lt; head.second.y) &#123;//子空间变成了一条横线，其他同上 int cm = head.second.x + rand() % (head.second.y - head.second.x); cells[head.first.x][cm].neighbors[RIGHT] = 1; cells[head.first.x][cm+1].neighbors[LEFT] = 1; recursive.push(std::pair&lt;glm::ivec2, glm::ivec2&gt;(&#123; glm::ivec2(head.first.x,head.first.x), glm::ivec2(head.second.x,cm) &#125;)); recursive.push(std::pair&lt;glm::ivec2, glm::ivec2&gt;(&#123; glm::ivec2(head.first.x,head.first.x), glm::ivec2(cm + 1,head.second.y) &#125;)); &#125; &#125; if (recursive.empty()) return true; else return false;&#125; 此方法速度很快，可以看到生成的迷宫较为简单，直路多，适合fps等类的游戏。 迷宫寻路算法 这里我实现的迷宫寻路算法有三个，分别是：深度优先搜索、广度优先搜索、A星搜索算法。 ####深度优先搜索 基本的图算法遍历操作，没什么特别的，深度优先搜索出来的路径不一定是最短的，它遵循的原则是找到就好。 12345678910111213141516171819202122232425262728bool MazeAlgorithm::Pathfinding_Dfs() &#123; //深度优先遍历寻路 frame = 10; while (!path_dfs.empty() &amp;&amp; frame--) &#123; glm::ivec2 head = path_dfs.top(); path_dfs.pop(); //寻找邻居 for (auto x = 0; x &lt; 4; ++x) &#123; glm::ivec2 loc(head.x + to[x][0], head.y + to[x][1]); if (CouldMove(loc) &amp;&amp; !cells[loc.x][loc.y].visited //未访问 &amp;&amp; cells[head.x][head.y].neighbors[x] == 1) &#123;//且无墙隔着 cells[loc.x][loc.y].prev = head;//记录前驱，然后要倒推路径 path_dfs.push(loc); cells[loc.x][loc.y].visited = 1; //找到终点了 if (loc == glm::ivec2(row - 1, col - 1)) &#123; //清空dfs栈，停止搜索 while (!path_dfs.empty())path_dfs.pop(); &#125; &#125; &#125; &#125; if (path_dfs.empty()) &#123;//从终点倒退路径到起点 GetSolution(); return true; &#125; else return false;&#125; 广度优先搜索 也是基本的图算法，它像病毒爆发一样向着终点蔓延，广度优先搜索得到的路径是最短的，它遵循的原则是一起找，谁先找到就谁是答案。 12345678910111213141516171819202122232425262728bool MazeAlgorithm::Pathfinding_Bfs() &#123; //广度优先遍历寻路-&gt;最短路径 frame = 10; while (!path_bfs.empty() &amp;&amp; frame--) &#123; glm::ivec2 head = path_bfs.front(); path_bfs.pop(); //寻找邻居 for (auto x = 0; x &lt; 4; ++x) &#123; glm::ivec2 loc(head.x + to[x][0], head.y + to[x][1]); if (CouldMove(loc) &amp;&amp; !cells[loc.x][loc.y].visited //未访问 &amp;&amp; cells[head.x][head.y].neighbors[x] == 1) &#123;//且无墙隔着 cells[loc.x][loc.y].prev = head;//记录前驱，然后要倒推路径 path_bfs.push(loc); cells[loc.x][loc.y].visited = 1; //找到终点了 if (loc == glm::ivec2(row - 1, col - 1)) &#123; //清空dfs栈，停止搜索 while (!path_bfs.empty())path_bfs.pop(); &#125; &#125; &#125; &#125; if (path_bfs.empty()) &#123;//从终点倒退路径到起点 GetSolution(); return true; &#125; else return false;&#125; 广度优先遍历像病毒蔓延一样。 A星搜索算法 A星搜索算法是比较经典的寻路算法了，我在前面的博文中有一篇关于A星算法，这里不再赘述和。我采用的启发式函数是fn = gn + hn，其中gn为起点到n的实际距离，hn为n到终点的哈密顿距离，采用优先队列实现，更多细节请看源代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344bool MazeAlgorithm::Pathfinding_Astar() &#123; frame = 10; while (!path_astar.empty() &amp;&amp; frame--) &#123; Node head = path_astar.top(); path_astar.pop(); //标记为放入closed表 cells[head.index.x][head.index.y].inOpen = false; cells[head.index.x][head.index.y].inClosed = true; cells[head.index.x][head.index.y].visited = 1; ////找到终点了 if (head.index == glm::ivec2(row - 1, col - 1)) &#123; //清空queue，停止搜索 while (!path_astar.empty())path_astar.pop(); break; &#125; for (auto x = 0; x &lt; 4; ++x) &#123;//查看邻居 glm::ivec2 loc(head.index.x + to[x][0], head.index.y + to[x][1]); if (CouldMove(loc) &amp;&amp; cells[head.index.x][head.index.y].neighbors[x] == 1) &#123;//无墙隔着 if (cells[loc.x][loc.y].inClosed)continue;//已在closed表中，不管它 if (!cells[loc.x][loc.y].inOpen) &#123;//不在open表中，加入open表 path_astar.push(Node(loc.x, loc.y)); cells[loc.x][loc.y].inOpen = true; cells[loc.x][loc.y].prev = head.index; cells[loc.x][loc.y].gn = cells[head.index.x][head.index.y].gn + 1; cells[loc.x][loc.y].hn = DirectLen(loc, glm::ivec2(row - 1, col - 1)); &#125; else &#123;//已在open表中，我们进行比较，然后修改前驱 int orig = cells[loc.x][loc.y].gn + cells[loc.x][loc.y].hn; int nows = cells[head.index.x][head.index.y].gn + cells[loc.x][loc.y].hn + 1; if (nows &lt; orig) &#123; cells[loc.x][loc.y].prev = head.index; cells[loc.x][loc.y].gn = cells[head.index.x][head.index.y].gn + 1; cells[loc.x][loc.y].hn = cells[loc.x][loc.y].hn; &#125; &#125; &#125; &#125; &#125; if (path_astar.empty()) &#123;//从终点倒退路径到起点 GetSolution(); return true; &#125; else return false;&#125; A星算法围绕启发式函数进行蔓延。 本工程全部源码及可执行程序可在github下载：https://github.com/ZeusYang/Breakout。其中的Maze目录就是本次迷宫的项目文件了，可执行程序exe在Maze/x64/Release下，编译的64位程序，可直接运行。 参考博客：https://blog.csdn.net/juzihongle1/article/details/73135920","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/tags/AI/"},{"name":"Maze","slug":"Maze","permalink":"http://yoursite.com/tags/Maze/"},{"name":"BFS & DFS","slug":"BFS-DFS","permalink":"http://yoursite.com/tags/BFS-DFS/"}]},{"title":"贪吃蛇智能自动寻食","slug":"snake","date":"2019-04-25T12:28:49.816Z","updated":"2019-04-27T08:51:57.861Z","comments":true,"path":"2019/04/25/snake/","link":"","permalink":"http://yoursite.com/2019/04/25/snake/","excerpt":"本次带来智能贪吃蛇的实现，以尽最大的可能吃掉食物，甚至最后达到满屏的效果。界面部分采用OpenGL制作，辅以炫酷的粒子效果。","text":"本次带来智能贪吃蛇的实现，以尽最大的可能吃掉食物，甚至最后达到满屏的效果。界面部分采用OpenGL制作，辅以炫酷的粒子效果。 前言 简单的框架 贪吃蛇AI实现 算法实现 实现展示 前言 本次带来智能贪吃蛇的实现，以尽最大的可能吃掉食物，甚至最后达到满屏的效果。界面部分采用OpenGL制作，辅以炫酷的粒子效果。整个工程以及可执行exe可以在github下载： https://github.com/ZeusYang/Breakout 其中的GreedySnake就是本工程项目目录。 简单的框架 **Shader类:**编译、链接着色器程序，包括顶点着色器、片元着色器、几何着色器，也提供设置GPU中的uniform变量的接口。 **Texture2D类:**封装了OpenGL的纹理接口，用于从数据中创建纹理，指定纹理格式，并用于绑定。 **ResourceManager类:**资源管理器，用于管理着色器资源和纹理资源，统一给每个着色器命名进行管理，提供从文件中获取着色器代码进而传入Shader类进行编译以及读取图片数据生成纹理，保存所有着色器程序和纹理的副本。 **SpriteRenderer类:**渲染精灵，这里是一个2D的四边形，提供一个统一的四边形VAO接口，一个精灵有不同的位置、大小、纹理、旋转角度、颜色。 **PostProcessor类:**后期特效处理，主要使用OpenGL的帧缓冲技术，将游戏渲染后的画面进一步地处理，这里包括震荡、反相、边缘检测和混沌。 **TextRenderer类:**文本渲染，用于渲染文字。 **GameObject类:**游戏物品的高层抽象，每个游戏物品有位置、大小、速度、颜色、旋转度、是否实心、是否被破坏、纹理等属性，每次调用SpriteRenderer类的一个实例的Draw方法渲染GameObject。 **SnakeObject类:**继承自GameObject类，用于绘制蛇身。 **ISoundEngine:**第三方库irrKlang的实例，用于播放游戏音效。 **Algorithm类:**算法类，贪吃蛇AI的全部算法逻辑都在这里。 贪吃蛇AI实现 寻路策略 我们已知食物的位置和蛇头的位置，那么怎么寻找蛇头到食物的位置呢？方法有多种，如A*算法、宽度优先遍历。这里我采用的是宽度优先遍历，在一个二维的数组上，从食物出发，用宽度优先遍历的方法计算出格子中非蛇身到食物的最短距离。一次bfs之后，这个二维格子上就标记好了到食物的最短距离，bfs就是我们搜索的核心： 12345678910111213141516171819202122232425262728293031bool Algorithm::RefreshBoard(const std::list&lt;Object&gt; &amp;psnake, const Object &amp;pfood, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;pboard) &#123; /* 从食物出发，利用广度优先遍历向四周扩散 从而得到pboard中每个格子到达food的路径长度 */ std::queue&lt;glm::ivec2&gt; record; record.push(pfood.Index); std::vector&lt;std::vector&lt;bool&gt;&gt;visited; visited.resize(pboard.size(), std::vector&lt;bool&gt;(pboard[0].size(), false)); visited[pfood.Index.x][pfood.Index.y] = true; glm::ivec2 cur; bool found = false; while (!record.empty()) &#123; glm::ivec2 head = record.front(); record.pop(); //向四个方向扩展 for (auto x = 0; x &lt; 4; ++x) &#123; cur = glm::ivec2(head.x + dir[x][0], head.y + dir[x][1]); //碰到边界或已经访问过了 if (!CouldMove(cur) || visited[cur.x][cur.y])continue; if (cur == psnake.front().Index)found = true;//找到蛇头 if (pboard[cur.x][cur.y] &lt; SNAKE) &#123;//不是蛇身 pboard[cur.x][cur.y] = pboard[head.x][head.y] + 1; record.push(cur); visited[cur.x][cur.y] = true; &#125; &#125; &#125; return found;&#125; 贪吃蛇寻食策略 上面已经给出了一种搜索算法，但是简单的使用bfs算法只能使蛇运行非常短的一段时间，一段时间之后它就被自己的身体困住了。每次都单纯地使用BFS，最终有一天， 贪吃蛇会因为这种不顾后果的短视行为而陷入困境。 聪明的蛇会考虑吃食物的后果，也就是吃完这个食物自己还安全吗？那么自己定义安全的局面呢？我们知道，蛇头在移动的过程中，蛇尾部分是不断地有空位空出来的，蛇永远不死的最好策略就是追着自己的尾巴跑！现在我们定义这样的安全策略，如果蛇吃完这个食物之后，蛇头到蛇尾之间有通路的话，那么就定义为安全的！ **每次寻找到食物的一个路径，我们就模拟蛇头移动过去吃食物了，然后再用bfs算法搜索蛇头到蛇尾之间是否存在通路。这是我们目前的策略。**值得注意的是，蛇每走一步，整个蛇身会移动，也就是说蛇在移动的过程中，整个局面是不断变化，所以我们不能只一次bfs就够了，而是每走一步，我们按照前面的策略模拟一次，不断寻找安全的路径！ 那么现在我们的问题是，如果蛇和食物之间不存在安全的路径或蛇和食物之间根本就没有通路该如何？也就是说吃完食物之后蛇头和蛇尾没有通路了或根本吃不到食物，这种情况下蛇可能很快就被自己饶进了死胡同然后over了。这时我们先用远大的目光，暂时不要去管食物，我们先追着蛇尾跑，在追着蛇尾的过程中出现安全的路径我们再过去吃食物。 现在新的问题又来了，如果蛇和食物之间没有路径且蛇头和蛇尾之间也没有路径该怎么办？这个时候没什么办法了，只能将就地走走停停，每次只走一步，更新布局，然后再判断蛇和食物间是否有安全路径； 没有的话，蛇头和蛇尾间是否存在路径；还没有，再挑一步可行的来走。 一般来说，我们让蛇头和食物之间的路径尽可能短，就是快点吃掉食物，而蛇头和蛇尾之间的路尽可能地长，尽可能地慢。这样蛇头和蛇尾间才能腾出更多的空间，空间多才有得发展。 所以针对食物和蛇尾，我们有：目标是食物时，选最短路径；目标是蛇尾时，选最长路径。 好的现在我们整理一下整个贪吃蛇AI的策略: 123456If hasPath(head,food) &amp;&amp; safe(head,tail): then go one step ahead toward food.else if hasPath(head,tail( then go one step ahead toward tail.else just find any possible step to go. 算法实现 核心部分： 12345678910111213//AI思考glm::ivec2 Algorithm::AIThinking() &#123; ResetBoard(snake, *food, board); glm::ivec2 move; if (RefreshBoard(snake, *food, board))//可以吃到食物 move = FindSafeWay();//找到一条安全的路 else move = FollowTail();//不可吃到食物，跟随尾巴 if(move == glm::ivec2(-1,-1))//不能跟随尾巴，任意路径 move = AnyPossibleWay(); return move;&#125; 12345678910111213141516171819202122232425if (this-&gt;State == GAME_ACTIVE ) &#123;//AI模式 //AI策略 glm::ivec2 move = algorithm-&gt;AIThinking(); //没找到任何路径，游戏结束 if (move == glm::ivec2(-1, -1))this-&gt;State = GAME_LOST; else &#123; //走出一步 bool isCollision = algorithm-&gt;make_move(move); if (isCollision) &#123;//碰撞,boom fireindex = (fireindex + 1) % 3; firetimer[fireindex] = 2.0f; firework-&gt;Position = food-&gt;Position; boom[fireindex]-&gt;Reset(); boom[fireindex]-&gt;Update(0.f, *firework, 400, firework-&gt;Size / 2.0f, 3, fireindex); sound-&gt;play2D(\"../res/Audio/get.wav\", GL_FALSE); //获取一分 ++score; &#125; if (algorithm-&gt;win) &#123;//满屏了 State = GAME_WIN; return; &#125; food-&gt;Position = Index(algorithm-&gt;food-&gt;Index);//更新食物位置 &#125;&#125; 算法类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697struct Object &#123; glm::ivec2 Index;//数组下标 glm::vec3 Color;//颜色 Object(int r,int c) :Index(r, c) &#123; int decision = rand() % 4; switch (decision) &#123; case 0:Color = glm::vec3(0.2f, 0.6f, 1.0f); break; case 1:Color = glm::vec3(0.0f, 0.7f, 0.0f); break; case 2:Color = glm::vec3(0.8f, 0.8f, 0.4f); break; case 3:Color = glm::vec3(1.0f, 0.5f, 0.0f); break; default: Color = glm::vec3(1.0f, 0.5f, 0.0f); break; &#125; &#125;&#125;;//算法逻辑类class Algorithm&#123;public: Algorithm(GLuint x,GLuint y); //随机产生新的食物 glm::ivec2 NewFood(); //重置 void ResetBoard(const std::list&lt;Object&gt; &amp;psnake, const Object &amp;pfood, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;pboard); void ResetSnakeAndFood(); //广度优先遍历整个board的情况 bool RefreshBoard(const std::list&lt;Object&gt; &amp;psnake, const Object &amp;pfood, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;pboard); glm::ivec2 FindSafeWay();//找到一条安全的路径 glm::ivec2 AnyPossibleWay();//随便找一条路 glm::ivec2 AIThinking();//AI思考 void Display(); bool make_move(glm::ivec2 step);//移动蛇身 void VirtualMove();//虚拟探测性检测 bool IsTailInside();//评测是否蛇尾和蛇头之间有路径 glm::ivec2 FollowTail();//朝蛇尾方向走 std::list&lt;Object&gt; snake;//蛇 std::shared_ptr&lt;Object&gt; food;//食物 bool win; private: //行数、列数 GLuint row, col; std::vector&lt;std::vector&lt;int&gt; &gt;board;//用来标记board中每个位置的状况，0是空的，1是蛇身，2是食物 //虚拟记录贪吃蛇的情况 std::vector&lt;std::vector&lt;int&gt; &gt;tmpboard; std::list&lt;Object&gt; tmpsnake; int EMPTY, SNAKE, FOOD; //边界判断 inline bool CouldMove(glm::ivec2 &amp;target) &#123; if (target.x &lt; 0 || target.x &gt;= row)return false; if (target.y &lt; 0 || target.y &gt;= col)return false; return true; &#125; //二维数组的结点向上、下、左、右四个扩展方向 const int dir[4][2] = &#123; &#123; -1,0 &#125;,&#123; +1,0 &#125;,&#123; 0,-1 &#125;,&#123; 0,+1 &#125; &#125;; //找到一条最短的路径的方向 inline glm::ivec2 ShortestMove(glm::ivec2 target, const std::vector&lt;std::vector&lt;int&gt; &gt; &amp;pboard)&#123; int minv = SNAKE; glm::ivec2 move(-1,-1); for (auto x = 0; x &lt; 4; ++x) &#123; glm::ivec2 tmp = glm::ivec2(target.x + dir[x][0], target.y + dir[x][1]); if (CouldMove(tmp) &amp;&amp; minv &gt; pboard[tmp.x][tmp.y]) &#123; minv = pboard[tmp.x][tmp.y]; move = tmp; &#125; &#125; return move; &#125; //找到一条最长的路径的方向 inline glm::ivec2 LongestMove(glm::ivec2 target, const std::vector&lt;std::vector&lt;int&gt; &gt; &amp;pboard) &#123; int mxav = -1; glm::ivec2 move(-1, -1); for (auto x = 0; x &lt; 4; ++x) &#123; glm::ivec2 tmp = glm::ivec2(target.x + dir[x][0], target.y + dir[x][1]); if (CouldMove(tmp) &amp;&amp; pboard[tmp.x][tmp.y] &lt; EMPTY &amp;&amp; mxav &lt; pboard[tmp.x][tmp.y]) &#123; mxav = pboard[tmp.x][tmp.y]; move = tmp; &#125; &#125; return move; &#125;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189Algorithm::Algorithm(GLuint x, GLuint y) :row(x), col(y), FOOD(0), EMPTY((row + 1)*(col + 1)), SNAKE(2 * EMPTY)&#123; food = std::make_shared&lt;Object&gt;(NewFood().x, NewFood().y); board.resize(row, std::vector&lt;int&gt;(col, EMPTY)); win = false;&#125;void Algorithm::ResetBoard(const std::list&lt;Object&gt; &amp;psnake, const Object &amp;pfood, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;pboard) &#123; for (auto &amp;t : pboard) std::fill(t.begin(), t.end(), EMPTY); pboard[pfood.Index.x][pfood.Index.y] = FOOD; for (auto &amp;t : psnake) pboard[t.Index.x][t.Index.y] = SNAKE;&#125;glm::ivec2 Algorithm::NewFood() &#123; glm::ivec2 loc; loc.x = rand() % row; loc.y = rand() % col; while (true) &#123; bool found = false; for (auto &amp;x : snake) &#123; if (loc == x.Index) &#123; found = true; break; &#125; &#125; if (!found)return loc; loc.x = rand() % row; loc.y = rand() % col; &#125; return loc;&#125;void Algorithm::Display() &#123; for (auto &amp;t : board) &#123; for (auto &amp;x : t) &#123; std::cout &lt;&lt; x &lt;&lt; \"-\"; &#125; std::cout &lt;&lt; \"\\n\"; &#125;&#125;bool Algorithm::RefreshBoard(const std::list&lt;Object&gt; &amp;psnake, const Object &amp;pfood, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;pboard) &#123; /* 从食物出发，利用广度优先遍历向四周扩散 从而得到pboard中每个格子到达food的路径长度 */ std::queue&lt;glm::ivec2&gt; record; record.push(pfood.Index); std::vector&lt;std::vector&lt;bool&gt;&gt;visited; visited.resize(pboard.size(), std::vector&lt;bool&gt;(pboard[0].size(), false)); visited[pfood.Index.x][pfood.Index.y] = true; glm::ivec2 cur; bool found = false; while (!record.empty()) &#123; glm::ivec2 head = record.front(); record.pop(); //向四个方向扩展 for (auto x = 0; x &lt; 4; ++x) &#123; cur = glm::ivec2(head.x + dir[x][0], head.y + dir[x][1]); //碰到边界或已经访问过了 if (!CouldMove(cur) || visited[cur.x][cur.y])continue; if (cur == psnake.front().Index)found = true;//找到蛇头 if (pboard[cur.x][cur.y] &lt; SNAKE) &#123;//不是蛇身 pboard[cur.x][cur.y] = pboard[head.x][head.y] + 1; record.push(cur); visited[cur.x][cur.y] = true; &#125; &#125; &#125; return found;&#125;bool Algorithm::make_move(glm::ivec2 step) &#123; //直接加入前面 snake.push_front(Object(step.x,step.y)); //如果加的不是食物位置,删掉最后一个 if (snake.front().Index != food-&gt;Index) &#123; snake.pop_back(); &#125; else &#123;//如果吃到食物 if (snake.size() == row*col) &#123; win = true; return true; &#125; food-&gt;Index = NewFood();//重新产生一个新的食物 return true; &#125; return false;&#125;glm::ivec2 Algorithm::AnyPossibleWay() &#123; glm::ivec2 ret = glm::ivec2(-1,-1); ResetBoard(snake, *food, board); RefreshBoard(snake, *food, board); int minv = SNAKE; for (auto x = 0; x &lt; 4; ++x) &#123; glm::ivec2 tmp = glm::ivec2(snake.front().Index.x + dir[x][0], snake.front().Index.y + dir[x][1]); if (CouldMove(tmp) &amp;&amp; minv &gt; board[tmp.x][tmp.y]) &#123; minv = board[tmp.x][tmp.y]; ret = tmp; &#125; &#125; return ret;&#125;void Algorithm::VirtualMove() &#123; tmpsnake = snake; tmpboard = board; ResetBoard(tmpsnake, *food, tmpboard); bool eaten = false; glm::ivec2 move; while (!eaten) &#123;//已确保蛇与食物有路径，所以不会陷入死循环 //搜索路径 RefreshBoard(tmpsnake, *food, tmpboard); move = ShortestMove(tmpsnake.front().Index, tmpboard);//找到最短的一步 tmpsnake.push_front(Object(move.x, move.y));//加入蛇头 if (move == food-&gt;Index) &#123;//如果走到了食物那里 eaten = true; ResetBoard(tmpsnake, *food, tmpboard); tmpboard[food-&gt;Index.x][food-&gt;Index.y] = SNAKE;//食物被蛇吃掉了 &#125; else &#123;//还没吃到食物 tmpsnake.pop_back(); &#125; &#125;&#125;bool Algorithm::IsTailInside() &#123; //将蛇尾看成食物 tmpboard[tmpsnake.back().Index.x][tmpsnake.back().Index.y] = FOOD; tmpboard[food-&gt;Index.x][food-&gt;Index.y] = SNAKE; Object tail(tmpsnake.back().Index.x, tmpsnake.back().Index.y); bool ret = RefreshBoard(tmpsnake, tail, tmpboard); for (auto x = 0; x &lt; 4; ++x) &#123; glm::ivec2 tmp = glm::ivec2(tmpsnake.front().Index.x + dir[x][0], tmpsnake.front().Index.y + dir[x][1]); if (CouldMove(tmp) &amp;&amp; tmp == tail.Index)ret = false; &#125; return ret;&#125;glm::ivec2 Algorithm::FollowTail() &#123; tmpsnake = snake; ResetBoard(tmpsnake, *food, tmpboard); //将蛇尾看成食物 tmpboard[tmpsnake.back().Index.x][tmpsnake.back().Index.y] = FOOD; tmpboard[food-&gt;Index.x][food-&gt;Index.y] = SNAKE; Object tail(tmpsnake.back().Index.x, tmpsnake.back().Index.y); RefreshBoard(tmpsnake, tail, tmpboard); //还原，排除蛇头与蛇尾紧挨着 tmpboard[tmpsnake.back().Index.x][tmpsnake.back().Index.y] = SNAKE; return LongestMove(tmpsnake.front().Index, tmpboard);&#125;glm::ivec2 Algorithm::FindSafeWay() &#123; VirtualMove();//虚拟蛇移动吃食物 if (IsTailInside())//检查吃完食物后蛇头与蛇尾之间是否存在路径 return ShortestMove(snake.front().Index, board); glm::ivec2 move = FollowTail();//没有路径则跟随尾巴 return move;&#125;//AI思考glm::ivec2 Algorithm::AIThinking() &#123; ResetBoard(snake, *food, board); glm::ivec2 move; if (RefreshBoard(snake, *food, board))//可以吃到食物 move = FindSafeWay();//找到一条安全的路 else move = FollowTail();//不可吃到食物，跟随尾巴 if(move == glm::ivec2(-1,-1))//不能跟随尾巴，任意路径 move = AnyPossibleWay(); return move;&#125;void Algorithm::ResetSnakeAndFood() &#123; snake.clear(); snake.push_back(Object(row / 2 - 1, col / 2 - 1)); snake.push_back(Object(row / 2 - 1, col / 2 + 0)); snake.push_back(Object(row / 2 - 1, col / 2 + 1)); food-&gt;Index = NewFood(); win = false;&#125; 实现展示 动态gif，只录了很小的一部分。整个格子设置得太大了点，27*27。 格子设置太大也导致了后期的情况非常复杂，满屏的难度的比较大，几乎都是差了几个格子然后陷入了死胡同或者陷入了死循环（一直追着蛇尾跑）。嗯，贪吃蛇AI在这里表现可以说是差不多是98%吧。设置得格子比较少的时候，是有满屏的。 格子较少的满屏： 格子较多（27*27）时的最终结果，已经接近大圆满的程度了： 整个工程以及可执行exe可以在github下载： https://github.com/ZeusYang/Breakout 其中的GreedySnake就是本工程项目目录。 参考博客：http://blog.renren.com/share/265863809/15651358712/2","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"Greedy Snake","slug":"Greedy-Snake","permalink":"http://yoursite.com/tags/Greedy-Snake/"},{"name":"OpenGL","slug":"OpenGL","permalink":"http://yoursite.com/tags/OpenGL/"},{"name":"Particle Effect","slug":"Particle-Effect","permalink":"http://yoursite.com/tags/Particle-Effect/"}]},{"title":"基于GPU预计算的大气层光效渲染","slug":"atmosphere","date":"2019-04-25T11:25:47.417Z","updated":"2019-04-29T11:14:38.105Z","comments":true,"path":"2019/04/25/atmosphere/","link":"","permalink":"http://yoursite.com/2019/04/25/atmosphere/","excerpt":"本文叙述基于物理模型的大气层光效渲染，不仅考虑单重散射，而且也尝试实现多重散射的效果。主要参考论文为Eric Bruneton和Fabrice Neyret的《Precomputed Atmospheric Scattering》。","text":"本文叙述基于物理模型的大气层光效渲染，不仅考虑单重散射，而且也尝试实现多重散射的效果。主要参考论文为Eric Bruneton和Fabrice Neyret的《Precomputed Atmospheric Scattering》。 基于GPU预计算的大气层光效渲染 前言 大气物理模型 渲染方程及其实现 实验结果 参考文献 前言 本文叙述基于物理模型的大气层光效渲染，不仅考虑单重散射，而且也尝试实现多重散射的效果。主要参考论文为Eric Bruneton和Fabrice Neyret的《Precomputed Atmospheric Scattering》。博文如果错误，欢迎指出，非常感谢。此外，本文较多物理理论和数学推导，代码也比较多。 代码已放至本人的github上：https://github.com/ZeusYang/Atmosphere 大气物理模型 1、大气散射现象 大气散射是指，太阳光在射入大气层时，与大气中的空气分子或空气溶胶等发生相互作用，使得入射的光能以一定的规律在各个方向上进行重新分布的现象。太阳光在射入大气层时，遇到大气分子、尘埃、雨滴等颗粒后，都会发生散射现象。其中一部分的光能会被这些粒子吸收转化为热能，而另一部分光能则会以该粒子为中心，向四面八方扩散开来。所以，在经过了大气的散射作用之后，有部分太阳光将无法抵达地球表面。大气散射在自然界中是一种十分重要而又普遍存在的物理现象，人们平时用肉眼观察到的光很大一部分都是散射光。如果没有大气散射，那么只要不是太阳光直接照射到的位置，都将是完全黑暗的。 2、空气物理模型 空气中的介质颗粒根据其直径大小的不同可分为两种：直径远小于光线波长的空气微粒、与直径与光线波长相当的空气溶胶。由前者引起的散射我们称为Rayleigh散射，它是导致晴朗天空呈现蓝色的主要原因。由后者引起的散射我们称为Mie散射，它是导致阴霾的天空呈现灰色的原因，因为阴天的空气中存在大量与光波直径相当的水滴。 ①Rayleigh散射：由空气中远小于波长的微粒(如空气分子)引起的散射称作瑞利散射。Rayleigh散射强度与光线波长的四次方成反比，这意味着白光中波长较短的颜色光(蓝色)会比波长较长的光(红色)有更强的散射强度，导致天空在白天偏向蓝色，而在黄昏偏向橙红色。 当日出或日落的时候，由于太阳的位置接近地平线，阳光斜射入大气，会在大气层中穿过很长的距离。在这个过程中，太阳光中的蓝色光几乎都会被散射殆尽无法抵达人眼，只剩下了波长较长的红色光，所以在太阳及其周围的天空都会呈现橘红色。 Rayleigh散射的散射系数可以使用如下公式计算： βR(θ)=2π2(n2−1)23Nλ4pR(θ)\\beta_R(\\theta)=\\frac{2\\pi^2(n^2-1)^2}{3N\\lambda^4}p_R(\\theta)βR​(θ)=3Nλ42π2(n2−1)2​pR​(θ) （1） 其中θ\\thetaθ是视线与太阳光线的夹角，NNN是大气分子密度，nnn是大气的折射率，λ\\lambdaλ是入射光的波长，pR(θ)p_R(\\theta)pR​(θ)是单位化的相位函数。由上可知，Rayleigh散射明显与波长的四次方成反比，在实现中我们可用一个RGB向量来表示，散射系数可表示为： βR.rgb=(5.81,13.5,33.1)×10−6\\beta_R.rgb=(5.81,13.5,33.1)\\times10^{-6}βR​.rgb=(5.81,13.5,33.1)×10−6 （2） 由于Rayleigh散射几乎是各向同性的，即光线会被粒子向各个方向均匀散射，其相位函数可以表示为： pR(θ)=316π(1+cos2θ))p_R(\\theta)=\\frac{3}{16\\pi}(1+cos^2\\theta))pR​(θ)=16π3​(1+cos2θ)) （3） 相位函数描述了散射的方向特征，也就是在视线与光线夹角为θ\\thetaθ的情况，在总共散射的光线中有多少被散射到视线方向上，可以理解为概率或者比例。 ② Mie散射：在空气中直径与波长相当的微粒(如尘埃、雾滴等)所导致的散射现象称作Mie散射。与Rayleigh散射不同，Mie散射与波长无关，散射方向表现出明显的各向异性，光线会被粒子更多的向后方散射。而当阴雨天气时，空气中存在大量的水滴颗粒，Mie散射导致天空呈现灰白色。现今经常出现的雾霆天气，同样是因为空气中悬浮的大颗粒过多而导致的Mie散射现象。 由于Mie散射与波长无关，故可以用标量表示，Mie散射系数为： βM.rgb=2.0×10−5\\beta_M.rgb=2.0\\times10^{-5}βM​.rgb=2.0×10−5 （4） Mie散射的方向是各向异性的，光线会被更多的向后方散射，其相位函数为： pM(θ)=14π3(1−g2)2(2+g2)1+cos2θ(1+g2−2gcosθ)32p_M(\\theta)=\\frac{1}{4\\pi}\\frac{3(1-g^2)}{2(2+g^2)}\\frac{1+cos^2\\theta}{(1+g^2-2gcos\\theta)^{\\frac{3}{2}}}pM​(θ)=4π1​2(2+g2)3(1−g2)​(1+g2−2gcosθ)23​1+cos2θ​ （5） 在公式（5）中，θ\\thetaθ是光线方向与视线方向的夹角，而ggg表示散射的对称性。若ggg是正值，则大多数光线会被粒子向后方散射；若ggg是负值，则更多的光线会被向前方散射。通常，g取值[-0.75,0.99]。 ③ 大气密度：对于瑞利散射和米氏散射，它们对太阳光的散射作用都和空气粒子的密度有关。许多大气模型都假设摄像机总是在地面上或者是在十分接近地面的位置，这样就可以认为空气具有一个恒定的粒子密度，这就在很大程度上简化了Nishita在1993年提出的散射积分方程，并在近地空间可以得到很好的渲染效果。然而在远离地表的高空，这种做法得到的渲染结果并不准确。 实际中的大气密度在地球引力的作用下，越靠近地表空气密度越高，越远离地表空气越稀薄。所以，我们假定空气粒子的密度是沿着海拔高度h呈指数递减的： ρ=ρ0e−hH\\rho=\\rho_0e^{-\\frac{h}{H}}ρ=ρ0​e−Hh​ 其中ρ0\\rho_0ρ0​是在海平面的空气密度 （6） hhh为当前采样点的海拔高度，HHH是缩放高度（在实现中可设为大气层高度）。理论上说大气层并没有确定的高度，但在实现中我们需要一个统一高度来渲染天空弯顶，这样空气密度随着高度的增加而呈指数递减。对于Rayleigh散射与Mie散射我们分别使用不同的缩放高度:HR=7994kmH_R=7994kmHR​=7994km，HM=1200kmH_M=1200kmHM​=1200km。这是因为影响Mie散射的大颗粒(尘埃、水滴等)更多的存在于近地表的对流层中，再往上Mie散射效果不明显，但Rayleigh散射的作用依然存在。 3、光线内散射 太阳光在大气中传输的时候会与空气中的微粒产生交互作用。有两种重要的交互方式:散射，它改变了光线的方向；吸收，它将光能吸收并转变为其它形态的能量（如热能）。而散射效果对场景中物体的影响又分为两个方面：一方面是一部分由物体反射的光被散射到视线之外，并不能到达摄像机，因而被衰减，称作外散射；另一方面是一部分太阳光被空气中的粒子散射正对向摄像机，这些正朝向视线的散射被称作内散射。 最后抵达视点被人眼所观察到的光线可分为两部分：衰减后的物体反射辐射度、被内散射的大气散射辐照度。 Lviewer=Lobject⋅e−T(O→C)+LinscatterL_{viewer}=L_{object}\\cdot e^{-T(O\\to C)}+L_{inscatter}Lviewer​=Lobject​⋅e−T(O→C)+Linscatter​ （7） 其中LviewerL_{viewer}Lviewer​为最终抵达摄像机的总光强，LobjectL_{object}Lobject​为物体的反射光（当视线不与物体相交时则为000），LinscatterL_{inscatter}Linscatter​为从O到C点路径上所有内散射光线的总和，这里暂时忽略太阳直射。 公式（7）中的e−T(O→C)e^{-T(O\\to C)}e−T(O→C)是光线从O点到C点的衰减系数，其中T(O→C)T(O\\to C)T(O→C)被称作光学深度（Optical Length)，它是散射系数与密度乘积在整条路径上的积分。 ① 光学深度：在上图中，大气层内有一点PPP，它在视线COCOCO上。太阳光线照向地球，在穿过大气层的时候会受空气分子和空气溶胶的散射作用而发生衰减（外散射的影响），最终到达PPP点处的光能总量为： Lp=Lsune−T(A→P)L_p=L_{sun}e^{-T(A\\to P)}Lp​=Lsun​e−T(A→P) （8） 其中LsunL_{sun}Lsun​是太阳光到达大气层前的初始辐射度。上图中AAA点是光线到达PPP点之前与大气层的交点，则T(A→P)T(A\\to P)T(A→P)被称作AAA点到PPP点的光学深度（Optical Depth），它本质上就是AAA点到PPP点这条路径上散射系数乘上空气密度的积分（包含Rayleigh散射与Mie散射）： T(A→P)=∫AP(βRee−h(t)HR+βMee−h(t)HM)dtT(A\\to P)=\\int_A^P(\\beta_R^ee^{-\\frac{h(t)}{H_R}}+\\beta_M^ee^{-\\frac{h(t)}{H_M}})dtT(A→P)=∫AP​(βRe​e−HR​h(t)​+βMe​e−HM​h(t)​)dt （9） 公式（9）中的参数前面都已提到过：βRe\\beta_R^eβRe​即Rayleigh散射系数，βMe\\beta_M^eβMe​是Mie散射系数，而形如e−hHe^{-\\frac{h}{H}}e−Hh​的则分别是Rayleigh散射粒子密度分布函数、Mie散射粒子密度分布函数。在这里我们散射系数当作一个在海平面上的常数值，则式（9）可变为如下形式： T(A→P)=βRe∫APe−h(t)HRdt+βMe∫APe−h(t)HMdtT(A\\to P)=\\beta_R^e\\int_A^Pe^{-\\frac{h(t)}{H_R}}dt+\\beta_M^e\\int_A^Pe^{-\\frac{h(t)}{H_M}}dtT(A→P)=βRe​∫AP​e−HR​h(t)​dt+βMe​∫AP​e−HM​h(t)​dt （10） 所以我们只需对AP路径上的空气密度进行积分，这个积分值被称光学长度（Optical Length），直观的意义就是在光线照射的路径上空气粒子的总量。 ② 散射系数：散射系数决定了散射介质对光线的散射的强弱程度，也反应了光线在通过该介质时的衰减程度。我们已经在前面提到，Rayleigh散射对不同波长的光线散射强度不同，在实现中我们可以将其在海平面处的散射系数设为一个三维向量： βR.rgb=(5.81,13.5,33.1)×10−6\\beta_R.rgb=(5.81,13.5,33.1)\\times10^{-6}βR​.rgb=(5.81,13.5,33.1)×10−6 而Mie散射对波长的变化影响不明显，所以可以将其在海平面上的散射系数设为标量： βM.rgb=2.0×10−5\\beta_M.rgb=2.0\\times10^{-5}βM​.rgb=2.0×10−5 ③ 相位函数：己知入射光能和介质的散射系数，我们就可以计算出有多少光线会被介质散射出去。但并非所有的光线在散射之后都会朝向摄像机，有一部分会被散射到其它方向，无法被肉眼所观察到(称作外散射)。所以为了计算内散射的光线量，还需要有另外一个因子描述这个物理量。而相位函数p(θ)p(\\theta)p(θ)则描述了在该点有多少光线散射之后朝向摄像机，其中的参数θ\\thetaθ是太阳光到点PPP的向量LPLPLP与点PPP到摄像机位置的向量PCPCPC的夹角，如下图所示。 相位函数是标准化的，函数本身在所有方向的积分为111。Rayleigh散射特点是各向同性，光线会以介质粒子为中心均匀地向各个方向散射，其相位函数是前面提到的公式（3）。而Mie散射呈现明显的各向异性，光线会被更多的介质粒子向后方散射，其相位函数是前面提到的公式（5）。 ④ 单重散射：目前我们讨论的都是单重散射，即太阳光在到达视点之前只会进行一次散射。点PPP的内散射光在达到视点前还会受到空气颗粒影响而衰减，衰减程度取决于点PPP到点CCC（视点）的光学深度T(P→C)T(P\\to C)T(P→C)，因而衰减因子为e−T(P→C)e^{-T(P\\to C)}e−T(P→C)。 所以最终达到视点C的内散射方程如下： Linscatter=∫COLsun⋅e−T(A(s)→P(s))⋅e−T(P(s)→C)⋅(βRse−h(s)HRpR(θ)+βMse−h(s)HMpM(θ))dsL_{inscatter}=\\int_C^OL_{sun}\\cdot e^{-T(A(s)\\to P(s))}\\cdot e^{-T(P(s)\\to C)}\\cdot (\\beta_R^se^{-\\frac{h(s)}{H_R}}p_R(\\theta)+\\beta_M^se^{-\\frac{h(s)}{H_M}}p_M(\\theta))dsLinscatter​=∫CO​Lsun​⋅e−T(A(s)→P(s))⋅e−T(P(s)→C)⋅(βRs​e−HR​h(s)​pR​(θ)+βMs​e−HM​h(s)​pM​(θ))ds（10） 上式中有两个衰减因子，一个是从AAA到PPP的衰减因子，一个是从PPP到CCC的衰减因子。整个积分路径是从OOO到CCC，这一方程描述了从OOO到CCC路径上全部内散射光的总和。 内散射积分公式（10）中，在积分路径OC上太阳光与视线的夹角θ\\thetaθ保持不变，因此有必要将相位函数p(θ)p(\\theta)p(θ)从积分内部中提取出来。而太阳光是平行光，LsunL_{sun}Lsun​是大阳光在大气层顶层的辐射度，视为常量，也可从积分内部提取出来。散射系数亦如此。故公式（10）可变为如下： Linscatter=LsunpR(θ)βRs∫COe−T(A(s)→P(s))−T(P(s)→C)e−h(s)HRds+LsunpM(θ)βMs∫COe−T(A(s)→P(s))−T(P(s)→C)e−h(s)HMdsL_{inscatter}=L_{sun}p_R(\\theta)\\beta_R^s\\int_C^Oe^{-T(A(s)\\to P(s))-T(P(s)\\to C)}e^{-\\frac{h(s)}{H_R}}ds+L_{sun}p_M(\\theta)\\beta_M^s\\int_C^Oe^{-T(A(s)\\to P(s))-T(P(s)\\to C)}e^{-\\frac{h(s)}{H_M}}dsLinscatter​=Lsun​pR​(θ)βRs​∫CO​e−T(A(s)→P(s))−T(P(s)→C)e−HR​h(s)​ds+Lsun​pM​(θ)βMs​∫CO​e−T(A(s)→P(s))−T(P(s)→C)e−HM​h(s)​ds （11） 故要计算一个视点到物体之间的内射光线，我们需要对视线路径上每一点的衰减因子以及空气密度进行积分。 ⑤ 多重散射：光线在传输过程中被空气中的一个粒子影响，称为光的一次散射。当空气中大颗粒较多时，被粒子散射的光又会被散射方向上的其它粒子再次散射，这个过程称为多重散射（Multiple Scattering)。在晴朗干净的天空中，由于空气中大粒子的数量较少，多重散射的作用不是很明显。而在空气浑浊或黄昏时，多重散射会对场景的真实性产生较明显的影响。 我们前面的讨论都是单一散射模型。这一模型在白天的时候比较合理，这一假设在白天的时候比较合理，因为在白天的时候太阳光强度较高，多重散射作用不明显;而在傍晚的时候，由于太阳直射光强度变弱，多重散射对场景的影响会变得更加重要，在渲染真实图像中必须加以考虑。即便如此，单一散射模型在此时依旧可以提供一个相对较好的结果。 关于多重散射的文献资料较少，因为单重散射模型目前已经有了不错的渲染结果。在我阅读的这篇论文《Precomputed Atmospheric Scattering》中考虑了多重散射的情况，较为复杂，在后面论述。 ⑥ 体积光：当光线照射到遮挡物时，一部分光线会从物体的边缘和空隙中穿过，并产生很明显的光柱效果，在视觉上给人以很强的体积感，所以称之为体积光（Light shaft)。体积光在自然界中是十分常见的现象，如太阳光从云隙中透过时产生的云隙光，森林中阳光从树叶中穿过产生的光柱。体积光现象有时又被称作“丁达尔效应”。其理论基础同样是光线的散射原理，可以使用前面描述的Mie散射理论来解释。对于溶胶，其粒子大小通常与可见光的波长相当，所以在光线穿过气溶胶时，会发生明显的Mie散射现象，产生肉眼可观察到的光柱体。 渲染方程及其实现 为了便于论述，我们记L(x,v,s)L(x,v,s)L(x,v,s)为视点xxx从方向vvv接收的总的辐射度，其中sss是太阳方向向量。记x0(x,v)x_0(x,v)x0​(x,v)为视线vvv的终点（通常为地面、物体或大气顶层）。xxx到x0x_0x0​之间的衰减因子TTT、x0x_0x0​处的反射辐射度III、在某一点yyy向−v-v−v内散射的辐射度JJJ定义如下： T(x,x0)=exp(−∫xx0(βReρR(y)+βMeρM(y))dy)T(x,x_0)=exp(-\\int_x^{x_0}(\\beta_R^e\\rho_R(y)+\\beta_M^e\\rho_M(y))dy)T(x,x0​)=exp(−∫xx0​​(βRe​ρR​(y)+βMe​ρM​(y))dy) （12） I[L](x0,s)=α(x0)π∫2πL(x0,ω,s)⋅n(x0)dω,or0I[L](x_0,s)=\\frac{\\alpha(x_0)}{\\pi}\\int_{2\\pi}L(x_0,\\omega,s)\\cdot n(x_0)d\\omega ,or 0I[L](x0​,s)=πα(x0​)​∫2π​L(x0​,ω,s)⋅n(x0​)dω,or0 （13） J[L](y,v,s)=∫4π∑i∈{R,M}βis(y)pi(v⋅w)L(y,ω,s)dωJ[L](y,v,s)=\\int_{4\\pi}\\sum_{i\\in\\{R,M\\}}\\beta_i^s(y)p_i(v\\cdot w)L(y,\\omega,s)d\\omegaJ[L](y,v,s)=∫4π​∑i∈{R,M}​βis​(y)pi​(v⋅w)L(y,ω,s)dω （14） 公式（12）、（13）、（14）对应上图的（a）、（b）、（c）。有了以上的函数表示，现在我们可以定义渲染方程了。 1、渲染方程 L(x,v,s)=L0(x,v,s)+R[L](x,v,s)+S[L](x,v,s)L(x,v,s)=L_0(x,v,s)+R[L](x,v,s)+S[L](x,v,s)L(x,v,s)=L0​(x,v,s)+R[L](x,v,s)+S[L](x,v,s) （15） L0(x,v,s)=T(x,x0)Lsum,or0L_0(x,v,s)=T(x,x_0)L_{sum}, or 0L0​(x,v,s)=T(x,x0​)Lsum​,or0 （16） R[L](x,v,s)=T(x,x0)I[L](x0,s)R[L](x,v,s)=T(x,x_0)I[L](x_0,s)R[L](x,v,s)=T(x,x0​)I[L](x0​,s) （17） S[L](x,v,s)=∫xx0T(x,y)J[L](y,v,s)dyS[L](x,v,s)=\\int_x^{x_0}T(x,y)J[L](y,v,s)dyS[L](x,v,s)=∫xx0​​T(x,y)J[L](y,v,s)dy （18） L(x,v,s)L(x,v,s)L(x,v,s)为视点xxx从方向vvv接收的总的辐射度。L0L_0L0​是到达xxx的太阳直射光，因此当视线vvv与太阳方向向量sss不相等时L0L_0L0​为0（又或者太阳被遮挡了）。R[L]R[L]R[L]是在点x0x_0x0​收到的反射的辐射度。S[L]S[L]S[L]则是从x0x_0x0​到xxx路径上接收的内散射光。从渲染方程可以看出，衰减因子TTT无处不在，这是因为在大气层内，涉及到光线的传播都要考虑外散射以及光线被吸收的影响。 这个渲染方程计算量非常大，尤其是公式（18），一重积分内部还嵌套了两重积分。纯粹地暴力计算对于实时渲染来说几乎不可能。为了能够实现实时渲染大气层，不少论文提出了查找表的优化思想，这是一种基于预先计算的优化方法。但大多数的论文都只是考虑了单重散射，我阅读的这篇论文《Precomputed Atmospheric Scattering》将多重散射也考虑进去了，提出了一种4维查找表的方法，在后面论述。除此之外，渲染方程也设计到大量的积分计算。为此，我们采用梯形法则和光线步进（Ray Marching）来快速计算数值积分。 下面的叙述部分，由于代码比较繁多，我尽量用伪代码描述。 2、光线衰减因子 前面已经提到过，从xxx的x0x_0x0​光线衰减因子如下（实际计算中把散射系数提出积分外）： T(x,x0)=exp(−∫xx0(βReρR(y)+βMeρM(y)dy)T(x,x_0)=exp(-\\int_x^{x_0}(\\beta_R^e\\rho_R(y)+\\beta_M^e\\rho_M(y)dy)T(x,x0​)=exp(−∫xx0​​(βRe​ρR​(y)+βMe​ρM​(y)dy) 每一帧去计算它并不现实，因此早在1994年就有人提出了查找表的优化方法。如下图所示，假设我们要计算ppp到qqq的衰减因子。iii是ppp点沿视线与大气顶层的交点。则有：ppp到iii的衰减因子=ppp到qqq的衰减因子乘上q到i的衰减因子（这里相乘的原因是决定衰减因子的光学深度是在其公式的指数位置上，衰减因子相乘等于相应的指数相加）。那么ppp到qqq的衰减因子=ppp到iii的衰减因子除以qqq到iii的衰减因子。因此只要知道点到大气顶层的衰减因子，就可计算任两点之间的光线衰减因子。 此外，O’ Neil发现了衰减因子的计算取决于两个参数:当前点的高度rrr和视线的天顶角θ\\thetaθ。也就是说我们可以通过预先计算(rrr,θ\\thetaθ)的全部组合决定的衰减因子存放到一张纹理中，后面的实时计算直接根据需要计算的(rrr,θ\\thetaθ)查找这张纹理。为了方便，我们取参数(rrr,cosθcos\\thetacosθ)，记u=cosθu=cos\\thetau=cosθ。 ① 点p到大气顶层的距离：即计算向量pipipi的长度。建立如图所示的坐标系，点OOO为地心，则向量pipipi距离点ppp为ddd的一点坐标(xxx,zzz)为:(d1−u2d\\sqrt{1-u^2}d1−u2​,r+dur+dur+du) 那么设距离ddd为向量pipipi的长度，则(xxx,zzz)即为点iii的坐标。已知大气层半径为rtopr_{top}rtop​，则由勾股定理有：(d1−u2)2+(r+du)2=rtop2(d\\sqrt{1-u^2})^2+(r+du)^2=r_{top}^2(d1−u2​)2+(r+du)2=rtop2​，整理后即为二元一次方程：d2+2rud+r2=rtop2d^2+2rud+r^2=r_{top}^2d2+2rud+r2=rtop2​，其中rrr、uuu和rtopr_{top}rtop​已知，可求出距离ddd。同样可通过该二元一次方程的判别式判断是否有解，从判断射线(rrr,uuu)是否与大气层（或地表）存在交点。 点p到地球表面交点的距离同理，将rtopr_{top}rtop​换成rbottomr_{bottom}rbottom​即可。 ② 计算点p到i（与大气顶层的交点）的光学长度：计算衰减因子需要计算点ppp到iii的光学深度，也就是对ppp到iii的散射系数和空气密度乘积进行积分。其中散射系数（包括Rayleigh散射和Mie散射）系数我们取海平面上相应的散射系数，故我们只需对ppp到iii路径的空气密度进行积分，这就是光学长度–∫piρ(s)ds\\int_p^i\\rho(s)ds∫pi​ρ(s)ds。 计算积分我们采用梯度法，以光线步进（Ray Marching）循环采样计算累加和。如下图所示，假设我们取P1P_1P1​-P5P_5P5​这五个采样点，依次计算每个点的空气密度乘上积分步长，累加计算。 计算Rayleigh光学长度和Mie光学长度均采用以上的方法计算。分别采用以上方法计算之后，再乘上相应的散射系数，就是光学深度，然后衰减因子就按照公式（12）计算即可。 ③ 坐标映射：我们把预计算的结果存入一张2D的纹理中，所以需要将(rrr,uuu)映射到纹理坐标(uru_rur​,vuv_uvu​)中。我们知道纹理坐标数值范围是[0,1][0,1][0,1]，故对于一个数值xxx，我们首先要将xxx映射到[0,1][0,1][0,1]，设xxx的值域为[min,max][min,max][min,max]。则令x=(x−min)/(max−min)x = (x-min)/(max-min)x=(x−min)/(max−min)，可将其映射到[0,1][0,1][0,1]。 然而值得注意的是，将xxx映射到[0,1][0,1][0,1]之后，边界部分我们应该要去掉。这是因为我们在对纹理进行查找时需要线性插值，边界部分会产生一些外推值。为了避免这种情况，我们进一步令xxx（此时xxx已属于[0,1][0,1][0,1]）： x=12n+x∗(1.0−1n)x=\\frac{1}{2n}+x*(1.0-\\frac{1}{n)}x=2n1​+x∗(1.0−n)1​，其中nnn是纹理的大小，1n\\frac{1}{n}n1​就是一个纹素的大小。如此我们将xxx由[0,1][0,1][0,1]映射到了[12n,1−12n][\\frac{1}{2n},1-\\frac{1}{2n}][2n1​,1−2n1​]上，去掉了边界部分。 接下来我们要将rrr映射到uuu，而uuu映射到vvv。 对于rrr，它代表当前点到地心的距离，显然其值域为[rbottom,rtop][r_{bottom},r_{top}][rbottom​,rtop​]。然而为了更高的精度（避免r接近地表时失真），我们采用了一个非线性映射的方式。如下图所示，实际上对于每个不同rrr，都对应着一个不同的ρ\\rhoρ，它是视点ppp到过视点的与地表相切的切线的切点的距离，ρ\\rhoρ的最大值则是如下图中的HHH（最小值为000）。故对于rrr我们采用该映射方式映射到uru_rur​：ur=ρHu_r=\\frac{\\rho}{H}ur​=Hρ​。 对于天顶角uuu，每个特定的天顶角，都对应着不同的距离ddd（视点到大气顶层交点的距离）。ddd的下界为r−rbottomr-r_{bottom}r−rbottom​，上界为为ρ+H\\rho+Hρ+H。故其映射方式为：vu=d−dmindmax−dminv_u=\\frac{d-d_{min}}{d_{max}-d_{min}}vu​=dmax​−dmin​d−dmin​​。 至于计算(ρ\\rhoρ,HHH)，可以通过两个三角形勾股定理，不再赘述。我们将(rrr,uuu)映射到2D纹理坐标，同样也需要逆过程，这将在预计算阶段用到。逆过程我们将上面的几个公式反推一下即可，也不再赘述。 ④ 点p到太阳的光线衰减因子：我们需要计算点ppp到太阳的光线衰减因子。太阳不是一个点光源，而是一个圆盘发光体。因此ppp到太阳的光线衰减因子，是以太阳圆盘为区域的衰减因子的积分。在这里我们把太阳圆盘区域上的衰减因子视作相同的常量。故该值等于衰减因子乘上太阳圆盘在水平线上部分占整个圆盘的比例。 设过视点p与地表相切的切线为l。当太阳天顶角θs\\theta_sθs​大于切线l的天顶角θh\\theta_hθh​+太阳的角半径αs\\alpha_sαs​时，这部分比例为000；当θs\\theta_sθs​小于θh−αs\\theta_h-\\alpha_sθh​−αs​时为111。故我们可以用相应的余弦值来定性地衡量这一比例（注意余弦函数在[0,π][0,\\pi][0,π]递减）。 当cosθs≤cos(θh+αs)≈cosθh−αssinθhcos\\theta_s\\leq cos(\\theta_h+\\alpha_s)\\approx cos\\theta_h-\\alpha_s sin\\theta_hcosθs​≤cos(θh​+αs​)≈cosθh​−αs​sinθh​时，为000；（约等符号是因为αs→0\\alpha_s→0αs​→0) 当cosθs≥cos(θh−αs)≈cosθh+αssinθhcos\\theta_s\\geq cos(\\theta_h-\\alpha_s)\\approx cos\\theta_h+\\alpha_s sin\\theta_hcosθs​≥cos(θh​−αs​)≈cosθh​+αs​sinθh​时，为111。 中间部分则用埃尔米特（Hermite）插值，可直接用GLSL的smoothstep函数。 3、单重散射 单重散射是指光线在到达视点之前只发生了一次散射。接下来将叙述如何计算单重散射，如何将其映射到3D纹理上。如下图，uuu是视点ppp处实现的天顶角的coscoscos值，假设太阳到达qqq点发生了散射，pqpqpq的距离为ddd，usu_sus​是太阳光方向向量在ppp处的天顶角coscoscos值，wsw_sws​是太阳光方向向量，vvv是太阳光方向向量与视线pqpqpq夹角的coscoscos值，us,du_{s,d}us,d​是太阳光方向向量在qqq处的天顶角coscoscos值。rrr是点ppp到地心的距离，rdr_drd​是点qqq到地心的距离。 到达p点的内散射辐射度为： Linscatter=∫PiLsun⋅e−T(A(s)→P(s))⋅(βRse−h(s)HRpR(θ)+βMse−h(s)HMpM(θ))dsL_{inscatter}=\\int_P^iL_{sun}\\cdot e^{-T(A(s)\\to P(s))}\\cdot(\\beta_R^se^{-\\frac{h(s)}{H_R}}p_R(\\theta)+\\beta_M^se^{-\\frac{h(s)}{H_M}}p_M(\\theta))dsLinscatter​=∫Pi​Lsun​⋅e−T(A(s)→P(s))⋅(βRs​e−HR​h(s)​pR​(θ)+βMs​e−HM​h(s)​pM​(θ))ds 其中的LsunL_{sun}Lsun​和两个相位函数我们先不管，计算内散射辐射度我们需要多p到大气顶层交点之间对光线衰减因子和空气密度进行积分。以上图积分点qqq为例，我们需要qqq到太阳的光线衰减因子、ppp到qqq的光线衰减因子，而这两个值可直接借助查找我们前面已经计算好的纹理获得。故对一个积分采样点，其积分函数值计算的伪代码如下。 ① 内散射积分：同样地，我们采用梯度法和光线步进法进行积分。积分路径的终端实际上不一定是大气顶层，有可能是地表，但积分过程都是一样。 ② 相位函数：对于Rayleigh相位函数和Mie相位函数，直接分别套用公式（3）和公式（5）。 ③ 坐标映射:计算单重散射积分同样非常耗费性能。因此我们一样使用预计算查找表的方法计算单重散射积分。与光线衰减因子不同的是，单重散射积分取决于四个参数，就是前面提到的(rrr,uuu,usu_sus​,vvv)，这意味着我们需要将这四个参数映射到4D纹理坐标。 对于(r,u)(r,u)(r,u)的坐标映射，与前面的提到的映射方法相同，这里不再赘述。 对于vvv，其值域为[−1,1][-1,1][−1,1]，我们做简单的线性映射，令uv=1+v2u_v=\\frac{1+v}{2}uv​=21+v​。 对于usu_sus​，通过非线性映射，如下所示（原因不明）： a=d−dmindmax−dmina=\\frac{d-d_{min}}{d_{max}-d_{min}}a=dmax​−dmin​d−dmin​​， A=−2.0usminrbottomdmax−dminA=\\frac{-2.0u_{s_min}r_{bottom}}{d_{max}-d_{min}}A=dmax​−dmin​−2.0usm​in​rbottom​​， uus=max(1.0−aA,0.0)1.0+au_{u_s}=\\frac{max(1.0-\\frac{a}{A},0.0)}{1.0+a}uus​​=1.0+amax(1.0−Aa​,0.0)​ 而逆过程则直接根据上述公式倒推即可。现在我们把(rrr,uuu,usu_sus​,vvv)映射到了4D纹理坐标，然而实际上纹理维度最多3D。故映射到4D之后，我们还要将4D坐标映射到3D坐标。为此，我们可通过取整、取模来实现。 4、多重散射 在考虑多重散射的时候，渲染方程就变为： L=L0+L1+L2+...=L0+L∗L=L_0+L_1+L_2+...=L_0+L_*L=L0​+L1​+L2​+...=L0​+L∗​ （18） 其中LiL_iLi​代表光线散射iii重。事实上，在白天的时候多重散射的效果微乎其微，而在傍晚的时候效果较为明显一点。因此实现多重散射是性价比非常低的事情，计算量比单重散射多很多，但是渲染的提升效果可以说是非常小了。 多重散射的来源有两个：一个是经过(n−1)(n-1)(n−1)次散射之后再发生了一次散射，而另一个是从地面的反射的光线。在这里我们先暂时不讨论地面的反射。多重散射可以分解成222重散射、333重散射、444重散射…等等nnn重散射的累加和。而且，第iii重散射可以根据第i−1i-1i−1重散射计算得到。 先讨论视点ppp接收到的第nnn重散射，设视点ppp沿视线vvv的终端为iii，qqq为路径pipipi上的任意一点。对于qqq点，我们要计算qqq点接收的经过n−1n-1n−1重散射（第nnn重散射时发生内散射，射向视点）的辐射度，这需要对整个球体方向进行积分，是二重积分的计算量。然后我们需要对路径pipipi上所有的qqq点（qqq点是pipipi上的一点）进行积分，是一重积分的计算量。由此我们可以知道，计算第nnn重散射，一重积分里面嵌套了两重积分，为三重积分的计算量。如果对于每一重散射的计算，都从头开始的话，这必然导致很大的计算量，而且有不少重复的计算。 为此，对于多重散射，我们采用迭代的方式来一重一重地计算，而且同样采用查找表的优化方法。每计算一重散射，我们把结果存储到纹理中，然后下一重的散射计算就直接查找这个纹理。如此，我们通过迭代的方式避免前一重的散射计算。 然而即便如此，以三重积分的方式计算第n重散射依然存在着不少重复的部分。如下图所示，设LLL为qqq点接收的经过n−1n-1n−1重散射最后第nnn重散射到−w-w−w方向的总的光线辐射度。如果以三重积分计算nnn重散射，那么在ppp点和p’p’p’点都会重复地计算到LLL。事实上，对于ppp点到qqq点之间所有的点，都会重复地计算LLL。显然，为了性能考虑，我们必须避免这一重复的部分。以空间换时间是个不错的方法。 最终，对于计算nnn重散射我们分两步走： 第一步：对于ppp点沿视线www上的每一个点qqq，我们计算qqq点接收的经过n−1n-1n−1重散射的辐射度，这需要两重积分； 第二步：在ppp点沿视线www的路径上，计算第nnn重散射，我们查找第一步计算得到的纹理，这只需单重积分。 ① 第一步：计算qqq点接收的经过n−1n-1n−1重散射的光线（第nnn重散射射向−w-w−w）。 如下所示，对于所有可能的方向wiw_iwi​，我们需要计算从wiw_iwi​方向接收的入射辐射度LiL_iLi​。LiL_iLi​由两部分组成：一部分是n−1n-1n−1重散射的辐射度（可以直接查找n−1n-1n−1重散射的纹理得到）；另一部分是当射线wiw_iwi​与地面相交时，我们需要考虑地面的反射辐射度。 n−1n-1n−1重散射辐射度由前面的迭代计算得到，不再讨论。我们需要重点讨论的是地面的反射辐射度。设射线(qqq,wiw_iwi​)与地面的交点为rrr，那么从地面接收的反射辐射度应该是以下几项的乘积： 点qqq和点rrr之间的光线衰减因子； 地面的平均反照率； 地面的Lambertian BRDF函数的1/π1/\\pi1/π； 地面接收的经过n−2n-2n−2次散射辐照度，这是个半球方向的积分，我们将在后面讨论，现在假设我们已经可以计算得到。 ② 第二步：第二步就是利用第一步的计算结果进行单次积分。在ppp点沿视线www的路径上，计算第nnn重散射，我们查找第一步计算得到的纹理。对于ppp到边界交点的每一个点qqq，设qqq计算得到的n−1n-1n−1重散射密度为LLL，则由qqq到ppp的辐射度应该再乘上一个qqq到ppp之间的光线衰减因子。 同样的，我们采用梯度法和光线步进计算ppp到边界路径上的黎曼和。 ③ 坐标映射：与单重散射一样。 5、地面辐照度 地面接收的辐照度是直接辐照度、单重散射或多重散射之后接收的辐照度总和，我们分为直接辐照度和间接辐照度。计算地面接收的辐照度有以下两个目的： 计算nnn重散射的时候，我们需要考虑从地面反射的辐射度； 渲染地面的需要。 ① 直接辐照度：太阳光线直达地面，中间不发生的散射（但是会向外散射导致光强减弱），所以我们将太阳的辐射度乘上地面到大气顶层的光线衰减因子即可。同时，值得注意的是太阳是一个圆盘，我们还需要考虑太阳可见圆盘的比例，这在前面已经讨论过了。比较简单，直接贴代码了。 ② 间接辐照度：间接辐照度考虑单重及多重散射，如下所示，我们需要对以地面法线为轴向的半球方向进行积分。 5、预计算 有了以上的铺垫，我们现在可以将光线衰减因子、单重散射、多重散射以及地面辐照度预先计算到纹理中，然后渲染的时候直接根据相应的参数去查找纹理（需要纹理坐标的映射）从而获取相应的值，如此在渲染时省去了大量的计算，这带来了非常大的性能提升。 实验结果 演示的是一个非常简单的场景，地球以及地球表面上的球体。由于仅仅只有两个球体，那么绘制轮廓部分用光线追踪的办法是非常简单的，而且在片元着色器也很容易实现，只需求解几个二元一次方程即可。而光照部分则是查找前面已经计算好的散射纹理。 ① 实验平台: 操作系统: Windows8.1 IDE: Qt Creator 语言: C++ API: OpenGL3.3+, Qt 5.7 ② 可调参数: 太阳光谱:选择常量值还是真实值（通过真实的太阳光谱线性插值） 臭氧层:是否开启臭氧层（臭氧层也会吸收一部分光线） 散射重数:最低为111（即只考虑单重散射） 体积光:是否开启丁达尔效应 Rayleigh散射:是否开启rayleigh散射 Mie散射:是否开启Mie散射 Mie散射对称系数:控制Mie散射的方向性，为正则向后散射，为负则向前散射 ③ 实验结果： 1）、首先，把Rayleigh散射和Mie散射都关闭了，也就是说相当于没有大气层的存在，和月球上的情况相似，所以天空不再是蓝色而是黑色（直接看到外太空了），太阳周围也不会出现光晕。而且由于没有散射，那么阴影部分（非太阳直射的地方）将完全漆黑。 2）、现在把Rayleigh散射和Mie散射都开启。 3）、仅开启Rayleig散射，这时由于没有Mie散射，也就是我们剔除了气溶胶的作用，天空的朦胧感降为000，天空看着很清澈，这与我们的生活经验一致。 4）、而如果仅开启Mie散射，那么天空不会呈现蓝色，而是呈现如下情况。可以看出，Mie散射呈现的是一种丁达尔效应的朦胧感。 5）、单重散射、多重散射的对比。实现的最大难度在于多重散射，需要编写大量的代码，而且占用更多的空间，但是提升的效果其实很小。如下图。 对比上面的几张图，可以看到其实单重散射的效果已经非常不错了。而且散射重数多了其实区别也不大。 6）、体积光效果：体积光效果是大气光效渲染比较复杂的一个方面，但是实现的话看起来是很令人震撼的。遗憾的是，论文作者提出的体积光实现是基于阴影体的，简单场景没什么问题，但是比较复杂的就不太现实了。 7）、Mie散射对称系数:控制Mie散射的方向性，为正则向后散射，为负则向前散射。为正时越大向后散射得越多。 8）、调整曝光率可以出现一些有趣的光效。 9）、一些从外太空观察的效果。 此外，值得注意的是，渲染的速度非常快，FPS稳定在606060。基于预先计算的查找表的优化方法把渲染时大量的计算挪到程序启动的初始阶段，而且开始阶段耗费时间也不多，最多两三秒。对于散射重数低于101010的，几乎是秒开。 参考文献 1、《Precomputed Atmospheric Scattering》 2、《SIGGRAPH 2009 - Lighting Research at Bungie》 3、《基于GPU的实时大气散射渲染优化算法研究与实现_方辰》 4、《PreethamSig2003CourseNotes》 5、《数字地球大气散射的GPU实现》 6、《基于GPU的行星大气散射效果实时渲染技术研究_刘维敏》 7、《基于GPU的地球大气散射现象可视化仿真_杜芳》 8、《多重散射的天空光照效果建模与实时绘制_艾祖亮》","categories":[{"name":"Computer Graphics","slug":"Computer-Graphics","permalink":"http://yoursite.com/categories/Computer-Graphics/"}],"tags":[{"name":"Computer Graphics","slug":"Computer-Graphics","permalink":"http://yoursite.com/tags/Computer-Graphics/"},{"name":"Atomsphere Rendering","slug":"Atomsphere-Rendering","permalink":"http://yoursite.com/tags/Atomsphere-Rendering/"},{"name":"BRDF","slug":"BRDF","permalink":"http://yoursite.com/tags/BRDF/"}]},{"title":"流体模拟基础","slug":"fluidSimulation","date":"2019-04-25T11:05:00.167Z","updated":"2019-04-29T11:10:04.252Z","comments":true,"path":"2019/04/25/fluidSimulation/","link":"","permalink":"http://yoursite.com/2019/04/25/fluidSimulation/","excerpt":"本文主要参考文献《FLUID SIMULATION SIGGRAPH 2007 Course Notes》，结合我的理解单纯地讲述一下流体渲染的一些基础知识，本人水平有限，如有错误，欢迎指出。本文只是单纯针对流体模拟领域，可能一些地方不太严谨，但是对于虚拟模拟来说是可行的。即便如此，本文涉及到大量的数学方法。","text":"本文主要参考文献《FLUID SIMULATION SIGGRAPH 2007 Course Notes》，结合我的理解单纯地讲述一下流体渲染的一些基础知识，本人水平有限，如有错误，欢迎指出。本文只是单纯针对流体模拟领域，可能一些地方不太严谨，但是对于虚拟模拟来说是可行的。即便如此，本文涉及到大量的数学方法。 矢量微积分 Naiver-Stokes偏微分方程组 N-S方程的分步求解 对流算法 一、矢量微积分 高等数学中太多数讨论的是一维的微积分，而矢量微积分则是一维微积分的高维扩展。矢量微积分的三个基础算子：梯度（符号为∇∇∇），散度（符号为∇⋅∇\\cdot∇⋅)，旋度（符号为∇×∇\\times∇×），在此基础上流体力学中经常用到的还有拉普拉斯算子。 1、梯度（Gradient） 梯度实际上就是矢量的空间偏导数，且结果依然是一个矢量，222维的梯度如下： (1.1)∇f(x,y)=(∂f∂x,∂f∂y)∇f(x,y)=(\\frac{\\partial f}{\\partial x},\\frac{\\partial f}{\\partial y}) \\tag {1.1} ∇f(x,y)=(∂x∂f​,∂y∂f​)(1.1) 依此类推，333维的梯度有如下形式： (1.2)∇f(x,y,z)=(∂f∂x,∂f∂y,∂f∂z)∇f(x,y,z)=(\\frac{\\partial f}{\\partial x},\\frac{\\partial f}{\\partial y},\\frac{\\partial f}{\\partial z}) \\tag {1.2} ∇f(x,y,z)=(∂x∂f​,∂y∂f​,∂z∂f​)(1.2) 有时也会采用如下形式来表示梯度： (1.3)∇f=∂f∂x⃗∇f=\\frac{\\partial f}{\\partial \\vec x} \\tag {1.3} ∇f=∂x∂f​(1.3) 梯度通常用来近似计算函数值（实际上就是一维形式的推广)： (1.4)f(x⃗+Δx⃗)≈f(x⃗)+∇f(x⃗)⋅Δx⃗f(\\vec x+\\Delta \\vec x)\\approx f(\\vec x)+∇f(\\vec x)\\cdot \\Delta \\vec x \\tag {1.4} f(x+Δx)≈f(x)+∇f(x)⋅Δx(1.4) 同样的，多个函数的梯度就构成了一个矩阵： (1.5)∇F⃗=∇(f,g,h)=(∂f∂x∂f∂y∂f∂z∂g∂x∂g∂y∂g∂z∂h∂x∂h∂y∂h∂z)=(∇f∇g∇h)∇\\vec F=∇(f,g,h)=\\left( \\begin{matrix} \\frac{\\partial f}{\\partial x} &amp; \\frac{\\partial f}{\\partial y} &amp; \\frac{\\partial f}{\\partial z} \\\\ \\frac{\\partial g}{\\partial x} &amp; \\frac{\\partial g}{\\partial y} &amp; \\frac{\\partial g}{\\partial z} \\\\ \\frac{\\partial h}{\\partial x} &amp; \\frac{\\partial h}{\\partial y} &amp; \\frac{\\partial h}{\\partial z} \\\\ \\end{matrix} \\right) =\\left( \\begin{matrix}∇f\\\\ ∇g\\\\ ∇h\\\\ \\end{matrix} \\right) \\tag {1.5} ∇F=∇(f,g,h)=⎝⎜⎛​∂x∂f​∂x∂g​∂x∂h​​∂y∂f​∂y∂g​∂y∂h​​∂z∂f​∂z∂g​∂z∂h​​⎠⎟⎞​=⎝⎛​∇f∇g∇h​⎠⎞​(1.5) 2、散度（Divergence） 散度算子仅仅应用于向量场，它衡量在某一点出相应的矢量聚集或者发散程度，测量方向为径向，结果为标量。222维、333维形式的散度算子如下所示： ∇⋅u⃗=∇⋅(u,v)=∂u∂x+∂v∂y∇\\cdot \\vec u=∇\\cdot (u,v)=\\frac{\\partial u}{\\partial x}+\\frac{\\partial v}{\\partial y} ∇⋅u=∇⋅(u,v)=∂x∂u​+∂y∂v​ (1.6)∇⋅u⃗=∇⋅(u,v,w)=∂u∂x+∂v∂y+∂w∂z∇\\cdot \\vec u=∇\\cdot (u,v,w)=\\frac{\\partial u}{\\partial x}+\\frac{\\partial v}{\\partial y}+\\frac{\\partial w}{\\partial z} \\tag {1.6} ∇⋅u=∇⋅(u,v,w)=∂x∂u​+∂y∂v​+∂z∂w​(1.6) 输入是矢量，而输出为标量。类比梯度，散度符号∇⋅u⃗∇\\cdot \\vec u∇⋅u可以理解为梯度∇∇∇与矢量u⃗\\vec uu的点乘： (1.7)∇⋅u⃗=(∂∂x,∂∂y,∂∂z)⋅(u,v,w)=∂∂xu+∂∂yv+∂∂zw∇\\cdot \\vec u=(\\frac{\\partial}{\\partial x},\\frac{\\partial}{\\partial y},\\frac{\\partial}{\\partial z})\\cdot (u,v,w)=\\frac{\\partial}{\\partial x}u+\\frac{\\partial}{\\partial y}v+\\frac{\\partial}{\\partial z}w \\tag {1.7} ∇⋅u=(∂x∂​,∂y∂​,∂z∂​)⋅(u,v,w)=∂x∂​u+∂y∂​v+∂z∂​w(1.7) 若矢量场散度为000，则称该矢量场无散度。 3、旋度（Curl） 旋度衡量围绕某一点的旋转速度，测量方向为切向，三维形式的旋度是一个向量： (1.8)∇×u⃗=∇×(u,v,w)=(∂w∂y−∂v∂z,∂u∂z−∂w∂x,∂v∂x−∂u∂y)∇\\times \\vec u=∇\\times (u,v,w) =(\\frac{\\partial w}{\\partial y}-\\frac{\\partial v}{\\partial z}, \\frac{\\partial u}{\\partial z}-\\frac{\\partial w}{\\partial x}, \\frac{\\partial v}{\\partial x}-\\frac{\\partial u}{\\partial y}) \\tag {1.8} ∇×u=∇×(u,v,w)=(∂y∂w​−∂z∂v​,∂z∂u​−∂x∂w​,∂x∂v​−∂y∂u​)(1.8) 倒推到222维，我们取上式中的w=0w=0w=0，即矢量场为(u,v,0)(u,v,0)(u,v,0)，222维向量场的旋度是一个标量： (1.9)∇×u⃗=∇×(u,v)=∂v∂x−∂u∂y∇\\times \\vec u=∇\\times (u,v)=\\frac{\\partial v}{\\partial x}-\\frac{\\partial u}{\\partial y} \\tag {1.9} ∇×u=∇×(u,v)=∂x∂v​−∂y∂u​(1.9) 同样地，旋度符号∇×u⃗∇\\times \\vec u∇×u我们可以理解为梯度∇∇∇与矢量场u⃗\\vec uu的叉乘： (1.10)∇×u⃗=(∂∂x,∂∂y,∂∂z)×(u,v,w)∇\\times \\vec u= (\\frac{\\partial }{\\partial x}, \\frac{\\partial }{\\partial y}, \\frac{\\partial }{\\partial z})\\times(u,v,w) \\tag {1.10} ∇×u=(∂x∂​,∂y∂​,∂z∂​)×(u,v,w)(1.10) 若矢量场旋度为000，则称该矢量场无旋度。 4、拉普拉斯算子（Laplacian） 拉普拉斯算子定义为梯度的散度，符号表示为∇⋅∇∇\\cdot∇∇⋅∇，显然∇⋅∇\\cdot∇⋅是散度，而后面的∇∇∇则为梯度，故拉普拉斯算子即梯度的散度，是一个二阶微分算子。222维、333维形式分别如下： ∇⋅∇f=∂2f∂x2+∂2f∂y2∇\\cdot∇f=\\frac{\\partial^2f}{\\partial x^2}+\\frac{\\partial^2f}{\\partial y^2} ∇⋅∇f=∂x2∂2f​+∂y2∂2f​ (1.11)∇⋅∇f=∂2f∂x2+∂2f∂y2+∂2f∂z2∇\\cdot∇f=\\frac{\\partial^2f}{\\partial x^2}+\\frac{\\partial^2f}{\\partial y^2}+\\frac{\\partial^2f}{\\partial z^2} \\tag {1.11} ∇⋅∇f=∂x2∂2f​+∂y2∂2f​+∂z2∂2f​(1.11) 简言之，拉普拉斯算子定义如下： (1.12)∇⋅∇f=Σi=1n∂2f∂xi2∇\\cdot∇f=\\Sigma_{i=1}^n\\frac{\\partial^2f}{\\partial x_i^2} \\tag {1.12} ∇⋅∇f=Σi=1n​∂xi2​∂2f​(1.12) 偏微分方程∇⋅∇f=0∇\\cdot ∇f=0∇⋅∇f=0被称为拉普拉斯方程；而如果右边为某个非000常数，即∇⋅∇f=q∇\\cdot ∇f=q∇⋅∇f=q，我们称之为泊松方程。更一般地，如果梯度再乘上一个标量aaa（如1/ρ1/\\rho1/ρ)，即∇⋅(a∇f)=q∇\\cdot (a∇f)=q∇⋅(a∇f)=q，我们依旧称之为泊松问题。 二、Naiver−StokesNaiver-StokesNaiver−Stokes偏微分方程组 流体模拟器的构建主要围绕著名的不可压缩Navier−StokesNavier-StokesNavier−Stokes方程展开，它是一个流体力学领域的偏微分方程，方程形式如下： (2.1)∂u⃗∂t+u⃗⋅∇u⃗+1ρ∇p=g⃗+ν∇⋅∇u⃗\\frac{\\partial \\vec u}{\\partial t}+\\vec u\\cdot ∇\\vec u+\\frac1\\rho∇p=\\vec g+\\nu∇\\cdot∇\\vec u \\tag {2.1} ∂t∂u​+u⋅∇u+ρ1​∇p=g​+ν∇⋅∇u(2.1) (2.2)∇⋅u⃗=0∇\\cdot\\vec u=0 \\tag {2.2} ∇⋅u=0(2.2) 这个方程组看起非常地复杂，接下来我们就把它剖析成一个个比较简单的部分来理解。 1、符号标记 我们有必要定义一些物理量的符号用以标记： 符号u⃗\\vec uu在流体力学中通常表示为流体的速度矢量，记333维的速度矢量u⃗=(u,v,w)\\vec u=(u,v,w)u=(u,v,w)； 希腊字符ρ\\rhoρ是流体的密度，对于水，该值大约为1000kg/m31000kg/m^31000kg/m3，而空气则大约为1.3kg/m31.3kg/m^31.3kg/m3； 字符ppp代表压力，流体对任何物体施加的单位面积力； 字符g⃗\\vec gg​则是我们熟悉的重力加速度，通常取(0,−9.81,0)m/s2(0,-9.81,0)m/s^2(0,−9.81,0)m/s2。我们约定yyy轴向上，而xxx轴和zzz轴在水平面上。另外补充一点，我们把其他的一些类似的力都累加到g⃗\\vec gg​上，也就是我们统一用g⃗\\vec gg​表示所有类似力之和，这类力我们称之为体积力（称之为体积力是因为它们的力是作用到整个流体而不只是流体的表面）； 希腊字符ν\\nuν是流体的运动粘度，它衡量流体的黏滞性。糖蜜之类的流体有非常高的粘度，而像酒精之类的流体有很低的粘度； 其它一些矢量微积分的符号算子前面已经提到过，不再赘述。 2、动量方程 偏微分方程(2.1)(2.1)(2.1)我们称之为动量方程，它本质上就是我们熟悉的牛顿定律F⃗=ma⃗\\vec F=m\\vec aF=ma的形式，描述了施加在流体上的力是如何影响流体的运动。 假设我们用粒子系统来模拟流体，每个粒子代表流体的一小滴，每个粒子有各自的质量mmm、体积VVV和速度u⃗\\vec uu。为了让整个粒子系统运作起来，我们必须弄清楚每个粒子所承受的力的作用。牛顿第二定律告诉我们：F⃗=ma⃗\\vec F=m\\vec aF=ma，而根据加速度定义，我们有： (2.3)a⃗=Du⃗Dt\\vec a=\\frac{D\\vec u}{Dt} \\tag {2.3} a=DtDu​(2.3) 符号DDD是指物质导数，所谓物质导数，就是对流体质点求导数，而且是针对流体质点（在这里就是流体粒子）而不是空间的固定点。因而牛顿第二定律就变成： (2.4)mDu⃗Dt=F⃗m\\frac{D\\vec u}{Dt}=\\vec F \\tag {2.4} mDtDu​=F(2.4) 那么流体粒子承受的力有哪些呢？一个最简单的力就是重力：mg⃗m\\vec gmg​。而其他的流体质点（或其他流体粒子）也会对当前的流体粒子产生作用力。流体内部的相互作用力之一便是压力，较大压力的区域会向较低压力区域产生作用力。值得注意的是，我们只关注施加在粒子上的压力的净合力。例如，若施加在粒子上压力在每个方向上都相等，那么它的压力的合力便为0。我们用压力的负梯度（取负是因为方向是由压力大的区域指向压力小的区域）来衡量在当前流体粒子处压力的不平衡性，即取−∇p-∇p−∇p。那么流体粒子所承受的压力就是对−∇p-∇p−∇p在整个流体粒子的体积上进行积分，为了简化，我们简单地将VVV与−∇p-∇p−∇p相乘，故粒子压力部分为−V∇p-V∇p−V∇p。 其他的流体相互作用力则是由流体的黏性产生的，我们直观地把这种力理解为尽可能使得粒子以周围区域的平均速度移动的力，也就是使得粒子的速度与周围区域粒子速度的差距最小化。拉普拉斯算子是衡量一个量与之周围区域该量平均值之差的算符，因而∇⋅∇u⃗∇\\cdot∇\\vec u∇⋅∇u是当前粒子速度矢量与周围区域平均速度矢量之差。为了计算粘滞力，我们同样对∇⋅∇u⃗∇\\cdot∇\\vec u∇⋅∇u在整个粒子体积VVV上进行积分，与前面类似，我们简单取V∇⋅∇u⃗V∇\\cdot∇\\vec uV∇⋅∇u。除此之外，我们还引进一个称为动力粘度系数的物理量，符号为μ\\muμ。因而粘滞力为Vμ∇⋅∇u⃗V\\mu∇\\cdot∇\\vec uVμ∇⋅∇u。 把重力、压力和粘滞力综合一起，我们可得： (2.5)mDu⃗Dt=F⃗=mg⃗−V∇p+Vμ∇⋅∇u⃗m\\frac{D\\vec u}{Dt}=\\vec F=m\\vec g-V∇p+V\\mu∇\\cdot∇\\vec u \\tag {2.5} mDtDu​=F=mg​−V∇p+Vμ∇⋅∇u(2.5) 当粒子系统中的粒子数量趋于无穷大，而每个粒子大小趋于000时，会产生一个问题：此时每个粒子的质量mmm和体积VVV变为000，此时上式变得没有意义。为此，我们把(2.5)(2.5)(2.5)式调整一下，两边同除以体积VVV，又因ρ=m/V\\rho=m/Vρ=m/V，故有： (2.6)ρDu⃗Dt=ρg⃗−∇p+μ∇⋅∇u⃗\\rho\\frac{D\\vec u}{Dt}=\\rho\\vec g-∇p+\\mu∇\\cdot∇\\vec u \\tag {2.6} ρDtDu​=ρg​−∇p+μ∇⋅∇u(2.6) 两边同除以ρ\\rhoρ，移项调整： (2.7)Du⃗Dt+1ρ∇p=g⃗+μρ∇⋅∇u⃗\\frac{D\\vec u}{Dt}+\\frac1\\rho∇p=\\vec g+\\frac\\mu\\rho∇\\cdot∇\\vec u \\tag {2.7} DtDu​+ρ1​∇p=g​+ρμ​∇⋅∇u(2.7) 为了进一步简化，定义运动粘度为ν=μ/ρ\\nu=\\mu/\\rhoν=μ/ρ，式(2.7)(2.7)(2.7)变为： (2.8)Du⃗Dt+1ρ∇p=g⃗+ν∇⋅∇u⃗\\frac{D\\vec u}{Dt}+\\frac1\\rho∇p=\\vec g+\\nu∇\\cdot∇\\vec u \\tag {2.8} DtDu​+ρ1​∇p=g​+ν∇⋅∇u(2.8) 我们已经快把动量方程推导出来，现在我们要把物质导数Du⃗Dt\\frac{D\\vec u}{Dt}DtDu​弄清楚，为此，我们需要了解两种描述方法：拉格朗日描述和欧拉描述。 3、拉格朗日描述与欧拉描述 当我们尝试研究流体或可变形固体的运动的时候，通常有两种方法来描述：拉格朗日描述（ Lagrangian viewpoint）、欧拉描述（Eulerian viewpoint）。 拉格朗日描述方法是我们比较熟悉的方法，这种描述方法把物体看成是由类似于粒子系统的形式组成，固体或流体的每个点看作一个独立的粒子，粒子有各自相应的位置x⃗\\vec xx和速度u⃗\\vec uu。我们可以把粒子理解为组成物体的分子。对于我们通常采用拉格朗日描述法进行建模模拟，即用一系列离散的粒子集来构建，粒子之间通过网格相联系。 欧拉描述方法则采用了完全不同的角度，它常被用于流体力学中。与拉格朗日描述追踪每个物体粒子的方法不同，欧拉描述关注点是空间中的一个固定点，并考察在这个固定点上流体性质（如密度、速度、温度等）是如何随着时间变化的。流体流动经过这个固定点可能会导致这个固定点的物理性质发生一些变化（如一个温度较高的流体粒子流经这个固定点，后面紧跟着一个温度较低的流体粒子流过固定点，那么这个固定点的温度会降低，但是并没有任何一个流体粒子的温度发生了变化）。 用天气测量举个简单的例子：拉格朗日描述方法就是你乘坐在一个随风而飘的热气球上，测量周围空气的压力、密度和浑浊度等天气指标；而欧拉描述方法就是你固定在地面上，测量流过的空气的天气指标。 欧拉描述法似乎看起来带来了一些不必要的复杂度，但是目前大多数的流体模拟器都是基于欧拉描述法，这是因为欧拉描述法相比于拉格朗日描述法有一些不可比拟的优点：欧拉描述法能够更加方便地计算一些物理量的空间导数（例如压力梯度和粘度）；而如果用粒子方法的话（即拉格朗日描述法），那么计算物理量相对于空间位置的变化是比较难的。 把拉格朗日描述法和欧拉描述法联系起来的关键点就是物质导数。首先从拉格朗日描述法出发，假设有一群粒子，每个粒子都有各自的位置x⃗\\vec xx和速度u⃗\\vec uu。记qqq为通用的物理量（如密度、速度和温度等），每个粒子有其对应的qqq值。方程q(t,x⃗)q(t,\\vec x)q(t,x)描述在时间点ttt而位置为x⃗\\vec xx的粒子对应的物理量值qqq。则一个粒子的物理量qqq随时间ttt的变化率是多少？这是一个拉格朗日描述角度下的问题，我们取对时间ttt的导数（注意用到了求导链式法则，以及∂q∂x⃗=∇q\\frac{\\partial q}{\\partial \\vec x}=∇q∂x∂q​=∇q和u⃗=dx⃗dt）\\vec u=\\frac{d\\vec x}{dt}）u=dtdx​）： (2.9)ddtq(t,x⃗)=∂q∂t+∇q⋅dx⃗dt=∂q∂t+∇q⋅u⃗≡DqDt\\frac d{dt}q(t,\\vec x)=\\frac{\\partial q}{\\partial t}+∇q\\cdot\\frac{d\\vec x}{dt}=\\frac{\\partial q}{\\partial t}+∇q\\cdot\\vec u\\equiv\\frac{Dq}{Dt} \\tag {2.9} dtd​q(t,x)=∂t∂q​+∇q⋅dtdx​=∂t∂q​+∇q⋅u≡DtDq​(2.9) 这就是物质导数。把式(2.9)(2.9)(2.9)代入式(2.8)(2.8)(2.8)我们就得到了流体动量方程(2.1)(2.1)(2.1)。物质导数针对的是流体质点（在这里就是流体粒子）而不是空间的固定点。式(2.9)(2.9)(2.9)写完整一点就是： (2.10)DqDt=∂q∂t+u∂q∂x+v∂q∂y+w∂q∂z\\frac{Dq}{Dt}=\\frac{\\partial q}{\\partial t}+u\\frac{\\partial q}{\\partial x}+v\\frac{\\partial q}{\\partial y}+w\\frac{\\partial q}{\\partial z} \\tag {2.10} DtDq​=∂t∂q​+u∂x∂q​+v∂y∂q​+w∂z∂q​(2.10) 对于给定的速度场u⃗\\vec uu， 流体的物理性质如何在这个速度场u⃗\\vec uu下变化的计算我们称之为对流（advection）。一个最简单的对流方程，就是其物理量的物质导数为000，如下所示： (2.11)DqDt=0 ⟹ ∂q∂t+u⃗⋅∇q=0\\frac{Dq}{Dt}=0\\implies\\frac{\\partial q}{\\partial t}+\\vec u\\cdot ∇q = 0 \\tag {2.11} DtDq​=0⟹∂t∂q​+u⋅∇q=0(2.11) 公式(2.11)(2.11)(2.11)的意义即在拉格朗日视角观察下，每个流体粒子的物理量保持不变。 4、不可压缩性 关于流体的压缩性在此不做过多的物理细节描述，只需知道一点：通常情况下流体的体积变化非常小（除开一些极端的情况，而且这些极端情况我们日常生活中较少出现）。可压缩流体的模拟涉及到非常复杂的情况，往往需要昂贵的计算资源开销，为此在计算机流体模拟中我们通常把所有的流体当作是不可压缩的，即它们的体积不会发生变化。 任取流体的一部分，设其体积为Ω\\OmegaΩ而其边界闭合曲面为∂Ω\\partial\\Omega∂Ω，我们可以通过围绕边界曲面∂Ω\\partial\\Omega∂Ω对流体速度u⃗\\vec uu在曲面法线方向上的分量进行积分来衡量这块部分流体的体积变化速率： (2.12)ddtVolume(Ω)=∫∫∂Ωu⃗⋅n\\frac d{dt}Volume(\\Omega)=\\int\\int_{\\partial\\Omega}\\vec u\\cdot n \\tag{2.12} dtd​Volume(Ω)=∫∫∂Ω​u⋅n(2.12) 对于不可压缩的流体，其体积保持为某个常量，故其体积变化速率为000： (2.13)∫∫∂Ωu⃗⋅n=0\\int\\int_{\\partial\\Omega}\\vec u\\cdot n=0 \\tag {2.13} ∫∫∂Ω​u⋅n=0(2.13) 由高斯散度定理，我们可以把式(2.13)(2.13)(2.13)转换为体积分： (2.14)∫∫∂Ωu⃗⋅n=∫∫∫Ω∇⋅u⃗=0\\int\\int_{\\partial\\Omega}\\vec u\\cdot n=\\int\\int\\int_\\Omega∇\\cdot \\vec u=0 \\tag{2.14} ∫∫∂Ω​u⋅n=∫∫∫Ω​∇⋅u=0(2.14) 式(13)(13)(13)应该对任意的Ω\\OmegaΩ成立，意即无论Ω\\OmegaΩ取何值，积分值均为000。这种情况下只有令积分函数值取000方可成立，即对000积分无论Ω\\OmegaΩ取何值结果均为000。所以有： (2.15)∇⋅u⃗=0∇\\cdot \\vec u=0 \\tag{2.15} ∇⋅u=0(2.15) 这就是Navier−StokesNavier-StokesNavier−Stokes方程中的不可压缩条件(2.2)(2.2)(2.2)。满足不可压缩条件的速度场被称为是无散度的，即在该速度场下流体体积既不膨胀也不坍缩，而是保持在一个常量。模拟不可压缩流体的关键部分就是使得流体的速度场保持无散度的状态，这也是流体内部压力的来源。 为了把压力与速度场的散度联系起来，我们在动量方程(2.1)(2.1)(2.1)两边同时取散度： (2.16)∇⋅∂u⃗∂t+∇⋅(u⃗⋅∇u⃗)+∇⋅1ρ∇p=∇⋅(g⃗+ν∇⋅∇u⃗)∇\\cdot\\frac{\\partial \\vec u}{\\partial t}+∇\\cdot(\\vec u\\cdot ∇\\vec u)+∇\\cdot\\frac1\\rho∇p=∇\\cdot(\\vec g+\\nu∇\\cdot∇\\vec u) \\tag {2.16} ∇⋅∂t∂u​+∇⋅(u⋅∇u)+∇⋅ρ1​∇p=∇⋅(g​+ν∇⋅∇u)(2.16) 对于上式(2.16)(2.16)(2.16)第一项，我们转变一下求导次序： (2.17)∂∂t∇⋅u⃗\\frac {\\partial}{\\partial t}∇\\cdot\\vec u \\tag {2.17} ∂t∂​∇⋅u(2.17) 如果满足流体不可压缩条件，那么式(2.17)(2.17)(2.17)取值000（因为无散度），然后我们调整一下式(2.16)(2.16)(2.16)可得关于压力的方程： (2.18)∇⋅1ρ∇p=∇⋅(−u⃗⋅∇u⃗+g⃗+ν∇⋅∇u⃗)∇\\cdot\\frac1\\rho∇p=∇\\cdot(-\\vec u\\cdot ∇\\vec u+\\vec g+\\nu∇\\cdot∇\\vec u) \\tag{2.18} ∇⋅ρ1​∇p=∇⋅(−u⋅∇u+g​+ν∇⋅∇u)(2.18) 5、丢弃粘度项 在某些流体如蜂蜜、小水珠等的模拟中，粘滞力起着非常重要的作用。但是在大多数流体动画模拟中，粘滞力的影响微乎其微，为此秉持着方程组越简单越好的原则，我们常常丢弃粘度项。当然这也不可避免地带来一些误差，事实上，在计算流体力学中尽可能地减少丢弃粘度项带来的误差是一个非常大的挑战。下面的叙述都是基于丢弃粘度项的前提。 丢弃了粘度项的Navier−StokesNavier-StokesNavier−Stokes方程被称为欧拉方程，而这种理想的流体则是无粘度的。丢弃了粘度项的欧拉方程如下： (2.19)Du⃗Dt+1ρ∇p=g⃗\\frac{D\\vec u}{Dt}+\\frac1\\rho∇p=\\vec g \\tag {2.19} DtDu​+ρ1​∇p=g​(2.19) (2.20)∇⋅u⃗=0∇\\cdot\\vec u=0 \\tag{2.20} ∇⋅u=0(2.20) 大多数的流体模拟的计算方程都是欧拉方程。 6、边界条件 目前为止我们讨论的都是流体内部的情况，然而边界部分也是流体模拟非常关键的部分。在流体模拟中我们仅仅关注两种边界条件：固体墙（solid walls）、自由面（free surfaces）。 固体墙顾名思义就是流体与固体接触的边界，用速度来描述很简单：流体既不会流进固体内部也不会从固体内部流出，因此流体在固体墙法线方向上的分量为000： (2.21)u⃗⋅n=0\\vec u\\cdot n=0 \\tag {2.21} u⋅n=0(2.21) 当然，上述是固体自身不移动的情况下。通常来说，流体速度在法线方向上的分量与固体的移动速度在法线方向上的分量应该保持一致： (2.22)u⃗⋅n=u⃗solid⋅n\\vec u\\cdot n=\\vec u_{solid}\\cdot n \\tag{2.22} u⋅n=usolid​⋅n(2.22) 上述的两个公式都是仅对流体速度在法线方向上的分量做了限制，对于无粘度的流体，切线方向上的流体速度与固体的移动速度无必然的联系。 自由面是另外一个非常重要的边界条件，它通常就是与另外一种流体相接壤的边界部分。例如在模拟水花四溅时，水流表面不与固体接触的都是自由面（如与空气这种流体接触）。因空气密度远小于水导致空气对水体的仿真影响非常小，为了简化模拟，我们将空气所占的空间设为某个固定大气压的区域，设为000是最方便的方案，此时自由面就是压强p=0p=0p=0的水体表面。 在小规模的流体仿真中，自由面的表面张力占据着非常重要的地位。在微观分子层面下，表面张力的存在是因为不同的分子相互吸引产生的力。从几何的角度来解释就是，表面张力就是促使流体的表面积尽可能小的一种力。物理学上，两种不同的流体之间实际上存在着与表面平均曲率成正比的压力骤变： (2.23)[p]=λk.[p]=\\lambda k. \\tag {2.23} [p]=λk.(2.23) 公式(2.23)(2.23)(2.23)中的[p][p][p]记为压力之差。λ\\lambdaλ是表面张力系数，可以根据模拟的流体类型查找对应的张力系数（例如空气与水在室温下张力系数为λ≈0.073N/m\\lambda \\approx 0.073N/mλ≈0.073N/m）。而kkk就是平均曲率，单位为m−1m^{-1}m−1。又因为我们常常设空气的压力为000，因此水与空气交界的自由面的压力为： (2.24)p=λkp=\\lambda k \\tag {2.24} p=λk(2.24) ​ 三、N-S方程的分步求解 有了对以上对Navier−StokesNavier-StokesNavier−Stokes方程的理论支撑，接下来我们就要如何用计算机来对该组偏微分方程进行离散化求解。为了程序的松耦合性以及使计算尽可能地高效、简单，在流体模型领域，我们将流体方程分成几个独立的步骤，然后按顺序先后推进。对于不可压缩的无粘度流体方程（即前面的欧拉方程(2.19)(2.19)(2.19)和(2.20)(2.20)(2.20)，我们将其离散化成对流项（advection）如公式(3.1)(3.1)(3.1)、体积力项（body force）如公式(3.2)(3.2)(3.2)、压力/不可压缩项如公式(3.3)(3.3)(3.3)： (3.1)DqDt=0\\frac{Dq}{Dt}=0 \\tag {3.1} DtDq​=0(3.1) (3.2)∂u⃗∂t=g⃗\\frac{\\partial \\vec u}{\\partial t}=\\vec g \\tag {3.2} ∂t∂u​=g​(3.2) (3.3){∂u⃗∂t+1ρ∇p=0∇⋅u⃗=0\\begin{cases} \\frac{\\partial \\vec u}{\\partial t}+\\frac{1}{\\rho}∇p=0\\\\ ∇\\cdot\\vec u=0 \\end{cases} \\tag {3.3} {∂t∂u​+ρ1​∇p=0∇⋅u=0​(3.3) 需要注意的是，在对流项公式(3.1)(3.1)(3.1)中我们用了一个通用量的符号qqq是因为我们不仅仅要对流体的速度进行对流，还需要对其他物理量进行对流。我们记对流项公式(3.1)(3.1)(3.1)的对流计算算法为advect(u⃗,Δt,q)advect(\\vec u, \\Delta t, q)advect(u,Δt,q)，即对于给定的时间步长Δt\\Delta tΔt和速度场u⃗\\vec uu，对物理量q进行对流。 对于体积力项(3.2)(3.2)(3.2)，我们采用简单的前向欧拉法即可：u⃗←u⃗+gΔt\\vec u \\leftarrow \\vec u + g\\Delta tu←u+gΔt。 对于压力/不可压缩项(3.3)(3.3)(3.3)，我们用一个称为project(Δt,u⃗)project(\\Delta t, \\vec u)project(Δt,u)的算法，通过project(Δt,u⃗)project(\\Delta t, \\vec u)project(Δt,u)计算出正确的压力以确保速度场u⃗\\vec uu的无散度性质。欧拉方案不会着重研究具体粒子间的作用力，因而不会正向去求解1ρ∇p\\frac{1}{\\rho}∇pρ1​∇p，它是利用流体不可压缩的特性，将速度场u⃗\\vec uu投影到散度为000的空间上，间接地解算了压力项。这种思想相当于，已知一个中间量u⃗temp\\vec u_{temp}utemp​，对这个中间量的唯一一个操作（如正向求解压力1ρ∇p\\frac{1}{\\rho}∇pρ1​∇p）不可行，但是直到最终量u⃗fianl\\vec u_{fianl}ufianl​符号的一个性质（散度为000），于是只要将u⃗temp\\vec u_{temp}utemp​投影到符合散度为000的特性平面上，即可间接地还原正向求解压力的操作，得到最终的速度场u⃗temp\\vec u_{temp}utemp​。 对流项advect(u⃗,Δt,q)advect(\\vec u, \\Delta t, q)advect(u,Δt,q)的输入速度场u⃗\\vec uu要确保为无散度的状态，投影项project(Δt,u⃗)project(\\Delta t, \\vec u)project(Δt,u)确保了流体体积保持不变，因而投影项输出的速度场必然是无散度的。所以我们只要确保投影项project(Δt,u⃗)project(\\Delta t, \\vec u)project(Δt,u)输出的速度场u⃗\\vec uu作为对流项advect(u⃗,Δt,q)advect(\\vec u, \\Delta t, q)advect(u,Δt,q)的输入即可，这时我们的分步求解流体方程的优势就体现出来了，其伪代码如下所示。 算法1 Fluid Simulation(u⃗n\\vec u_nun​, Δt\\Delta tΔt): **1: 初始化速度场u⃗n\\vec u_nun​,使得u⃗n\\vec u_nun​无散度 ** 2: 对于每个时间步n=0,1,2,...n = 0,1,2,...n=0,1,2,... **3: 决定一个合理的时间步长Δt=tn+1−tn\\Delta t = t_{n+1}-t_nΔt=tn+1​−tn​ ** **4: 对流项计算u⃗A=advect(u⃗n,Δt,q⃗)\\vec u_A=advect(\\vec u_n,\\Delta t,\\vec q)uA​=advect(un​,Δt,q​) ** 5: 体积力项计算u⃗B=u⃗A+Δtg⃗\\vec u_B=\\vec u_A+\\Delta t\\vec guB​=uA​+Δtg​ **6: 无散度投影u⃗n+1=project(Δt,u⃗B)\\vec u_{n+1}=project(\\Delta t,\\vec u_B)un+1​=project(Δt,uB​) ** 1、时间步长 在流体模拟算法中，确定适当的时间步长是算法的第一步。因为计算流体模拟的最后结果是呈现在屏幕上的，所以Δt\\Delta tΔt的选取与屏幕的刷新率有重要的关系。若选取的Δt\\Delta tΔt有tn+Δt&gt;tframet_n+\\Delta t &gt; t_{frame}tn​+Δt&gt;tframe​，那么必须做一个截断使Δt=tframe−tn\\Delta t=t_{frame}-t_nΔt=tframe​−tn​。此外，流体模拟的三个步骤即对流项、体积力项、无散度投影项对时间步长Δt\\Delta tΔt的要求不尽相同，要选择一个满足所有要求的最小时间步长能确保计算的收敛性。此外，一方面为了流体模拟的真实性，我们可能需要选取一个足够小的时间步长来复现流体的高质量细节。另一方面，有时高性能的需求又使得我们不能选取太小的时间步长去渲染一帧。假设一帧至少要进行三个时间步的模拟，那么Δt\\Delta tΔt应该至少设成帧间隔时间的三分之一。 2、网格结构 欧拉法的整个流程都是基于网格的，所以合理的网格结构是算法高效的关键点。HarlowHarlowHarlow和WelchWelchWelch提出了一种经典的MACMACMAC（marker and cell）网格结构，许多不可压缩流体模拟的算法都在这个网格结构上呈现出了良好的效率。MACMACMAC网格是一种交叉排列的网格，不同类型的物理量被存储于网格的不同位置。以二维的网格为例，如图3-1左图所示，流体粒子的压力数据存储于网格的中心点Pi,jP_{i,j}Pi,j​，而速度则沿着笛卡尔坐标被分成了两部分。水平方向的uuu成分被存储在了网格单元竖直边的中心处，例如网格单元(i,j)(i,j)(i,j)和(i+1,j)(i+1,j)(i+1,j)之间的水平速度记为ui+1/2,ju_{i+1/2,j}ui+1/2,j​。垂直方向的vvv成分则被存储在了网格单元水平面的中心上。这样的存储方案十分有利于估算流体流进/流出某个网格单元的量。 图3-1 MAC网格,左图二维,右图三维 扩展到三维的情况，MACMACMAC网格同样是交错排列的结构网格，如图3-1右图所示。压力数值存储在立方体网格单元的中心，三个速度分量分别被记录在立方体网格单元的三个表面的中心点上。在数值计算时，这样的分配方式使得我们可以准确地采用中心差分法计算压力梯度和速度的散度，同时克服了中心差分法的一个普遍的缺点。一维的情况为例，在网格顶点位置...,qi−1,qi,qi+1......,q_{i-1},q_i,q_{i+1}......,qi−1​,qi​,qi+1​...上估算量场qqq的导数，为了无偏（所谓无偏，就是不偏向左边或者右边）估计网格顶点iii处的∂q∂x\\frac{\\partial q}{\\partial x}∂x∂q​，一种比较自然的方式就是采用一阶中心差分法： (3.4)(∂q∂x)i≈qi+1−qi−12Δx(\\frac{\\partial q}{\\partial x})_i\\approx \\frac{q_{i+1}-q_{i-1}}{2\\Delta x} \\tag {3.4} (∂x∂q​)i​≈2Δxqi+1​−qi−1​​(3.4) 公式(3.4)(3.4)(3.4)是无偏的，且精确度为O(Δx2)O(\\Delta x^2)O(Δx2)。而前向欧拉差分法偏向右边且精确度只有O(Δx)O(\\Delta x)O(Δx)： (3.5)(∂q∂x)i≈qi+1−qiΔx(\\frac{\\partial q}{\\partial x})_i\\approx \\frac{q_{i+1}-q_i}{\\Delta x} \\tag {3.5} (∂x∂q​)i​≈Δxqi+1​−qi​​(3.5) 然而，公式(3.4)(3.4)(3.4)存在着一个非常严重的问题：网格点iii的估算导数完全忽略了qiq_iqi​的值。数学上，只有常数函数的一阶导数为零。但是公式(3.4)(3.4)(3.4)遇到了锯齿函数如qi=(−1)iq_i=(-1)^iqi​=(−1)i时，它错误地将该类函数的导数估算为000，这种问题被称为零空间问题（null-space problem）。 交叉错排的MACMACMAC网格完美地克服了中心差分法的零空间问题，同时也保持了它的无偏二阶精度。在MACMACMAC网格上运用中心差分法，网格点iii处的估算导数公式如下所示： (3.6)(∂q∂x)i≈qi+1/2−qi−1/2Δx(\\frac{\\partial q}{\\partial x})_i\\approx\\frac{q_{i+1/2}-q_{i-1/2}}{\\Delta x} \\tag {3.6} (∂x∂q​)i​≈Δxqi+1/2​−qi−1/2​​(3.6) MACMACMAC网格确实给流体的压力计算和不可压缩性的处理带来了很大的便利，但与此同时也带来了一些其他方面的麻烦。如果我们要估算某个地方的速度向量，即便采样点恰好在网格点上我们也要做一些插值才能获取相应的速度向量。在网格点处，我们通常采用平均法，以二维为例： (3.7)u⃗i,j=(ui−1/2,j+ui+1/2,j2,vi,j−1/2+vi,j+1/22),u⃗i+1/2,j=(ui+1/2,j,vi,j−1/2+vi,j+1/2+vi+1,j−1/2+vi+1,j+1/24),u⃗i,j+1/2=(ui−1/2,j+ui+1/2,j+ui−1/2,j+1+ui+1/2,j+14,vi,j+1/2).\\vec u_{i,j}=(\\frac{u_{i-1/2,j}+u_{i+1/2,j}}{2},\\frac{v_{i,j-1/2}+v_{i,j+1/2}}{2}),\\\\ \\vec u_{i+1/2,j}=(u_{i+1/2,j},\\frac{v_{i,j-1/2}+v_{i,j+1/2}+v_{i+1,j-1/2}+v_{i+1,j+1/2}}{4}),\\\\ \\vec u_{i,j+1/2}=(\\frac{u_{i-1/2,j}+u_{i+1/2,j}+u_{i-1/2,j+1}+u_{i+1/2,j+1}}{4},v_{i,j+1/2}).\\tag {3.7} ui,j​=(2ui−1/2,j​+ui+1/2,j​​,2vi,j−1/2​+vi,j+1/2​​),ui+1/2,j​=(ui+1/2,j​,4vi,j−1/2​+vi,j+1/2​+vi+1,j−1/2​+vi+1,j+1/2​​),ui,j+1/2​=(4ui−1/2,j​+ui+1/2,j​+ui−1/2,j+1​+ui+1/2,j+1​​,vi,j+1/2​).(3.7) 最后，在实现中下标索引一般没有浮点数之说，前面直接采用i+1/2i+1/2i+1/2的记法是为了便于叙述。一般约定如下： (3.8)p(i,j,k)=pi,j,k,u(i,j,k)=ui−1/2,j,k,v(i,j,k)=vi,j−1/2,k,w(i,j,k)=wi,j,k−1/2.p(i,j,k)=p_{i,j,k},\\\\ u(i,j,k)=u_{i-1/2,j,k},\\\\ v(i,j,k)=v_{i,j-1/2,k},\\\\ w(i,j,k)=w_{i,j,k-1/2}. \\tag{3.8} p(i,j,k)=pi,j,k​,u(i,j,k)=ui−1/2,j,k​,v(i,j,k)=vi,j−1/2,k​,w(i,j,k)=wi,j,k−1/2​.(3.8) 因而对于nx×ny×nznx\\times ny\\times nznx×ny×nz分辨率的网格，压力数值存储在nx×ny×nznx\\times ny\\times nznx×ny×nz的数组中，速度的uuu成分存储在(nx+1)×ny×nz(nx+1)\\times ny\\times nz(nx+1)×ny×nz数组中，速度的vvv成分存储在nx×(ny+1)×nznx\\times (ny+1)\\times nznx×(ny+1)×nz数组中，速度的www成分存储在nx×ny×(nz+1)nx\\times ny\\times (nz+1)nx×ny×(nz+1)数组中。 四、对流算法 求解如下所示的对流方程是流体模拟的关键一步： (4.1)DqDt=0\\frac{Dq}{Dt}=0 \\tag {4.1} DtDq​=0(4.1) 我们把这个对流数值计算的算法记为： (4.2)qn+1=advect(u⃗,Δt,qn)q^{n+1}=advect(\\vec u,\\Delta t,q^n) \\tag {4.2} qn+1=advect(u,Δt,qn)(4.2) 公式(4.2)(4.2)(4.2)中的各个符号含义： u⃗\\vec uu：在MACMACMAC网格上的离散化的速度场； Δt\\Delta tΔt：时间步长； qnq^nqn：当前的物理量场qqq（如流体密度、速度、燃烧物浓度等）； qn+1q^{n+1}qn+1：经过对流后得到的新的量场。 在这里要特别注意，输入对流算法的速度场u⃗\\vec uu必须是无散度的，否则模拟结果会出现一些奇怪的失真现象。 1、半拉格朗日对流算法（Semi-Lagrangian Advection） 一维情况下，对流方程(4.1)(4.1)(4.1)写成偏微分的形式如下： (4.3)∂q∂t+u∂q∂x=0\\frac{\\partial q}{\\partial t}+u\\frac{\\partial q}{\\partial x}=0 \\tag {4.3} ∂t∂q​+u∂x∂q​=0(4.3) 分别采用前向欧拉差分法计算对时间的偏导和中心差分法计算对空间的偏导，我们有： (4.4)qin+1−qinΔt+uinqi+1n−qi−1n2Δx=0\\frac{q^{n+1}_{i}-q^n_i}{\\Delta t}+u^n_i\\frac{q^n_{i+1}-q^n_{i-1}}{2\\Delta x}=0 \\tag {4.4} Δtqin+1​−qin​​+uin​2Δxqi+1n​−qi−1n​​=0(4.4) 转成以qin+1q^{n+1}_iqin+1​为计算目标的显式公式，得： (4.5)qin+1=qin−Δtuinqi+1n−qi−1n2Δxq^{n+1}_i=q^n_i-\\Delta t u^n_i\\frac{q^n_{i+1}-q^n_{i-1}}{2\\Delta x} \\tag {4.5} qin+1​=qin​−Δtuin​2Δxqi+1n​−qi−1n​​(4.5) 公式(4.5)(4.5)(4.5)看起来没什么问题，但是却存在非常严重的漏洞。首先，前向欧拉法被证明是无条件不稳定的空间离散方法：无论取多么小Δ𝑡，随着时间步的推进，累积误差终将发散。即使使用更稳定的时间积分方法来取代前向欧拉方法，解决了时间上的PDE（Partial Differential Equation，偏微分方程）计算，空间上的PDE计算还是会带来重大的麻烦。标准中心差分方法不可避免地会出现的零空间问题，具有高频震荡性质的速度场对空间的导数被错误地计算为000或几乎为000，低离速度分量被分离出来，从而导致模拟效果中出现许多奇怪的高频摆动和震荡。 针对这些问题，研究者们提出了一个解然不同的、更加简单和更具物理直观意义的半拉格朗日法。之所以叫半拉格朗日法，是因为这种方法是以拉格朗日视角去解决欧拉视角的对流方程（“半”字的由来）。假设我们的目标是求解网格点x⃗G\\vec x_GxG​的在第n+1n+1n+1个时间步时关于物理量qqq的新值，记为qGn+1q^{n+1}_GqGn+1​。在拉格朗日的视角下，我们可以寻找在第n+1n+1n+1时间步之前，是空间中的哪一个点上的流体粒子在速度场u⃗\\vec uu的作用下“流向”了x⃗G\\vec x_GxG​，我们记这个粒子在第nnn个时间步时的网格位置为x⃗P\\vec x_PxP​，则第n+1n+1n+1个时间步时x⃗G\\vec x_GxG​的qGn+1q^{n+1}_GqGn+1​即为第nnn个时间步时x⃗P\\vec x_PxP​的qPnq^{n}_PqPn​。如下图4-1为半拉格朗日对流法的示意图。 图4-1 半拉格朗日对流法 半拉格朗日对流法的第一步就是要找出x⃗P\\vec x_PxP​，为此我们根据x⃗G\\vec x_GxG​做反向的追踪。粒子位置对时间的导数就是速度场： (4.6)dx⃗dt=u⃗(x⃗)\\frac{d\\vec x}{dt}=\\vec u(\\vec x) \\tag {4.6} dtdx​=u(x)(4.6) 经过一个时间步长Δt\\Delta tΔt之后，粒子由x⃗P\\vec x_PxP​移动到x⃗G\\vec x_GxG​。为了得到x⃗P\\vec x_PxP​，最简单的方法就是采用前向欧拉法进行倒推： (4.7)x⃗P=x⃗G−Δtu⃗(x⃗G)\\vec x_P=\\vec x_G-\\Delta t\\vec u(\\vec x_G) \\tag {4.7} xP​=xG​−Δtu(xG​)(4.7) 然而前向欧拉法只有一阶的精度，若在不改变Δt\\Delta tΔt的情况下提高精度，我们可以采用高阶的龙格库塔法（Runge-Kutta method）。采用二阶的龙格库塔法如下所示： (4.7)x⃗mid=x⃗G−12Δtu⃗(x⃗G),x⃗P=x⃗G−Δtu⃗(x⃗mid).\\vec x_{mid}=\\vec x_G-\\frac12\\Delta t\\vec u(\\vec x_G),\\\\ \\vec x_P=\\vec x_G-\\Delta t\\vec u(\\vec x_{mid}). \\tag {4.7} xmid​=xG​−21​Δtu(xG​),xP​=xG​−Δtu(xmid​).(4.7) 倒推得到Δt\\Delta tΔt之前的网格位置x⃗P\\vec x_PxP​一般不会恰好在网格顶点上，为此我们需要做些插值。三维模拟通常采用三线性插值，而二维的则采用双线性插值。 (4.8)qGn+1=interpolate(qn,x⃗P)q^{n+1}_G=interpolate(q_n,\\vec x_P) \\tag {4.8} qGn+1​=interpolate(qn​,xP​)(4.8) 2、边界情况 若我们倒推得到的x⃗P\\vec x_PxP​仍然在流体的内部，那么做插值是完全没问题的。但若x⃗P\\vec x_PxP​在流体的边界之外呢？这种情况的出现的原因通常有两个：一个是x⃗P\\vec x_PxP​确确实实在流体的外部且即将流入流体内部，另一个是由前向欧拉法或龙格库塔法的数值计算方法带来的误差导致。 在一种情况下，我们应该知道当流体流入时其携带的物理量，此时我们将这个外部流入的物理量作为返回值即可。例如，第nnn个时间步时的外部流体以速度U⃗\\vec UU和温度TTT在第n+1n+1n+1个时间步时注入流体内部x⃗G\\vec x_GxG​的位置，那么T⃗Gn+1\\vec T^{n+1}_GTGn+1​的值就为TTT。 在第二种由误差导致的情况下，一个适当的策略就是根据边界上的最近点外推出所求得物理量。在模拟某些流体时，外推变得很简单。例如，在模拟烟雾时我们简单地假设烟雾流体外部即空气的速度风场为某个常数U⃗\\vec UU（可能为000），这样边界上的速度场都取U⃗\\vec UU。但还有一些必须根据流体内部的已知量外推出未知量，这时情况就变得比较复杂了。具体如何外推将在后面介绍，目前我们只需要知道大概的步骤：首先寻找边界上的最近点，然后在最近点的领域内插值获取相应的物理量场。 3、时间步长大小 对任何一种数值计算方法的主要的考虑点就是它是否稳定。幸运的是，半拉格朗日对流法已经被证明是一种无条件稳定的算法：无论Δt\\Delta tΔt取多大，它永远不会出现数值爆炸的现象。因为每一个新值qqq的确定，都是通过对旧值得插值，无论是线性插值、双线性插值还是三线性插值，qqq的大小都是处于插值点之间，不会得到比原来插值点更大或者更小的值，因而qqq是有上下界的。这使得我们可以尽情地根据所需的模拟质量和模拟效率去调整时间步长。 但是在实践中，时间步长的大小也不能选得太过极端，否则会产生一些奇观的现象。Foster和Fekiw提出了一个对Δt\\Delta tΔt的限制：流体粒子在Δt\\Delta tΔt内的倒推轨迹最多经过某个常数个网格单元为宜，例如5个： (4.9)Δt≤5Δxumax\\Delta t \\leq \\frac{5\\Delta x}{u_{max}} \\tag {4.9} Δt≤umax​5Δx​(4.9) 公式(4.9)(4.9)(4.9)中，umaxu_{max}umax​是速度场的最大值，我们可以简单地取 存储在网格中的最大速度值。一个更鲁棒的方法考虑了体积力（如重力、浮力等）对最大速度的影响： (4.10)umax=max(∣un∣)+Δt∣g∣u_{max}=max(|u^n|)+\\Delta t|g| \\tag {4.10} umax​=max(∣un∣)+Δt∣g∣(4.10) 将不等式(4.9)(4.9)(4.9)的最大值带入公式(4.10)(4.10)(4.10)，我们有： (4.11)umax=max(∣un∣)+5Δxumax∣g∣u_{max}=max(|u^n|)+\\frac{5\\Delta x}{u_{max}}|g| \\tag {4.11} umax​=max(∣un∣)+umax​5Δx​∣g∣(4.11) 取一个简单的速度上界（简化了公式(4.11)(4.11)(4.11)），umaxu_{max}umax​： (4.12)umax=max(∣un∣)+5Δxgu_{max}=max(|u^n|)+\\sqrt{5\\Delta xg} \\tag {4.12} umax​=max(∣un∣)+5Δxg​(4.12) 这样确保了umaxu_{max}umax​始终为正，且避免公式(4.9)(4.9)(4.9)的除000错误。 关于时间步长的讨论离不开CFLCFLCFL（以Courant、Friedrichs、Lewy三人的名字命名）条件。CFLCFLCFL条件是一个简单而直观的判断计算是否收敛的必要条件。它的直观物理解释就是时间推进求解的速度必须大于物理扰动传播的速度，只有这样才能将物理上所有的扰动俘获到。满足CFLCFLCFL条件意味着当Δx\\Delta xΔx和Δt\\Delta tΔt趋于取极限000时，数值计算所求的解就会收敛到原微分方程的解。 对于半拉格朗日对流法，其满足CFLCFLCFL条件当且仅当在极限情况下，追踪得到的粒子轨迹足够逼近真实的轨迹。足够逼近的意思是经过正确的网格插值能够得到正确的依赖域（即差分格式的依赖域包含了原微分方程的依赖域），追踪的轨迹就会收敛到正确真实的轨迹。 因而，对于采用标准的显式有限差分法的对流方程求解，为了保证收敛，我们要求qn+1q^{n+1}qn+1的新值是由以当前网格点为中心、以CΔxC\\Delta xCΔx（CCC是一个小的整数常量）为半径的邻域范围内插值得到： (4.13)Δt≤CΔx∣u⃗∣\\Delta t \\leq C\\frac{\\Delta x}{|\\vec u|} \\tag {4.13} Δt≤C∣u∣Δx​(4.13) 公式(4.13)(4.13)(4.13)中的CCC被称为CFLCFLCFL数，因而不等式(4.9)(4.9)(4.9)可以看成是公式(4.13)(4.13)(4.13)取CFLCFLCFL数为555得到。 4、数值耗散 对流算法在对流获取新的物理量场qin+1q^{n+1}_iqin+1​时会进行一些插值操作，插值不可避免地会平滑物理量场，这带来了一些数值耗散。一次两次的数值耗散不会由太大的影响，但是在流体模拟中我们会在每个时间步都进行对流运算，反反复复的平滑操作将数值耗散不断扩大，损失大量的流体细节。 以一维的对流项计算为例，流体速度为常量u&gt;0u&gt;0u&gt;0： (4.14)∂q∂t+u∂q∂x=0\\frac{\\partial q}{\\partial t}+u\\frac{\\partial q}{\\partial x}=0 \\tag {4.14} ∂t∂q​+u∂x∂q​=0(4.14) 假设Δt&lt;Δxu\\Delta t &lt; \\frac{\\Delta x}{u}Δt&lt;uΔx​，即单个时间步长内粒子追踪轨迹长度小于单个网格单元的大小。我们的目标点是xix_ixi​，则倒推得到的粒子位置就落在了[xi−1,xi][x_{i-1},x_i][xi−1​,xi​]上的xi−Δtux_i-\\Delta tuxi​−Δtu，然后进行线性插值得到qin+1q^{n+1}_iqin+1​： (4.15)qn+1=ΔtuΔxqi−1n+(1−ΔtuΔx)qinq^{n+1}=\\frac{\\Delta tu}{\\Delta x}q^n_{i-1}+(1-\\frac{\\Delta tu}{\\Delta x})q^n_i \\tag {4.15} qn+1=ΔxΔtu​qi−1n​+(1−ΔxΔtu​)qin​(4.15) 将公式(4.15)(4.15)(4.15)整理一下，有： (4.16)qin+1=qin−Δtuqin−qi−1nΔxq^{n+1}_i=q^n_i-\\Delta tu\\frac{q^n_i-q^n_{i-1}}{\\Delta x} \\tag {4.16} qin+1​=qin​−ΔtuΔxqin​−qi−1n​​(4.16) 公式(4.16)(4.16)(4.16)实际上正好就是采用时间上的前向欧拉差分法和空间上的单向有限差分法的欧拉方案，把qinq^n_iqin​看成是qnq^nqn关于xix_ixi​的函数，对qi−1nq^n_{i-1}qi−1n​进行泰勒级数展开： (4.17)qi−1n=qin−(∂q∂x)inΔx+(∂2q∂x2)inΔx22+O(Δx3)q^n_{i-1}=q^n_i-(\\frac{\\partial q}{\\partial x})^n_i\\Delta x+(\\frac{\\partial^2q}{\\partial x^2})^n_i\\frac{\\Delta x^2}{2}+O(\\Delta x^3) \\tag {4.17} qi−1n​=qin​−(∂x∂q​)in​Δx+(∂x2∂2q​)in​2Δx2​+O(Δx3)(4.17) 将公式(4.17)(4.17)(4.17)代入公式(4.16)(4.16)(4.16)，并做一些变量消去，可得： (4.18)qin+1=qin−Δtu(∂q∂x)in+ΔtuΔx(∂2q∂x2)in+O(Δx2)q^{n+1}_i=q^n_i-\\Delta tu(\\frac{\\partial q}{\\partial x})^n_i+\\Delta tu\\Delta x(\\frac{\\partial^2q}{\\partial x^2})^n_i+O(\\Delta x^2) \\tag {4.18} qin+1​=qin​−Δtu(∂x∂q​)in​+ΔtuΔx(∂x2∂2q​)in​+O(Δx2)(4.18) 在二阶截断误差的情况下，结合公式(4.18)(4.18)(4.18)和公式(4.14)(4.14)(4.14)，有： (4.19)∂q∂t+u∂q∂x=uΔx(∂2q∂x2)\\frac{\\partial q}{\\partial t}+u\\frac{\\partial q}{\\partial x}=u\\Delta x(\\frac{\\partial^2q}{\\partial x^2}) \\tag {4.19} ∂t∂q​+u∂x∂q​=uΔx(∂x2∂2q​)(4.19) 右边就是对流方程计算时引入的额外类似粘度乘上系数uΔxu\\Delta xuΔx的项。**这也就是说，当我们采用简单的半拉格朗日法去求解无粘度的对流方程时，模拟的结果却看起来我们像时在模拟有粘度的流体。这就是数值耗散！**当然，当Δx→0\\Delta x\\to 0Δx→0时，这个数值耗散系数也会趋于000，所以取时间步无穷小时能够得到正确的模拟结果，但这需要耗费巨额的计算资源开销。我们通常模拟的流体大多数都是无粘度的，所以如何减少这个数值耗散是个至关重要的难题。 一个简单有效的修复数值耗散的方法就是采用更加锐利的插值方法，从而尽可能地减少由插值带来的数值耗散。在一维的情况时，我们采用三次插值（cubic interpolant）如下公式(4.21)(4.21)(4.21)，而不是简单的一次线性插值(4.20)(4.20)(4.20)： (4.20)q≈(1−s)xi+sxi+1q\\approx(1-s)x_i+sx_{i+1} \\tag {4.20} q≈(1−s)xi​+sxi+1​(4.20) (4.21)q≈[−13s+12s2−16s3]qi−1+[1−s2+12(s3−s)]qi+[s+12(s2−s3)]qi+1+[16(s3−s)]qi+2q\\approx[-\\frac13s+\\frac12s^2-\\frac16s^3]q_{i-1}+[1-s^2+\\frac12(s^3-s)]q_i\\\\ +[s+\\frac12(s^2-s^3)]q_{i+1}+[\\frac16(s^3-s)]q_{i+2} \\tag {4.21} q≈[−31​s+21​s2−61​s3]qi−1​+[1−s2+21​(s3−s)]qi​+[s+21​(s2−s3)]qi+1​+[61​(s3−s)]qi+2​(4.21) 扩展到二维或者三维就是双三次插值（bicubic interpolation）或三三次插值（tricubic interpolation）。以二维情况为例，我们可以先沿着xxx轴做第一遍的三次插值如公式(4.22)(4.22)(4.22)，然后再沿着yyy轴做第二遍插值如公式(4.23)(4.23)(4.23)： (4.22)qj−1=w−1(s)qi−1,j−1+w0(s)+qi,j−1+w1(s)qi+1,j−1+w2(s)qi+2,j−1,qj=w−1(s)qi−1,j+w0(s)+qi,j+w1(s)qi+1,j+w2(s)qi+2,j,qj+1=w−1(s)qi−1,j+1+w0(s)+qi,j+1+w1(s)qi+1,j+1+w2(s)qi+2,j+1,qj+2=w−1(s)qi−1,j+2+w0(s)+qi,j+2+w1(s)qi+1,j+2+w2(s)qi+2,j+2.q_{j-1}=w_{-1}(s)q_{i-1,j-1}+w_0(s)+q_{i,j-1}+w_1(s)q_{i+1,j-1}+w_2(s)q_{i+2,j-1},\\\\ q_{j}=w_{-1}(s)q_{i-1,j}+w_0(s)+q_{i,j}+w_1(s)q_{i+1,j}+w_2(s)q_{i+2,j},\\\\ q_{j+1}=w_{-1}(s)q_{i-1,j+1}+w_0(s)+q_{i,j+1}+w_1(s)q_{i+1,j+1}+w_2(s)q_{i+2,j+1},\\\\ q_{j+2}=w_{-1}(s)q_{i-1,j+2}+w_0(s)+q_{i,j+2}+w_1(s)q_{i+1,j+2}+w_2(s)q_{i+2,j+2}. \\tag {4.22} qj−1​=w−1​(s)qi−1,j−1​+w0​(s)+qi,j−1​+w1​(s)qi+1,j−1​+w2​(s)qi+2,j−1​,qj​=w−1​(s)qi−1,j​+w0​(s)+qi,j​+w1​(s)qi+1,j​+w2​(s)qi+2,j​,qj+1​=w−1​(s)qi−1,j+1​+w0​(s)+qi,j+1​+w1​(s)qi+1,j+1​+w2​(s)qi+2,j+1​,qj+2​=w−1​(s)qi−1,j+2​+w0​(s)+qi,j+2​+w1​(s)qi+1,j+2​+w2​(s)qi+2,j+2​.(4.22) (4.23)q=w−1(t)qj−1+w0(t)qj+w1(t)qj+1+w2(t)qj+2q=w_{-1}(t)q_{j-1}+w_0(t)q_j+w_1(t)q_{j+1}+w_2(t)q_{j+2} \\tag {4.23} q=w−1​(t)qj−1​+w0​(t)qj​+w1​(t)qj+1​+w2​(t)qj+2​(4.23) 当然也可以先沿着yyy轴，然后再沿着xxx轴做插值操作。","categories":[{"name":"Computer Graphics","slug":"Computer-Graphics","permalink":"http://yoursite.com/categories/Computer-Graphics/"},{"name":"Fluid Simulation","slug":"Fluid-Simulation","permalink":"http://yoursite.com/categories/Fluid-Simulation/"}],"tags":[{"name":"Computer Graphics","slug":"Computer-Graphics","permalink":"http://yoursite.com/tags/Computer-Graphics/"},{"name":"Naiver-Stokes Equations","slug":"Naiver-Stokes-Equations","permalink":"http://yoursite.com/tags/Naiver-Stokes-Equations/"},{"name":"Fluid Simulation","slug":"Fluid-Simulation","permalink":"http://yoursite.com/tags/Fluid-Simulation/"},{"name":"Advection","slug":"Advection","permalink":"http://yoursite.com/tags/Advection/"}]}]}